
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Crop
 * 
 */
export type Crop = $Result.DefaultSelection<Prisma.$CropPayload>
/**
 * Model Livestock
 * 
 */
export type Livestock = $Result.DefaultSelection<Prisma.$LivestockPayload>
/**
 * Model CropSpray
 * 
 */
export type CropSpray = $Result.DefaultSelection<Prisma.$CropSprayPayload>
/**
 * Model CropHarvest
 * 
 */
export type CropHarvest = $Result.DefaultSelection<Prisma.$CropHarvestPayload>
/**
 * Model MilkLog
 * 
 */
export type MilkLog = $Result.DefaultSelection<Prisma.$MilkLogPayload>
/**
 * Model EggLog
 * 
 */
export type EggLog = $Result.DefaultSelection<Prisma.$EggLogPayload>
/**
 * Model HoneyLog
 * 
 */
export type HoneyLog = $Result.DefaultSelection<Prisma.$HoneyLogPayload>
/**
 * Model WoolLog
 * 
 */
export type WoolLog = $Result.DefaultSelection<Prisma.$WoolLogPayload>
/**
 * Model WeightLog
 * 
 */
export type WeightLog = $Result.DefaultSelection<Prisma.$WeightLogPayload>
/**
 * Model LivestockMetric
 * 
 */
export type LivestockMetric = $Result.DefaultSelection<Prisma.$LivestockMetricPayload>
/**
 * Model CropQualityLog
 * 
 */
export type CropQualityLog = $Result.DefaultSelection<Prisma.$CropQualityLogPayload>
/**
 * Model CropMetric
 * 
 */
export type CropMetric = $Result.DefaultSelection<Prisma.$CropMetricPayload>
/**
 * Model SupportProgram
 * 
 */
export type SupportProgram = $Result.DefaultSelection<Prisma.$SupportProgramPayload>
/**
 * Model WeatherAlert
 * 
 */
export type WeatherAlert = $Result.DefaultSelection<Prisma.$WeatherAlertPayload>
/**
 * Model MarketListing
 * 
 */
export type MarketListing = $Result.DefaultSelection<Prisma.$MarketListingPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  farmer: 'farmer',
  ministry: 'ministry'
};

export type Role = (typeof Role)[keyof typeof Role]


export const ItemType: {
  crop: 'crop',
  livestock: 'livestock'
};

export type ItemType = (typeof ItemType)[keyof typeof ItemType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type ItemType = $Enums.ItemType

export const ItemType: typeof $Enums.ItemType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.crop`: Exposes CRUD operations for the **Crop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Crops
    * const crops = await prisma.crop.findMany()
    * ```
    */
  get crop(): Prisma.CropDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.livestock`: Exposes CRUD operations for the **Livestock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Livestocks
    * const livestocks = await prisma.livestock.findMany()
    * ```
    */
  get livestock(): Prisma.LivestockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cropSpray`: Exposes CRUD operations for the **CropSpray** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CropSprays
    * const cropSprays = await prisma.cropSpray.findMany()
    * ```
    */
  get cropSpray(): Prisma.CropSprayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cropHarvest`: Exposes CRUD operations for the **CropHarvest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CropHarvests
    * const cropHarvests = await prisma.cropHarvest.findMany()
    * ```
    */
  get cropHarvest(): Prisma.CropHarvestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.milkLog`: Exposes CRUD operations for the **MilkLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MilkLogs
    * const milkLogs = await prisma.milkLog.findMany()
    * ```
    */
  get milkLog(): Prisma.MilkLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eggLog`: Exposes CRUD operations for the **EggLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EggLogs
    * const eggLogs = await prisma.eggLog.findMany()
    * ```
    */
  get eggLog(): Prisma.EggLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.honeyLog`: Exposes CRUD operations for the **HoneyLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HoneyLogs
    * const honeyLogs = await prisma.honeyLog.findMany()
    * ```
    */
  get honeyLog(): Prisma.HoneyLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.woolLog`: Exposes CRUD operations for the **WoolLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WoolLogs
    * const woolLogs = await prisma.woolLog.findMany()
    * ```
    */
  get woolLog(): Prisma.WoolLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weightLog`: Exposes CRUD operations for the **WeightLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeightLogs
    * const weightLogs = await prisma.weightLog.findMany()
    * ```
    */
  get weightLog(): Prisma.WeightLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.livestockMetric`: Exposes CRUD operations for the **LivestockMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LivestockMetrics
    * const livestockMetrics = await prisma.livestockMetric.findMany()
    * ```
    */
  get livestockMetric(): Prisma.LivestockMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cropQualityLog`: Exposes CRUD operations for the **CropQualityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CropQualityLogs
    * const cropQualityLogs = await prisma.cropQualityLog.findMany()
    * ```
    */
  get cropQualityLog(): Prisma.CropQualityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cropMetric`: Exposes CRUD operations for the **CropMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CropMetrics
    * const cropMetrics = await prisma.cropMetric.findMany()
    * ```
    */
  get cropMetric(): Prisma.CropMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supportProgram`: Exposes CRUD operations for the **SupportProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupportPrograms
    * const supportPrograms = await prisma.supportProgram.findMany()
    * ```
    */
  get supportProgram(): Prisma.SupportProgramDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weatherAlert`: Exposes CRUD operations for the **WeatherAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeatherAlerts
    * const weatherAlerts = await prisma.weatherAlert.findMany()
    * ```
    */
  get weatherAlert(): Prisma.WeatherAlertDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marketListing`: Exposes CRUD operations for the **MarketListing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketListings
    * const marketListings = await prisma.marketListing.findMany()
    * ```
    */
  get marketListing(): Prisma.MarketListingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.0
   * Query Engine version: c0aafc03b8ef6cdced8654b9a817999e02457d6a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Crop: 'Crop',
    Livestock: 'Livestock',
    CropSpray: 'CropSpray',
    CropHarvest: 'CropHarvest',
    MilkLog: 'MilkLog',
    EggLog: 'EggLog',
    HoneyLog: 'HoneyLog',
    WoolLog: 'WoolLog',
    WeightLog: 'WeightLog',
    LivestockMetric: 'LivestockMetric',
    CropQualityLog: 'CropQualityLog',
    CropMetric: 'CropMetric',
    SupportProgram: 'SupportProgram',
    WeatherAlert: 'WeatherAlert',
    MarketListing: 'MarketListing',
    Notification: 'Notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "crop" | "livestock" | "cropSpray" | "cropHarvest" | "milkLog" | "eggLog" | "honeyLog" | "woolLog" | "weightLog" | "livestockMetric" | "cropQualityLog" | "cropMetric" | "supportProgram" | "weatherAlert" | "marketListing" | "notification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Crop: {
        payload: Prisma.$CropPayload<ExtArgs>
        fields: Prisma.CropFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CropFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CropFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>
          }
          findFirst: {
            args: Prisma.CropFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CropFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>
          }
          findMany: {
            args: Prisma.CropFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>[]
          }
          create: {
            args: Prisma.CropCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>
          }
          createMany: {
            args: Prisma.CropCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CropCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>[]
          }
          delete: {
            args: Prisma.CropDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>
          }
          update: {
            args: Prisma.CropUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>
          }
          deleteMany: {
            args: Prisma.CropDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CropUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CropUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>[]
          }
          upsert: {
            args: Prisma.CropUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>
          }
          aggregate: {
            args: Prisma.CropAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrop>
          }
          groupBy: {
            args: Prisma.CropGroupByArgs<ExtArgs>
            result: $Utils.Optional<CropGroupByOutputType>[]
          }
          count: {
            args: Prisma.CropCountArgs<ExtArgs>
            result: $Utils.Optional<CropCountAggregateOutputType> | number
          }
        }
      }
      Livestock: {
        payload: Prisma.$LivestockPayload<ExtArgs>
        fields: Prisma.LivestockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LivestockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivestockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LivestockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivestockPayload>
          }
          findFirst: {
            args: Prisma.LivestockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivestockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LivestockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivestockPayload>
          }
          findMany: {
            args: Prisma.LivestockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivestockPayload>[]
          }
          create: {
            args: Prisma.LivestockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivestockPayload>
          }
          createMany: {
            args: Prisma.LivestockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LivestockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivestockPayload>[]
          }
          delete: {
            args: Prisma.LivestockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivestockPayload>
          }
          update: {
            args: Prisma.LivestockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivestockPayload>
          }
          deleteMany: {
            args: Prisma.LivestockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LivestockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LivestockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivestockPayload>[]
          }
          upsert: {
            args: Prisma.LivestockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivestockPayload>
          }
          aggregate: {
            args: Prisma.LivestockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLivestock>
          }
          groupBy: {
            args: Prisma.LivestockGroupByArgs<ExtArgs>
            result: $Utils.Optional<LivestockGroupByOutputType>[]
          }
          count: {
            args: Prisma.LivestockCountArgs<ExtArgs>
            result: $Utils.Optional<LivestockCountAggregateOutputType> | number
          }
        }
      }
      CropSpray: {
        payload: Prisma.$CropSprayPayload<ExtArgs>
        fields: Prisma.CropSprayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CropSprayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropSprayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CropSprayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropSprayPayload>
          }
          findFirst: {
            args: Prisma.CropSprayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropSprayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CropSprayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropSprayPayload>
          }
          findMany: {
            args: Prisma.CropSprayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropSprayPayload>[]
          }
          create: {
            args: Prisma.CropSprayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropSprayPayload>
          }
          createMany: {
            args: Prisma.CropSprayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CropSprayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropSprayPayload>[]
          }
          delete: {
            args: Prisma.CropSprayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropSprayPayload>
          }
          update: {
            args: Prisma.CropSprayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropSprayPayload>
          }
          deleteMany: {
            args: Prisma.CropSprayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CropSprayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CropSprayUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropSprayPayload>[]
          }
          upsert: {
            args: Prisma.CropSprayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropSprayPayload>
          }
          aggregate: {
            args: Prisma.CropSprayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCropSpray>
          }
          groupBy: {
            args: Prisma.CropSprayGroupByArgs<ExtArgs>
            result: $Utils.Optional<CropSprayGroupByOutputType>[]
          }
          count: {
            args: Prisma.CropSprayCountArgs<ExtArgs>
            result: $Utils.Optional<CropSprayCountAggregateOutputType> | number
          }
        }
      }
      CropHarvest: {
        payload: Prisma.$CropHarvestPayload<ExtArgs>
        fields: Prisma.CropHarvestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CropHarvestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropHarvestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CropHarvestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropHarvestPayload>
          }
          findFirst: {
            args: Prisma.CropHarvestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropHarvestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CropHarvestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropHarvestPayload>
          }
          findMany: {
            args: Prisma.CropHarvestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropHarvestPayload>[]
          }
          create: {
            args: Prisma.CropHarvestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropHarvestPayload>
          }
          createMany: {
            args: Prisma.CropHarvestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CropHarvestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropHarvestPayload>[]
          }
          delete: {
            args: Prisma.CropHarvestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropHarvestPayload>
          }
          update: {
            args: Prisma.CropHarvestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropHarvestPayload>
          }
          deleteMany: {
            args: Prisma.CropHarvestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CropHarvestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CropHarvestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropHarvestPayload>[]
          }
          upsert: {
            args: Prisma.CropHarvestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropHarvestPayload>
          }
          aggregate: {
            args: Prisma.CropHarvestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCropHarvest>
          }
          groupBy: {
            args: Prisma.CropHarvestGroupByArgs<ExtArgs>
            result: $Utils.Optional<CropHarvestGroupByOutputType>[]
          }
          count: {
            args: Prisma.CropHarvestCountArgs<ExtArgs>
            result: $Utils.Optional<CropHarvestCountAggregateOutputType> | number
          }
        }
      }
      MilkLog: {
        payload: Prisma.$MilkLogPayload<ExtArgs>
        fields: Prisma.MilkLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MilkLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilkLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MilkLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilkLogPayload>
          }
          findFirst: {
            args: Prisma.MilkLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilkLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MilkLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilkLogPayload>
          }
          findMany: {
            args: Prisma.MilkLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilkLogPayload>[]
          }
          create: {
            args: Prisma.MilkLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilkLogPayload>
          }
          createMany: {
            args: Prisma.MilkLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MilkLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilkLogPayload>[]
          }
          delete: {
            args: Prisma.MilkLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilkLogPayload>
          }
          update: {
            args: Prisma.MilkLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilkLogPayload>
          }
          deleteMany: {
            args: Prisma.MilkLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MilkLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MilkLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilkLogPayload>[]
          }
          upsert: {
            args: Prisma.MilkLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilkLogPayload>
          }
          aggregate: {
            args: Prisma.MilkLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMilkLog>
          }
          groupBy: {
            args: Prisma.MilkLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<MilkLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.MilkLogCountArgs<ExtArgs>
            result: $Utils.Optional<MilkLogCountAggregateOutputType> | number
          }
        }
      }
      EggLog: {
        payload: Prisma.$EggLogPayload<ExtArgs>
        fields: Prisma.EggLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EggLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EggLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggLogPayload>
          }
          findFirst: {
            args: Prisma.EggLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EggLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggLogPayload>
          }
          findMany: {
            args: Prisma.EggLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggLogPayload>[]
          }
          create: {
            args: Prisma.EggLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggLogPayload>
          }
          createMany: {
            args: Prisma.EggLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EggLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggLogPayload>[]
          }
          delete: {
            args: Prisma.EggLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggLogPayload>
          }
          update: {
            args: Prisma.EggLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggLogPayload>
          }
          deleteMany: {
            args: Prisma.EggLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EggLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EggLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggLogPayload>[]
          }
          upsert: {
            args: Prisma.EggLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggLogPayload>
          }
          aggregate: {
            args: Prisma.EggLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEggLog>
          }
          groupBy: {
            args: Prisma.EggLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<EggLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.EggLogCountArgs<ExtArgs>
            result: $Utils.Optional<EggLogCountAggregateOutputType> | number
          }
        }
      }
      HoneyLog: {
        payload: Prisma.$HoneyLogPayload<ExtArgs>
        fields: Prisma.HoneyLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HoneyLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoneyLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HoneyLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoneyLogPayload>
          }
          findFirst: {
            args: Prisma.HoneyLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoneyLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HoneyLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoneyLogPayload>
          }
          findMany: {
            args: Prisma.HoneyLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoneyLogPayload>[]
          }
          create: {
            args: Prisma.HoneyLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoneyLogPayload>
          }
          createMany: {
            args: Prisma.HoneyLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HoneyLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoneyLogPayload>[]
          }
          delete: {
            args: Prisma.HoneyLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoneyLogPayload>
          }
          update: {
            args: Prisma.HoneyLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoneyLogPayload>
          }
          deleteMany: {
            args: Prisma.HoneyLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HoneyLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HoneyLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoneyLogPayload>[]
          }
          upsert: {
            args: Prisma.HoneyLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoneyLogPayload>
          }
          aggregate: {
            args: Prisma.HoneyLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHoneyLog>
          }
          groupBy: {
            args: Prisma.HoneyLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<HoneyLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.HoneyLogCountArgs<ExtArgs>
            result: $Utils.Optional<HoneyLogCountAggregateOutputType> | number
          }
        }
      }
      WoolLog: {
        payload: Prisma.$WoolLogPayload<ExtArgs>
        fields: Prisma.WoolLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WoolLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WoolLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WoolLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WoolLogPayload>
          }
          findFirst: {
            args: Prisma.WoolLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WoolLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WoolLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WoolLogPayload>
          }
          findMany: {
            args: Prisma.WoolLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WoolLogPayload>[]
          }
          create: {
            args: Prisma.WoolLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WoolLogPayload>
          }
          createMany: {
            args: Prisma.WoolLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WoolLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WoolLogPayload>[]
          }
          delete: {
            args: Prisma.WoolLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WoolLogPayload>
          }
          update: {
            args: Prisma.WoolLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WoolLogPayload>
          }
          deleteMany: {
            args: Prisma.WoolLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WoolLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WoolLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WoolLogPayload>[]
          }
          upsert: {
            args: Prisma.WoolLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WoolLogPayload>
          }
          aggregate: {
            args: Prisma.WoolLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWoolLog>
          }
          groupBy: {
            args: Prisma.WoolLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<WoolLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.WoolLogCountArgs<ExtArgs>
            result: $Utils.Optional<WoolLogCountAggregateOutputType> | number
          }
        }
      }
      WeightLog: {
        payload: Prisma.$WeightLogPayload<ExtArgs>
        fields: Prisma.WeightLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeightLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeightLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightLogPayload>
          }
          findFirst: {
            args: Prisma.WeightLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeightLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightLogPayload>
          }
          findMany: {
            args: Prisma.WeightLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightLogPayload>[]
          }
          create: {
            args: Prisma.WeightLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightLogPayload>
          }
          createMany: {
            args: Prisma.WeightLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeightLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightLogPayload>[]
          }
          delete: {
            args: Prisma.WeightLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightLogPayload>
          }
          update: {
            args: Prisma.WeightLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightLogPayload>
          }
          deleteMany: {
            args: Prisma.WeightLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeightLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WeightLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightLogPayload>[]
          }
          upsert: {
            args: Prisma.WeightLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightLogPayload>
          }
          aggregate: {
            args: Prisma.WeightLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeightLog>
          }
          groupBy: {
            args: Prisma.WeightLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeightLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeightLogCountArgs<ExtArgs>
            result: $Utils.Optional<WeightLogCountAggregateOutputType> | number
          }
        }
      }
      LivestockMetric: {
        payload: Prisma.$LivestockMetricPayload<ExtArgs>
        fields: Prisma.LivestockMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LivestockMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivestockMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LivestockMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivestockMetricPayload>
          }
          findFirst: {
            args: Prisma.LivestockMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivestockMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LivestockMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivestockMetricPayload>
          }
          findMany: {
            args: Prisma.LivestockMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivestockMetricPayload>[]
          }
          create: {
            args: Prisma.LivestockMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivestockMetricPayload>
          }
          createMany: {
            args: Prisma.LivestockMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LivestockMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivestockMetricPayload>[]
          }
          delete: {
            args: Prisma.LivestockMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivestockMetricPayload>
          }
          update: {
            args: Prisma.LivestockMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivestockMetricPayload>
          }
          deleteMany: {
            args: Prisma.LivestockMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LivestockMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LivestockMetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivestockMetricPayload>[]
          }
          upsert: {
            args: Prisma.LivestockMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivestockMetricPayload>
          }
          aggregate: {
            args: Prisma.LivestockMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLivestockMetric>
          }
          groupBy: {
            args: Prisma.LivestockMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<LivestockMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.LivestockMetricCountArgs<ExtArgs>
            result: $Utils.Optional<LivestockMetricCountAggregateOutputType> | number
          }
        }
      }
      CropQualityLog: {
        payload: Prisma.$CropQualityLogPayload<ExtArgs>
        fields: Prisma.CropQualityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CropQualityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropQualityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CropQualityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropQualityLogPayload>
          }
          findFirst: {
            args: Prisma.CropQualityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropQualityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CropQualityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropQualityLogPayload>
          }
          findMany: {
            args: Prisma.CropQualityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropQualityLogPayload>[]
          }
          create: {
            args: Prisma.CropQualityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropQualityLogPayload>
          }
          createMany: {
            args: Prisma.CropQualityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CropQualityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropQualityLogPayload>[]
          }
          delete: {
            args: Prisma.CropQualityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropQualityLogPayload>
          }
          update: {
            args: Prisma.CropQualityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropQualityLogPayload>
          }
          deleteMany: {
            args: Prisma.CropQualityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CropQualityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CropQualityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropQualityLogPayload>[]
          }
          upsert: {
            args: Prisma.CropQualityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropQualityLogPayload>
          }
          aggregate: {
            args: Prisma.CropQualityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCropQualityLog>
          }
          groupBy: {
            args: Prisma.CropQualityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<CropQualityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.CropQualityLogCountArgs<ExtArgs>
            result: $Utils.Optional<CropQualityLogCountAggregateOutputType> | number
          }
        }
      }
      CropMetric: {
        payload: Prisma.$CropMetricPayload<ExtArgs>
        fields: Prisma.CropMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CropMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CropMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropMetricPayload>
          }
          findFirst: {
            args: Prisma.CropMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CropMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropMetricPayload>
          }
          findMany: {
            args: Prisma.CropMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropMetricPayload>[]
          }
          create: {
            args: Prisma.CropMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropMetricPayload>
          }
          createMany: {
            args: Prisma.CropMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CropMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropMetricPayload>[]
          }
          delete: {
            args: Prisma.CropMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropMetricPayload>
          }
          update: {
            args: Prisma.CropMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropMetricPayload>
          }
          deleteMany: {
            args: Prisma.CropMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CropMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CropMetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropMetricPayload>[]
          }
          upsert: {
            args: Prisma.CropMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropMetricPayload>
          }
          aggregate: {
            args: Prisma.CropMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCropMetric>
          }
          groupBy: {
            args: Prisma.CropMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<CropMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.CropMetricCountArgs<ExtArgs>
            result: $Utils.Optional<CropMetricCountAggregateOutputType> | number
          }
        }
      }
      SupportProgram: {
        payload: Prisma.$SupportProgramPayload<ExtArgs>
        fields: Prisma.SupportProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupportProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupportProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportProgramPayload>
          }
          findFirst: {
            args: Prisma.SupportProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupportProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportProgramPayload>
          }
          findMany: {
            args: Prisma.SupportProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportProgramPayload>[]
          }
          create: {
            args: Prisma.SupportProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportProgramPayload>
          }
          createMany: {
            args: Prisma.SupportProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupportProgramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportProgramPayload>[]
          }
          delete: {
            args: Prisma.SupportProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportProgramPayload>
          }
          update: {
            args: Prisma.SupportProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportProgramPayload>
          }
          deleteMany: {
            args: Prisma.SupportProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupportProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupportProgramUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportProgramPayload>[]
          }
          upsert: {
            args: Prisma.SupportProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportProgramPayload>
          }
          aggregate: {
            args: Prisma.SupportProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupportProgram>
          }
          groupBy: {
            args: Prisma.SupportProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupportProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupportProgramCountArgs<ExtArgs>
            result: $Utils.Optional<SupportProgramCountAggregateOutputType> | number
          }
        }
      }
      WeatherAlert: {
        payload: Prisma.$WeatherAlertPayload<ExtArgs>
        fields: Prisma.WeatherAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeatherAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeatherAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherAlertPayload>
          }
          findFirst: {
            args: Prisma.WeatherAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeatherAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherAlertPayload>
          }
          findMany: {
            args: Prisma.WeatherAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherAlertPayload>[]
          }
          create: {
            args: Prisma.WeatherAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherAlertPayload>
          }
          createMany: {
            args: Prisma.WeatherAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeatherAlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherAlertPayload>[]
          }
          delete: {
            args: Prisma.WeatherAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherAlertPayload>
          }
          update: {
            args: Prisma.WeatherAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherAlertPayload>
          }
          deleteMany: {
            args: Prisma.WeatherAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeatherAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WeatherAlertUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherAlertPayload>[]
          }
          upsert: {
            args: Prisma.WeatherAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherAlertPayload>
          }
          aggregate: {
            args: Prisma.WeatherAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeatherAlert>
          }
          groupBy: {
            args: Prisma.WeatherAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeatherAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeatherAlertCountArgs<ExtArgs>
            result: $Utils.Optional<WeatherAlertCountAggregateOutputType> | number
          }
        }
      }
      MarketListing: {
        payload: Prisma.$MarketListingPayload<ExtArgs>
        fields: Prisma.MarketListingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketListingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketListingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketListingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketListingPayload>
          }
          findFirst: {
            args: Prisma.MarketListingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketListingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketListingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketListingPayload>
          }
          findMany: {
            args: Prisma.MarketListingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketListingPayload>[]
          }
          create: {
            args: Prisma.MarketListingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketListingPayload>
          }
          createMany: {
            args: Prisma.MarketListingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketListingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketListingPayload>[]
          }
          delete: {
            args: Prisma.MarketListingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketListingPayload>
          }
          update: {
            args: Prisma.MarketListingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketListingPayload>
          }
          deleteMany: {
            args: Prisma.MarketListingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketListingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MarketListingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketListingPayload>[]
          }
          upsert: {
            args: Prisma.MarketListingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketListingPayload>
          }
          aggregate: {
            args: Prisma.MarketListingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketListing>
          }
          groupBy: {
            args: Prisma.MarketListingGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketListingGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketListingCountArgs<ExtArgs>
            result: $Utils.Optional<MarketListingCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    crop?: CropOmit
    livestock?: LivestockOmit
    cropSpray?: CropSprayOmit
    cropHarvest?: CropHarvestOmit
    milkLog?: MilkLogOmit
    eggLog?: EggLogOmit
    honeyLog?: HoneyLogOmit
    woolLog?: WoolLogOmit
    weightLog?: WeightLogOmit
    livestockMetric?: LivestockMetricOmit
    cropQualityLog?: CropQualityLogOmit
    cropMetric?: CropMetricOmit
    supportProgram?: SupportProgramOmit
    weatherAlert?: WeatherAlertOmit
    marketListing?: MarketListingOmit
    notification?: NotificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    crops: number
    livestock: number
    listings: number
    notifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crops?: boolean | UserCountOutputTypeCountCropsArgs
    livestock?: boolean | UserCountOutputTypeCountLivestockArgs
    listings?: boolean | UserCountOutputTypeCountListingsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCropsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CropWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLivestockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LivestockWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketListingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type CropCountOutputType
   */

  export type CropCountOutputType = {
    sprays: number
    harvests: number
    qualityLogs: number
    metrics: number
  }

  export type CropCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sprays?: boolean | CropCountOutputTypeCountSpraysArgs
    harvests?: boolean | CropCountOutputTypeCountHarvestsArgs
    qualityLogs?: boolean | CropCountOutputTypeCountQualityLogsArgs
    metrics?: boolean | CropCountOutputTypeCountMetricsArgs
  }

  // Custom InputTypes
  /**
   * CropCountOutputType without action
   */
  export type CropCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropCountOutputType
     */
    select?: CropCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CropCountOutputType without action
   */
  export type CropCountOutputTypeCountSpraysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CropSprayWhereInput
  }

  /**
   * CropCountOutputType without action
   */
  export type CropCountOutputTypeCountHarvestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CropHarvestWhereInput
  }

  /**
   * CropCountOutputType without action
   */
  export type CropCountOutputTypeCountQualityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CropQualityLogWhereInput
  }

  /**
   * CropCountOutputType without action
   */
  export type CropCountOutputTypeCountMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CropMetricWhereInput
  }


  /**
   * Count Type LivestockCountOutputType
   */

  export type LivestockCountOutputType = {
    milkLogs: number
    eggLogs: number
    honeyLogs: number
    woolLogs: number
    weightLogs: number
    metrics: number
  }

  export type LivestockCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    milkLogs?: boolean | LivestockCountOutputTypeCountMilkLogsArgs
    eggLogs?: boolean | LivestockCountOutputTypeCountEggLogsArgs
    honeyLogs?: boolean | LivestockCountOutputTypeCountHoneyLogsArgs
    woolLogs?: boolean | LivestockCountOutputTypeCountWoolLogsArgs
    weightLogs?: boolean | LivestockCountOutputTypeCountWeightLogsArgs
    metrics?: boolean | LivestockCountOutputTypeCountMetricsArgs
  }

  // Custom InputTypes
  /**
   * LivestockCountOutputType without action
   */
  export type LivestockCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivestockCountOutputType
     */
    select?: LivestockCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LivestockCountOutputType without action
   */
  export type LivestockCountOutputTypeCountMilkLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilkLogWhereInput
  }

  /**
   * LivestockCountOutputType without action
   */
  export type LivestockCountOutputTypeCountEggLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EggLogWhereInput
  }

  /**
   * LivestockCountOutputType without action
   */
  export type LivestockCountOutputTypeCountHoneyLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HoneyLogWhereInput
  }

  /**
   * LivestockCountOutputType without action
   */
  export type LivestockCountOutputTypeCountWoolLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WoolLogWhereInput
  }

  /**
   * LivestockCountOutputType without action
   */
  export type LivestockCountOutputTypeCountWeightLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeightLogWhereInput
  }

  /**
   * LivestockCountOutputType without action
   */
  export type LivestockCountOutputTypeCountMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LivestockMetricWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    fullName: string | null
    role: $Enums.Role | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    fullName: string | null
    role: $Enums.Role | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    fullName: number
    role: number
    createdAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    fullName?: true
    role?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    fullName?: true
    role?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    fullName?: true
    role?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    fullName: string | null
    role: $Enums.Role
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    fullName?: boolean
    role?: boolean
    createdAt?: boolean
    crops?: boolean | User$cropsArgs<ExtArgs>
    livestock?: boolean | User$livestockArgs<ExtArgs>
    listings?: boolean | User$listingsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    fullName?: boolean
    role?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    fullName?: boolean
    role?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    fullName?: boolean
    role?: boolean
    createdAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "fullName" | "role" | "createdAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crops?: boolean | User$cropsArgs<ExtArgs>
    livestock?: boolean | User$livestockArgs<ExtArgs>
    listings?: boolean | User$listingsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      crops: Prisma.$CropPayload<ExtArgs>[]
      livestock: Prisma.$LivestockPayload<ExtArgs>[]
      listings: Prisma.$MarketListingPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      fullName: string | null
      role: $Enums.Role
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    crops<T extends User$cropsArgs<ExtArgs> = {}>(args?: Subset<T, User$cropsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    livestock<T extends User$livestockArgs<ExtArgs> = {}>(args?: Subset<T, User$livestockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivestockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    listings<T extends User$listingsArgs<ExtArgs> = {}>(args?: Subset<T, User$listingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.crops
   */
  export type User$cropsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    where?: CropWhereInput
    orderBy?: CropOrderByWithRelationInput | CropOrderByWithRelationInput[]
    cursor?: CropWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CropScalarFieldEnum | CropScalarFieldEnum[]
  }

  /**
   * User.livestock
   */
  export type User$livestockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livestock
     */
    select?: LivestockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livestock
     */
    omit?: LivestockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockInclude<ExtArgs> | null
    where?: LivestockWhereInput
    orderBy?: LivestockOrderByWithRelationInput | LivestockOrderByWithRelationInput[]
    cursor?: LivestockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LivestockScalarFieldEnum | LivestockScalarFieldEnum[]
  }

  /**
   * User.listings
   */
  export type User$listingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingInclude<ExtArgs> | null
    where?: MarketListingWhereInput
    orderBy?: MarketListingOrderByWithRelationInput | MarketListingOrderByWithRelationInput[]
    cursor?: MarketListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketListingScalarFieldEnum | MarketListingScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Crop
   */

  export type AggregateCrop = {
    _count: CropCountAggregateOutputType | null
    _avg: CropAvgAggregateOutputType | null
    _sum: CropSumAggregateOutputType | null
    _min: CropMinAggregateOutputType | null
    _max: CropMaxAggregateOutputType | null
  }

  export type CropAvgAggregateOutputType = {
    areaHectares: number | null
    proteinPercent: number | null
    moisturePercent: number | null
    sugarPercent: number | null
    oilPercent: number | null
    qualityScore: number | null
  }

  export type CropSumAggregateOutputType = {
    areaHectares: number | null
    proteinPercent: number | null
    moisturePercent: number | null
    sugarPercent: number | null
    oilPercent: number | null
    qualityScore: number | null
  }

  export type CropMinAggregateOutputType = {
    id: string | null
    userId: string | null
    cropType: string | null
    specificType: string | null
    plantingDate: Date | null
    harvestDate: Date | null
    notes: string | null
    areaHectares: number | null
    pesticide: string | null
    createdAt: Date | null
    nextSprayDueAt: Date | null
    lastSprayAlertAt: Date | null
    proteinPercent: number | null
    moisturePercent: number | null
    sugarPercent: number | null
    oilPercent: number | null
    healthStatus: string | null
    diseaseNotes: string | null
    qualityScore: number | null
  }

  export type CropMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    cropType: string | null
    specificType: string | null
    plantingDate: Date | null
    harvestDate: Date | null
    notes: string | null
    areaHectares: number | null
    pesticide: string | null
    createdAt: Date | null
    nextSprayDueAt: Date | null
    lastSprayAlertAt: Date | null
    proteinPercent: number | null
    moisturePercent: number | null
    sugarPercent: number | null
    oilPercent: number | null
    healthStatus: string | null
    diseaseNotes: string | null
    qualityScore: number | null
  }

  export type CropCountAggregateOutputType = {
    id: number
    userId: number
    cropType: number
    specificType: number
    plantingDate: number
    harvestDate: number
    notes: number
    areaHectares: number
    pesticide: number
    createdAt: number
    nextSprayDueAt: number
    lastSprayAlertAt: number
    proteinPercent: number
    moisturePercent: number
    sugarPercent: number
    oilPercent: number
    healthStatus: number
    diseaseNotes: number
    qualityScore: number
    customMetrics: number
    _all: number
  }


  export type CropAvgAggregateInputType = {
    areaHectares?: true
    proteinPercent?: true
    moisturePercent?: true
    sugarPercent?: true
    oilPercent?: true
    qualityScore?: true
  }

  export type CropSumAggregateInputType = {
    areaHectares?: true
    proteinPercent?: true
    moisturePercent?: true
    sugarPercent?: true
    oilPercent?: true
    qualityScore?: true
  }

  export type CropMinAggregateInputType = {
    id?: true
    userId?: true
    cropType?: true
    specificType?: true
    plantingDate?: true
    harvestDate?: true
    notes?: true
    areaHectares?: true
    pesticide?: true
    createdAt?: true
    nextSprayDueAt?: true
    lastSprayAlertAt?: true
    proteinPercent?: true
    moisturePercent?: true
    sugarPercent?: true
    oilPercent?: true
    healthStatus?: true
    diseaseNotes?: true
    qualityScore?: true
  }

  export type CropMaxAggregateInputType = {
    id?: true
    userId?: true
    cropType?: true
    specificType?: true
    plantingDate?: true
    harvestDate?: true
    notes?: true
    areaHectares?: true
    pesticide?: true
    createdAt?: true
    nextSprayDueAt?: true
    lastSprayAlertAt?: true
    proteinPercent?: true
    moisturePercent?: true
    sugarPercent?: true
    oilPercent?: true
    healthStatus?: true
    diseaseNotes?: true
    qualityScore?: true
  }

  export type CropCountAggregateInputType = {
    id?: true
    userId?: true
    cropType?: true
    specificType?: true
    plantingDate?: true
    harvestDate?: true
    notes?: true
    areaHectares?: true
    pesticide?: true
    createdAt?: true
    nextSprayDueAt?: true
    lastSprayAlertAt?: true
    proteinPercent?: true
    moisturePercent?: true
    sugarPercent?: true
    oilPercent?: true
    healthStatus?: true
    diseaseNotes?: true
    qualityScore?: true
    customMetrics?: true
    _all?: true
  }

  export type CropAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Crop to aggregate.
     */
    where?: CropWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crops to fetch.
     */
    orderBy?: CropOrderByWithRelationInput | CropOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CropWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Crops
    **/
    _count?: true | CropCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CropAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CropSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CropMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CropMaxAggregateInputType
  }

  export type GetCropAggregateType<T extends CropAggregateArgs> = {
        [P in keyof T & keyof AggregateCrop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrop[P]>
      : GetScalarType<T[P], AggregateCrop[P]>
  }




  export type CropGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CropWhereInput
    orderBy?: CropOrderByWithAggregationInput | CropOrderByWithAggregationInput[]
    by: CropScalarFieldEnum[] | CropScalarFieldEnum
    having?: CropScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CropCountAggregateInputType | true
    _avg?: CropAvgAggregateInputType
    _sum?: CropSumAggregateInputType
    _min?: CropMinAggregateInputType
    _max?: CropMaxAggregateInputType
  }

  export type CropGroupByOutputType = {
    id: string
    userId: string
    cropType: string
    specificType: string | null
    plantingDate: Date
    harvestDate: Date | null
    notes: string | null
    areaHectares: number | null
    pesticide: string | null
    createdAt: Date
    nextSprayDueAt: Date | null
    lastSprayAlertAt: Date | null
    proteinPercent: number | null
    moisturePercent: number | null
    sugarPercent: number | null
    oilPercent: number | null
    healthStatus: string | null
    diseaseNotes: string | null
    qualityScore: number | null
    customMetrics: JsonValue | null
    _count: CropCountAggregateOutputType | null
    _avg: CropAvgAggregateOutputType | null
    _sum: CropSumAggregateOutputType | null
    _min: CropMinAggregateOutputType | null
    _max: CropMaxAggregateOutputType | null
  }

  type GetCropGroupByPayload<T extends CropGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CropGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CropGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CropGroupByOutputType[P]>
            : GetScalarType<T[P], CropGroupByOutputType[P]>
        }
      >
    >


  export type CropSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cropType?: boolean
    specificType?: boolean
    plantingDate?: boolean
    harvestDate?: boolean
    notes?: boolean
    areaHectares?: boolean
    pesticide?: boolean
    createdAt?: boolean
    nextSprayDueAt?: boolean
    lastSprayAlertAt?: boolean
    proteinPercent?: boolean
    moisturePercent?: boolean
    sugarPercent?: boolean
    oilPercent?: boolean
    healthStatus?: boolean
    diseaseNotes?: boolean
    qualityScore?: boolean
    customMetrics?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    sprays?: boolean | Crop$spraysArgs<ExtArgs>
    harvests?: boolean | Crop$harvestsArgs<ExtArgs>
    qualityLogs?: boolean | Crop$qualityLogsArgs<ExtArgs>
    metrics?: boolean | Crop$metricsArgs<ExtArgs>
    _count?: boolean | CropCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crop"]>

  export type CropSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cropType?: boolean
    specificType?: boolean
    plantingDate?: boolean
    harvestDate?: boolean
    notes?: boolean
    areaHectares?: boolean
    pesticide?: boolean
    createdAt?: boolean
    nextSprayDueAt?: boolean
    lastSprayAlertAt?: boolean
    proteinPercent?: boolean
    moisturePercent?: boolean
    sugarPercent?: boolean
    oilPercent?: boolean
    healthStatus?: boolean
    diseaseNotes?: boolean
    qualityScore?: boolean
    customMetrics?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crop"]>

  export type CropSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cropType?: boolean
    specificType?: boolean
    plantingDate?: boolean
    harvestDate?: boolean
    notes?: boolean
    areaHectares?: boolean
    pesticide?: boolean
    createdAt?: boolean
    nextSprayDueAt?: boolean
    lastSprayAlertAt?: boolean
    proteinPercent?: boolean
    moisturePercent?: boolean
    sugarPercent?: boolean
    oilPercent?: boolean
    healthStatus?: boolean
    diseaseNotes?: boolean
    qualityScore?: boolean
    customMetrics?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crop"]>

  export type CropSelectScalar = {
    id?: boolean
    userId?: boolean
    cropType?: boolean
    specificType?: boolean
    plantingDate?: boolean
    harvestDate?: boolean
    notes?: boolean
    areaHectares?: boolean
    pesticide?: boolean
    createdAt?: boolean
    nextSprayDueAt?: boolean
    lastSprayAlertAt?: boolean
    proteinPercent?: boolean
    moisturePercent?: boolean
    sugarPercent?: boolean
    oilPercent?: boolean
    healthStatus?: boolean
    diseaseNotes?: boolean
    qualityScore?: boolean
    customMetrics?: boolean
  }

  export type CropOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "cropType" | "specificType" | "plantingDate" | "harvestDate" | "notes" | "areaHectares" | "pesticide" | "createdAt" | "nextSprayDueAt" | "lastSprayAlertAt" | "proteinPercent" | "moisturePercent" | "sugarPercent" | "oilPercent" | "healthStatus" | "diseaseNotes" | "qualityScore" | "customMetrics", ExtArgs["result"]["crop"]>
  export type CropInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    sprays?: boolean | Crop$spraysArgs<ExtArgs>
    harvests?: boolean | Crop$harvestsArgs<ExtArgs>
    qualityLogs?: boolean | Crop$qualityLogsArgs<ExtArgs>
    metrics?: boolean | Crop$metricsArgs<ExtArgs>
    _count?: boolean | CropCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CropIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CropIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CropPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Crop"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      sprays: Prisma.$CropSprayPayload<ExtArgs>[]
      harvests: Prisma.$CropHarvestPayload<ExtArgs>[]
      qualityLogs: Prisma.$CropQualityLogPayload<ExtArgs>[]
      metrics: Prisma.$CropMetricPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      cropType: string
      specificType: string | null
      plantingDate: Date
      harvestDate: Date | null
      notes: string | null
      areaHectares: number | null
      pesticide: string | null
      createdAt: Date
      nextSprayDueAt: Date | null
      lastSprayAlertAt: Date | null
      proteinPercent: number | null
      moisturePercent: number | null
      sugarPercent: number | null
      oilPercent: number | null
      healthStatus: string | null
      diseaseNotes: string | null
      qualityScore: number | null
      customMetrics: Prisma.JsonValue | null
    }, ExtArgs["result"]["crop"]>
    composites: {}
  }

  type CropGetPayload<S extends boolean | null | undefined | CropDefaultArgs> = $Result.GetResult<Prisma.$CropPayload, S>

  type CropCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CropFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CropCountAggregateInputType | true
    }

  export interface CropDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Crop'], meta: { name: 'Crop' } }
    /**
     * Find zero or one Crop that matches the filter.
     * @param {CropFindUniqueArgs} args - Arguments to find a Crop
     * @example
     * // Get one Crop
     * const crop = await prisma.crop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CropFindUniqueArgs>(args: SelectSubset<T, CropFindUniqueArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Crop that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CropFindUniqueOrThrowArgs} args - Arguments to find a Crop
     * @example
     * // Get one Crop
     * const crop = await prisma.crop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CropFindUniqueOrThrowArgs>(args: SelectSubset<T, CropFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Crop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropFindFirstArgs} args - Arguments to find a Crop
     * @example
     * // Get one Crop
     * const crop = await prisma.crop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CropFindFirstArgs>(args?: SelectSubset<T, CropFindFirstArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Crop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropFindFirstOrThrowArgs} args - Arguments to find a Crop
     * @example
     * // Get one Crop
     * const crop = await prisma.crop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CropFindFirstOrThrowArgs>(args?: SelectSubset<T, CropFindFirstOrThrowArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Crops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Crops
     * const crops = await prisma.crop.findMany()
     * 
     * // Get first 10 Crops
     * const crops = await prisma.crop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cropWithIdOnly = await prisma.crop.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CropFindManyArgs>(args?: SelectSubset<T, CropFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Crop.
     * @param {CropCreateArgs} args - Arguments to create a Crop.
     * @example
     * // Create one Crop
     * const Crop = await prisma.crop.create({
     *   data: {
     *     // ... data to create a Crop
     *   }
     * })
     * 
     */
    create<T extends CropCreateArgs>(args: SelectSubset<T, CropCreateArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Crops.
     * @param {CropCreateManyArgs} args - Arguments to create many Crops.
     * @example
     * // Create many Crops
     * const crop = await prisma.crop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CropCreateManyArgs>(args?: SelectSubset<T, CropCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Crops and returns the data saved in the database.
     * @param {CropCreateManyAndReturnArgs} args - Arguments to create many Crops.
     * @example
     * // Create many Crops
     * const crop = await prisma.crop.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Crops and only return the `id`
     * const cropWithIdOnly = await prisma.crop.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CropCreateManyAndReturnArgs>(args?: SelectSubset<T, CropCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Crop.
     * @param {CropDeleteArgs} args - Arguments to delete one Crop.
     * @example
     * // Delete one Crop
     * const Crop = await prisma.crop.delete({
     *   where: {
     *     // ... filter to delete one Crop
     *   }
     * })
     * 
     */
    delete<T extends CropDeleteArgs>(args: SelectSubset<T, CropDeleteArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Crop.
     * @param {CropUpdateArgs} args - Arguments to update one Crop.
     * @example
     * // Update one Crop
     * const crop = await prisma.crop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CropUpdateArgs>(args: SelectSubset<T, CropUpdateArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Crops.
     * @param {CropDeleteManyArgs} args - Arguments to filter Crops to delete.
     * @example
     * // Delete a few Crops
     * const { count } = await prisma.crop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CropDeleteManyArgs>(args?: SelectSubset<T, CropDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Crops
     * const crop = await prisma.crop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CropUpdateManyArgs>(args: SelectSubset<T, CropUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crops and returns the data updated in the database.
     * @param {CropUpdateManyAndReturnArgs} args - Arguments to update many Crops.
     * @example
     * // Update many Crops
     * const crop = await prisma.crop.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Crops and only return the `id`
     * const cropWithIdOnly = await prisma.crop.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CropUpdateManyAndReturnArgs>(args: SelectSubset<T, CropUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Crop.
     * @param {CropUpsertArgs} args - Arguments to update or create a Crop.
     * @example
     * // Update or create a Crop
     * const crop = await prisma.crop.upsert({
     *   create: {
     *     // ... data to create a Crop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Crop we want to update
     *   }
     * })
     */
    upsert<T extends CropUpsertArgs>(args: SelectSubset<T, CropUpsertArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Crops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropCountArgs} args - Arguments to filter Crops to count.
     * @example
     * // Count the number of Crops
     * const count = await prisma.crop.count({
     *   where: {
     *     // ... the filter for the Crops we want to count
     *   }
     * })
    **/
    count<T extends CropCountArgs>(
      args?: Subset<T, CropCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CropCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Crop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CropAggregateArgs>(args: Subset<T, CropAggregateArgs>): Prisma.PrismaPromise<GetCropAggregateType<T>>

    /**
     * Group by Crop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CropGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CropGroupByArgs['orderBy'] }
        : { orderBy?: CropGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CropGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCropGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Crop model
   */
  readonly fields: CropFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Crop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CropClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sprays<T extends Crop$spraysArgs<ExtArgs> = {}>(args?: Subset<T, Crop$spraysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropSprayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    harvests<T extends Crop$harvestsArgs<ExtArgs> = {}>(args?: Subset<T, Crop$harvestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropHarvestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    qualityLogs<T extends Crop$qualityLogsArgs<ExtArgs> = {}>(args?: Subset<T, Crop$qualityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropQualityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    metrics<T extends Crop$metricsArgs<ExtArgs> = {}>(args?: Subset<T, Crop$metricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Crop model
   */
  interface CropFieldRefs {
    readonly id: FieldRef<"Crop", 'String'>
    readonly userId: FieldRef<"Crop", 'String'>
    readonly cropType: FieldRef<"Crop", 'String'>
    readonly specificType: FieldRef<"Crop", 'String'>
    readonly plantingDate: FieldRef<"Crop", 'DateTime'>
    readonly harvestDate: FieldRef<"Crop", 'DateTime'>
    readonly notes: FieldRef<"Crop", 'String'>
    readonly areaHectares: FieldRef<"Crop", 'Float'>
    readonly pesticide: FieldRef<"Crop", 'String'>
    readonly createdAt: FieldRef<"Crop", 'DateTime'>
    readonly nextSprayDueAt: FieldRef<"Crop", 'DateTime'>
    readonly lastSprayAlertAt: FieldRef<"Crop", 'DateTime'>
    readonly proteinPercent: FieldRef<"Crop", 'Float'>
    readonly moisturePercent: FieldRef<"Crop", 'Float'>
    readonly sugarPercent: FieldRef<"Crop", 'Float'>
    readonly oilPercent: FieldRef<"Crop", 'Float'>
    readonly healthStatus: FieldRef<"Crop", 'String'>
    readonly diseaseNotes: FieldRef<"Crop", 'String'>
    readonly qualityScore: FieldRef<"Crop", 'Int'>
    readonly customMetrics: FieldRef<"Crop", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Crop findUnique
   */
  export type CropFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * Filter, which Crop to fetch.
     */
    where: CropWhereUniqueInput
  }

  /**
   * Crop findUniqueOrThrow
   */
  export type CropFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * Filter, which Crop to fetch.
     */
    where: CropWhereUniqueInput
  }

  /**
   * Crop findFirst
   */
  export type CropFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * Filter, which Crop to fetch.
     */
    where?: CropWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crops to fetch.
     */
    orderBy?: CropOrderByWithRelationInput | CropOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Crops.
     */
    cursor?: CropWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Crops.
     */
    distinct?: CropScalarFieldEnum | CropScalarFieldEnum[]
  }

  /**
   * Crop findFirstOrThrow
   */
  export type CropFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * Filter, which Crop to fetch.
     */
    where?: CropWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crops to fetch.
     */
    orderBy?: CropOrderByWithRelationInput | CropOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Crops.
     */
    cursor?: CropWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Crops.
     */
    distinct?: CropScalarFieldEnum | CropScalarFieldEnum[]
  }

  /**
   * Crop findMany
   */
  export type CropFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * Filter, which Crops to fetch.
     */
    where?: CropWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crops to fetch.
     */
    orderBy?: CropOrderByWithRelationInput | CropOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Crops.
     */
    cursor?: CropWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crops.
     */
    skip?: number
    distinct?: CropScalarFieldEnum | CropScalarFieldEnum[]
  }

  /**
   * Crop create
   */
  export type CropCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * The data needed to create a Crop.
     */
    data: XOR<CropCreateInput, CropUncheckedCreateInput>
  }

  /**
   * Crop createMany
   */
  export type CropCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Crops.
     */
    data: CropCreateManyInput | CropCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Crop createManyAndReturn
   */
  export type CropCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * The data used to create many Crops.
     */
    data: CropCreateManyInput | CropCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Crop update
   */
  export type CropUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * The data needed to update a Crop.
     */
    data: XOR<CropUpdateInput, CropUncheckedUpdateInput>
    /**
     * Choose, which Crop to update.
     */
    where: CropWhereUniqueInput
  }

  /**
   * Crop updateMany
   */
  export type CropUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Crops.
     */
    data: XOR<CropUpdateManyMutationInput, CropUncheckedUpdateManyInput>
    /**
     * Filter which Crops to update
     */
    where?: CropWhereInput
    /**
     * Limit how many Crops to update.
     */
    limit?: number
  }

  /**
   * Crop updateManyAndReturn
   */
  export type CropUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * The data used to update Crops.
     */
    data: XOR<CropUpdateManyMutationInput, CropUncheckedUpdateManyInput>
    /**
     * Filter which Crops to update
     */
    where?: CropWhereInput
    /**
     * Limit how many Crops to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Crop upsert
   */
  export type CropUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * The filter to search for the Crop to update in case it exists.
     */
    where: CropWhereUniqueInput
    /**
     * In case the Crop found by the `where` argument doesn't exist, create a new Crop with this data.
     */
    create: XOR<CropCreateInput, CropUncheckedCreateInput>
    /**
     * In case the Crop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CropUpdateInput, CropUncheckedUpdateInput>
  }

  /**
   * Crop delete
   */
  export type CropDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * Filter which Crop to delete.
     */
    where: CropWhereUniqueInput
  }

  /**
   * Crop deleteMany
   */
  export type CropDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Crops to delete
     */
    where?: CropWhereInput
    /**
     * Limit how many Crops to delete.
     */
    limit?: number
  }

  /**
   * Crop.sprays
   */
  export type Crop$spraysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropSpray
     */
    select?: CropSpraySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropSpray
     */
    omit?: CropSprayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropSprayInclude<ExtArgs> | null
    where?: CropSprayWhereInput
    orderBy?: CropSprayOrderByWithRelationInput | CropSprayOrderByWithRelationInput[]
    cursor?: CropSprayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CropSprayScalarFieldEnum | CropSprayScalarFieldEnum[]
  }

  /**
   * Crop.harvests
   */
  export type Crop$harvestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropHarvest
     */
    select?: CropHarvestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropHarvest
     */
    omit?: CropHarvestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropHarvestInclude<ExtArgs> | null
    where?: CropHarvestWhereInput
    orderBy?: CropHarvestOrderByWithRelationInput | CropHarvestOrderByWithRelationInput[]
    cursor?: CropHarvestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CropHarvestScalarFieldEnum | CropHarvestScalarFieldEnum[]
  }

  /**
   * Crop.qualityLogs
   */
  export type Crop$qualityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropQualityLog
     */
    select?: CropQualityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropQualityLog
     */
    omit?: CropQualityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropQualityLogInclude<ExtArgs> | null
    where?: CropQualityLogWhereInput
    orderBy?: CropQualityLogOrderByWithRelationInput | CropQualityLogOrderByWithRelationInput[]
    cursor?: CropQualityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CropQualityLogScalarFieldEnum | CropQualityLogScalarFieldEnum[]
  }

  /**
   * Crop.metrics
   */
  export type Crop$metricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropMetric
     */
    select?: CropMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropMetric
     */
    omit?: CropMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropMetricInclude<ExtArgs> | null
    where?: CropMetricWhereInput
    orderBy?: CropMetricOrderByWithRelationInput | CropMetricOrderByWithRelationInput[]
    cursor?: CropMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CropMetricScalarFieldEnum | CropMetricScalarFieldEnum[]
  }

  /**
   * Crop without action
   */
  export type CropDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
  }


  /**
   * Model Livestock
   */

  export type AggregateLivestock = {
    _count: LivestockCountAggregateOutputType | null
    _avg: LivestockAvgAggregateOutputType | null
    _sum: LivestockSumAggregateOutputType | null
    _min: LivestockMinAggregateOutputType | null
    _max: LivestockMaxAggregateOutputType | null
  }

  export type LivestockAvgAggregateOutputType = {
    weightKg: number | null
    dailyFeedKg: number | null
  }

  export type LivestockSumAggregateOutputType = {
    weightKg: number | null
    dailyFeedKg: number | null
  }

  export type LivestockMinAggregateOutputType = {
    id: string | null
    userId: string | null
    animalType: string | null
    specificType: string | null
    breed: string | null
    birthDate: Date | null
    notes: string | null
    createdAt: Date | null
    lastMilkAlertAt: Date | null
    weightKg: number | null
    healthStatus: string | null
    dailyFeedKg: number | null
    vaccineStatus: string | null
    lastCheckupDate: Date | null
  }

  export type LivestockMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    animalType: string | null
    specificType: string | null
    breed: string | null
    birthDate: Date | null
    notes: string | null
    createdAt: Date | null
    lastMilkAlertAt: Date | null
    weightKg: number | null
    healthStatus: string | null
    dailyFeedKg: number | null
    vaccineStatus: string | null
    lastCheckupDate: Date | null
  }

  export type LivestockCountAggregateOutputType = {
    id: number
    userId: number
    animalType: number
    specificType: number
    breed: number
    birthDate: number
    notes: number
    createdAt: number
    lastMilkAlertAt: number
    weightKg: number
    healthStatus: number
    dailyFeedKg: number
    vaccineStatus: number
    lastCheckupDate: number
    customMetrics: number
    _all: number
  }


  export type LivestockAvgAggregateInputType = {
    weightKg?: true
    dailyFeedKg?: true
  }

  export type LivestockSumAggregateInputType = {
    weightKg?: true
    dailyFeedKg?: true
  }

  export type LivestockMinAggregateInputType = {
    id?: true
    userId?: true
    animalType?: true
    specificType?: true
    breed?: true
    birthDate?: true
    notes?: true
    createdAt?: true
    lastMilkAlertAt?: true
    weightKg?: true
    healthStatus?: true
    dailyFeedKg?: true
    vaccineStatus?: true
    lastCheckupDate?: true
  }

  export type LivestockMaxAggregateInputType = {
    id?: true
    userId?: true
    animalType?: true
    specificType?: true
    breed?: true
    birthDate?: true
    notes?: true
    createdAt?: true
    lastMilkAlertAt?: true
    weightKg?: true
    healthStatus?: true
    dailyFeedKg?: true
    vaccineStatus?: true
    lastCheckupDate?: true
  }

  export type LivestockCountAggregateInputType = {
    id?: true
    userId?: true
    animalType?: true
    specificType?: true
    breed?: true
    birthDate?: true
    notes?: true
    createdAt?: true
    lastMilkAlertAt?: true
    weightKg?: true
    healthStatus?: true
    dailyFeedKg?: true
    vaccineStatus?: true
    lastCheckupDate?: true
    customMetrics?: true
    _all?: true
  }

  export type LivestockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Livestock to aggregate.
     */
    where?: LivestockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Livestocks to fetch.
     */
    orderBy?: LivestockOrderByWithRelationInput | LivestockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LivestockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Livestocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Livestocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Livestocks
    **/
    _count?: true | LivestockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LivestockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LivestockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LivestockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LivestockMaxAggregateInputType
  }

  export type GetLivestockAggregateType<T extends LivestockAggregateArgs> = {
        [P in keyof T & keyof AggregateLivestock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLivestock[P]>
      : GetScalarType<T[P], AggregateLivestock[P]>
  }




  export type LivestockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LivestockWhereInput
    orderBy?: LivestockOrderByWithAggregationInput | LivestockOrderByWithAggregationInput[]
    by: LivestockScalarFieldEnum[] | LivestockScalarFieldEnum
    having?: LivestockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LivestockCountAggregateInputType | true
    _avg?: LivestockAvgAggregateInputType
    _sum?: LivestockSumAggregateInputType
    _min?: LivestockMinAggregateInputType
    _max?: LivestockMaxAggregateInputType
  }

  export type LivestockGroupByOutputType = {
    id: string
    userId: string
    animalType: string
    specificType: string | null
    breed: string | null
    birthDate: Date | null
    notes: string | null
    createdAt: Date
    lastMilkAlertAt: Date | null
    weightKg: number | null
    healthStatus: string | null
    dailyFeedKg: number | null
    vaccineStatus: string | null
    lastCheckupDate: Date | null
    customMetrics: JsonValue | null
    _count: LivestockCountAggregateOutputType | null
    _avg: LivestockAvgAggregateOutputType | null
    _sum: LivestockSumAggregateOutputType | null
    _min: LivestockMinAggregateOutputType | null
    _max: LivestockMaxAggregateOutputType | null
  }

  type GetLivestockGroupByPayload<T extends LivestockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LivestockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LivestockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LivestockGroupByOutputType[P]>
            : GetScalarType<T[P], LivestockGroupByOutputType[P]>
        }
      >
    >


  export type LivestockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    animalType?: boolean
    specificType?: boolean
    breed?: boolean
    birthDate?: boolean
    notes?: boolean
    createdAt?: boolean
    lastMilkAlertAt?: boolean
    weightKg?: boolean
    healthStatus?: boolean
    dailyFeedKg?: boolean
    vaccineStatus?: boolean
    lastCheckupDate?: boolean
    customMetrics?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    milkLogs?: boolean | Livestock$milkLogsArgs<ExtArgs>
    eggLogs?: boolean | Livestock$eggLogsArgs<ExtArgs>
    honeyLogs?: boolean | Livestock$honeyLogsArgs<ExtArgs>
    woolLogs?: boolean | Livestock$woolLogsArgs<ExtArgs>
    weightLogs?: boolean | Livestock$weightLogsArgs<ExtArgs>
    metrics?: boolean | Livestock$metricsArgs<ExtArgs>
    _count?: boolean | LivestockCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["livestock"]>

  export type LivestockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    animalType?: boolean
    specificType?: boolean
    breed?: boolean
    birthDate?: boolean
    notes?: boolean
    createdAt?: boolean
    lastMilkAlertAt?: boolean
    weightKg?: boolean
    healthStatus?: boolean
    dailyFeedKg?: boolean
    vaccineStatus?: boolean
    lastCheckupDate?: boolean
    customMetrics?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["livestock"]>

  export type LivestockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    animalType?: boolean
    specificType?: boolean
    breed?: boolean
    birthDate?: boolean
    notes?: boolean
    createdAt?: boolean
    lastMilkAlertAt?: boolean
    weightKg?: boolean
    healthStatus?: boolean
    dailyFeedKg?: boolean
    vaccineStatus?: boolean
    lastCheckupDate?: boolean
    customMetrics?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["livestock"]>

  export type LivestockSelectScalar = {
    id?: boolean
    userId?: boolean
    animalType?: boolean
    specificType?: boolean
    breed?: boolean
    birthDate?: boolean
    notes?: boolean
    createdAt?: boolean
    lastMilkAlertAt?: boolean
    weightKg?: boolean
    healthStatus?: boolean
    dailyFeedKg?: boolean
    vaccineStatus?: boolean
    lastCheckupDate?: boolean
    customMetrics?: boolean
  }

  export type LivestockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "animalType" | "specificType" | "breed" | "birthDate" | "notes" | "createdAt" | "lastMilkAlertAt" | "weightKg" | "healthStatus" | "dailyFeedKg" | "vaccineStatus" | "lastCheckupDate" | "customMetrics", ExtArgs["result"]["livestock"]>
  export type LivestockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    milkLogs?: boolean | Livestock$milkLogsArgs<ExtArgs>
    eggLogs?: boolean | Livestock$eggLogsArgs<ExtArgs>
    honeyLogs?: boolean | Livestock$honeyLogsArgs<ExtArgs>
    woolLogs?: boolean | Livestock$woolLogsArgs<ExtArgs>
    weightLogs?: boolean | Livestock$weightLogsArgs<ExtArgs>
    metrics?: boolean | Livestock$metricsArgs<ExtArgs>
    _count?: boolean | LivestockCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LivestockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LivestockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LivestockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Livestock"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      milkLogs: Prisma.$MilkLogPayload<ExtArgs>[]
      eggLogs: Prisma.$EggLogPayload<ExtArgs>[]
      honeyLogs: Prisma.$HoneyLogPayload<ExtArgs>[]
      woolLogs: Prisma.$WoolLogPayload<ExtArgs>[]
      weightLogs: Prisma.$WeightLogPayload<ExtArgs>[]
      metrics: Prisma.$LivestockMetricPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      animalType: string
      specificType: string | null
      breed: string | null
      birthDate: Date | null
      notes: string | null
      createdAt: Date
      lastMilkAlertAt: Date | null
      weightKg: number | null
      healthStatus: string | null
      dailyFeedKg: number | null
      vaccineStatus: string | null
      lastCheckupDate: Date | null
      customMetrics: Prisma.JsonValue | null
    }, ExtArgs["result"]["livestock"]>
    composites: {}
  }

  type LivestockGetPayload<S extends boolean | null | undefined | LivestockDefaultArgs> = $Result.GetResult<Prisma.$LivestockPayload, S>

  type LivestockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LivestockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LivestockCountAggregateInputType | true
    }

  export interface LivestockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Livestock'], meta: { name: 'Livestock' } }
    /**
     * Find zero or one Livestock that matches the filter.
     * @param {LivestockFindUniqueArgs} args - Arguments to find a Livestock
     * @example
     * // Get one Livestock
     * const livestock = await prisma.livestock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LivestockFindUniqueArgs>(args: SelectSubset<T, LivestockFindUniqueArgs<ExtArgs>>): Prisma__LivestockClient<$Result.GetResult<Prisma.$LivestockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Livestock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LivestockFindUniqueOrThrowArgs} args - Arguments to find a Livestock
     * @example
     * // Get one Livestock
     * const livestock = await prisma.livestock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LivestockFindUniqueOrThrowArgs>(args: SelectSubset<T, LivestockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LivestockClient<$Result.GetResult<Prisma.$LivestockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Livestock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivestockFindFirstArgs} args - Arguments to find a Livestock
     * @example
     * // Get one Livestock
     * const livestock = await prisma.livestock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LivestockFindFirstArgs>(args?: SelectSubset<T, LivestockFindFirstArgs<ExtArgs>>): Prisma__LivestockClient<$Result.GetResult<Prisma.$LivestockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Livestock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivestockFindFirstOrThrowArgs} args - Arguments to find a Livestock
     * @example
     * // Get one Livestock
     * const livestock = await prisma.livestock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LivestockFindFirstOrThrowArgs>(args?: SelectSubset<T, LivestockFindFirstOrThrowArgs<ExtArgs>>): Prisma__LivestockClient<$Result.GetResult<Prisma.$LivestockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Livestocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivestockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Livestocks
     * const livestocks = await prisma.livestock.findMany()
     * 
     * // Get first 10 Livestocks
     * const livestocks = await prisma.livestock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const livestockWithIdOnly = await prisma.livestock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LivestockFindManyArgs>(args?: SelectSubset<T, LivestockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivestockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Livestock.
     * @param {LivestockCreateArgs} args - Arguments to create a Livestock.
     * @example
     * // Create one Livestock
     * const Livestock = await prisma.livestock.create({
     *   data: {
     *     // ... data to create a Livestock
     *   }
     * })
     * 
     */
    create<T extends LivestockCreateArgs>(args: SelectSubset<T, LivestockCreateArgs<ExtArgs>>): Prisma__LivestockClient<$Result.GetResult<Prisma.$LivestockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Livestocks.
     * @param {LivestockCreateManyArgs} args - Arguments to create many Livestocks.
     * @example
     * // Create many Livestocks
     * const livestock = await prisma.livestock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LivestockCreateManyArgs>(args?: SelectSubset<T, LivestockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Livestocks and returns the data saved in the database.
     * @param {LivestockCreateManyAndReturnArgs} args - Arguments to create many Livestocks.
     * @example
     * // Create many Livestocks
     * const livestock = await prisma.livestock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Livestocks and only return the `id`
     * const livestockWithIdOnly = await prisma.livestock.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LivestockCreateManyAndReturnArgs>(args?: SelectSubset<T, LivestockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivestockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Livestock.
     * @param {LivestockDeleteArgs} args - Arguments to delete one Livestock.
     * @example
     * // Delete one Livestock
     * const Livestock = await prisma.livestock.delete({
     *   where: {
     *     // ... filter to delete one Livestock
     *   }
     * })
     * 
     */
    delete<T extends LivestockDeleteArgs>(args: SelectSubset<T, LivestockDeleteArgs<ExtArgs>>): Prisma__LivestockClient<$Result.GetResult<Prisma.$LivestockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Livestock.
     * @param {LivestockUpdateArgs} args - Arguments to update one Livestock.
     * @example
     * // Update one Livestock
     * const livestock = await prisma.livestock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LivestockUpdateArgs>(args: SelectSubset<T, LivestockUpdateArgs<ExtArgs>>): Prisma__LivestockClient<$Result.GetResult<Prisma.$LivestockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Livestocks.
     * @param {LivestockDeleteManyArgs} args - Arguments to filter Livestocks to delete.
     * @example
     * // Delete a few Livestocks
     * const { count } = await prisma.livestock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LivestockDeleteManyArgs>(args?: SelectSubset<T, LivestockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Livestocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivestockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Livestocks
     * const livestock = await prisma.livestock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LivestockUpdateManyArgs>(args: SelectSubset<T, LivestockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Livestocks and returns the data updated in the database.
     * @param {LivestockUpdateManyAndReturnArgs} args - Arguments to update many Livestocks.
     * @example
     * // Update many Livestocks
     * const livestock = await prisma.livestock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Livestocks and only return the `id`
     * const livestockWithIdOnly = await prisma.livestock.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LivestockUpdateManyAndReturnArgs>(args: SelectSubset<T, LivestockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivestockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Livestock.
     * @param {LivestockUpsertArgs} args - Arguments to update or create a Livestock.
     * @example
     * // Update or create a Livestock
     * const livestock = await prisma.livestock.upsert({
     *   create: {
     *     // ... data to create a Livestock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Livestock we want to update
     *   }
     * })
     */
    upsert<T extends LivestockUpsertArgs>(args: SelectSubset<T, LivestockUpsertArgs<ExtArgs>>): Prisma__LivestockClient<$Result.GetResult<Prisma.$LivestockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Livestocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivestockCountArgs} args - Arguments to filter Livestocks to count.
     * @example
     * // Count the number of Livestocks
     * const count = await prisma.livestock.count({
     *   where: {
     *     // ... the filter for the Livestocks we want to count
     *   }
     * })
    **/
    count<T extends LivestockCountArgs>(
      args?: Subset<T, LivestockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LivestockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Livestock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivestockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LivestockAggregateArgs>(args: Subset<T, LivestockAggregateArgs>): Prisma.PrismaPromise<GetLivestockAggregateType<T>>

    /**
     * Group by Livestock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivestockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LivestockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LivestockGroupByArgs['orderBy'] }
        : { orderBy?: LivestockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LivestockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLivestockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Livestock model
   */
  readonly fields: LivestockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Livestock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LivestockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    milkLogs<T extends Livestock$milkLogsArgs<ExtArgs> = {}>(args?: Subset<T, Livestock$milkLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilkLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    eggLogs<T extends Livestock$eggLogsArgs<ExtArgs> = {}>(args?: Subset<T, Livestock$eggLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EggLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    honeyLogs<T extends Livestock$honeyLogsArgs<ExtArgs> = {}>(args?: Subset<T, Livestock$honeyLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoneyLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    woolLogs<T extends Livestock$woolLogsArgs<ExtArgs> = {}>(args?: Subset<T, Livestock$woolLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WoolLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    weightLogs<T extends Livestock$weightLogsArgs<ExtArgs> = {}>(args?: Subset<T, Livestock$weightLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeightLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    metrics<T extends Livestock$metricsArgs<ExtArgs> = {}>(args?: Subset<T, Livestock$metricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivestockMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Livestock model
   */
  interface LivestockFieldRefs {
    readonly id: FieldRef<"Livestock", 'String'>
    readonly userId: FieldRef<"Livestock", 'String'>
    readonly animalType: FieldRef<"Livestock", 'String'>
    readonly specificType: FieldRef<"Livestock", 'String'>
    readonly breed: FieldRef<"Livestock", 'String'>
    readonly birthDate: FieldRef<"Livestock", 'DateTime'>
    readonly notes: FieldRef<"Livestock", 'String'>
    readonly createdAt: FieldRef<"Livestock", 'DateTime'>
    readonly lastMilkAlertAt: FieldRef<"Livestock", 'DateTime'>
    readonly weightKg: FieldRef<"Livestock", 'Float'>
    readonly healthStatus: FieldRef<"Livestock", 'String'>
    readonly dailyFeedKg: FieldRef<"Livestock", 'Float'>
    readonly vaccineStatus: FieldRef<"Livestock", 'String'>
    readonly lastCheckupDate: FieldRef<"Livestock", 'DateTime'>
    readonly customMetrics: FieldRef<"Livestock", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Livestock findUnique
   */
  export type LivestockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livestock
     */
    select?: LivestockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livestock
     */
    omit?: LivestockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockInclude<ExtArgs> | null
    /**
     * Filter, which Livestock to fetch.
     */
    where: LivestockWhereUniqueInput
  }

  /**
   * Livestock findUniqueOrThrow
   */
  export type LivestockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livestock
     */
    select?: LivestockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livestock
     */
    omit?: LivestockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockInclude<ExtArgs> | null
    /**
     * Filter, which Livestock to fetch.
     */
    where: LivestockWhereUniqueInput
  }

  /**
   * Livestock findFirst
   */
  export type LivestockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livestock
     */
    select?: LivestockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livestock
     */
    omit?: LivestockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockInclude<ExtArgs> | null
    /**
     * Filter, which Livestock to fetch.
     */
    where?: LivestockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Livestocks to fetch.
     */
    orderBy?: LivestockOrderByWithRelationInput | LivestockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Livestocks.
     */
    cursor?: LivestockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Livestocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Livestocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Livestocks.
     */
    distinct?: LivestockScalarFieldEnum | LivestockScalarFieldEnum[]
  }

  /**
   * Livestock findFirstOrThrow
   */
  export type LivestockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livestock
     */
    select?: LivestockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livestock
     */
    omit?: LivestockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockInclude<ExtArgs> | null
    /**
     * Filter, which Livestock to fetch.
     */
    where?: LivestockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Livestocks to fetch.
     */
    orderBy?: LivestockOrderByWithRelationInput | LivestockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Livestocks.
     */
    cursor?: LivestockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Livestocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Livestocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Livestocks.
     */
    distinct?: LivestockScalarFieldEnum | LivestockScalarFieldEnum[]
  }

  /**
   * Livestock findMany
   */
  export type LivestockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livestock
     */
    select?: LivestockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livestock
     */
    omit?: LivestockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockInclude<ExtArgs> | null
    /**
     * Filter, which Livestocks to fetch.
     */
    where?: LivestockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Livestocks to fetch.
     */
    orderBy?: LivestockOrderByWithRelationInput | LivestockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Livestocks.
     */
    cursor?: LivestockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Livestocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Livestocks.
     */
    skip?: number
    distinct?: LivestockScalarFieldEnum | LivestockScalarFieldEnum[]
  }

  /**
   * Livestock create
   */
  export type LivestockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livestock
     */
    select?: LivestockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livestock
     */
    omit?: LivestockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockInclude<ExtArgs> | null
    /**
     * The data needed to create a Livestock.
     */
    data: XOR<LivestockCreateInput, LivestockUncheckedCreateInput>
  }

  /**
   * Livestock createMany
   */
  export type LivestockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Livestocks.
     */
    data: LivestockCreateManyInput | LivestockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Livestock createManyAndReturn
   */
  export type LivestockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livestock
     */
    select?: LivestockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Livestock
     */
    omit?: LivestockOmit<ExtArgs> | null
    /**
     * The data used to create many Livestocks.
     */
    data: LivestockCreateManyInput | LivestockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Livestock update
   */
  export type LivestockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livestock
     */
    select?: LivestockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livestock
     */
    omit?: LivestockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockInclude<ExtArgs> | null
    /**
     * The data needed to update a Livestock.
     */
    data: XOR<LivestockUpdateInput, LivestockUncheckedUpdateInput>
    /**
     * Choose, which Livestock to update.
     */
    where: LivestockWhereUniqueInput
  }

  /**
   * Livestock updateMany
   */
  export type LivestockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Livestocks.
     */
    data: XOR<LivestockUpdateManyMutationInput, LivestockUncheckedUpdateManyInput>
    /**
     * Filter which Livestocks to update
     */
    where?: LivestockWhereInput
    /**
     * Limit how many Livestocks to update.
     */
    limit?: number
  }

  /**
   * Livestock updateManyAndReturn
   */
  export type LivestockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livestock
     */
    select?: LivestockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Livestock
     */
    omit?: LivestockOmit<ExtArgs> | null
    /**
     * The data used to update Livestocks.
     */
    data: XOR<LivestockUpdateManyMutationInput, LivestockUncheckedUpdateManyInput>
    /**
     * Filter which Livestocks to update
     */
    where?: LivestockWhereInput
    /**
     * Limit how many Livestocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Livestock upsert
   */
  export type LivestockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livestock
     */
    select?: LivestockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livestock
     */
    omit?: LivestockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockInclude<ExtArgs> | null
    /**
     * The filter to search for the Livestock to update in case it exists.
     */
    where: LivestockWhereUniqueInput
    /**
     * In case the Livestock found by the `where` argument doesn't exist, create a new Livestock with this data.
     */
    create: XOR<LivestockCreateInput, LivestockUncheckedCreateInput>
    /**
     * In case the Livestock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LivestockUpdateInput, LivestockUncheckedUpdateInput>
  }

  /**
   * Livestock delete
   */
  export type LivestockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livestock
     */
    select?: LivestockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livestock
     */
    omit?: LivestockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockInclude<ExtArgs> | null
    /**
     * Filter which Livestock to delete.
     */
    where: LivestockWhereUniqueInput
  }

  /**
   * Livestock deleteMany
   */
  export type LivestockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Livestocks to delete
     */
    where?: LivestockWhereInput
    /**
     * Limit how many Livestocks to delete.
     */
    limit?: number
  }

  /**
   * Livestock.milkLogs
   */
  export type Livestock$milkLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilkLog
     */
    select?: MilkLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MilkLog
     */
    omit?: MilkLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilkLogInclude<ExtArgs> | null
    where?: MilkLogWhereInput
    orderBy?: MilkLogOrderByWithRelationInput | MilkLogOrderByWithRelationInput[]
    cursor?: MilkLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MilkLogScalarFieldEnum | MilkLogScalarFieldEnum[]
  }

  /**
   * Livestock.eggLogs
   */
  export type Livestock$eggLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggLog
     */
    select?: EggLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggLog
     */
    omit?: EggLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggLogInclude<ExtArgs> | null
    where?: EggLogWhereInput
    orderBy?: EggLogOrderByWithRelationInput | EggLogOrderByWithRelationInput[]
    cursor?: EggLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EggLogScalarFieldEnum | EggLogScalarFieldEnum[]
  }

  /**
   * Livestock.honeyLogs
   */
  export type Livestock$honeyLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoneyLog
     */
    select?: HoneyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HoneyLog
     */
    omit?: HoneyLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoneyLogInclude<ExtArgs> | null
    where?: HoneyLogWhereInput
    orderBy?: HoneyLogOrderByWithRelationInput | HoneyLogOrderByWithRelationInput[]
    cursor?: HoneyLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HoneyLogScalarFieldEnum | HoneyLogScalarFieldEnum[]
  }

  /**
   * Livestock.woolLogs
   */
  export type Livestock$woolLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WoolLog
     */
    select?: WoolLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WoolLog
     */
    omit?: WoolLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WoolLogInclude<ExtArgs> | null
    where?: WoolLogWhereInput
    orderBy?: WoolLogOrderByWithRelationInput | WoolLogOrderByWithRelationInput[]
    cursor?: WoolLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WoolLogScalarFieldEnum | WoolLogScalarFieldEnum[]
  }

  /**
   * Livestock.weightLogs
   */
  export type Livestock$weightLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightLog
     */
    select?: WeightLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeightLog
     */
    omit?: WeightLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightLogInclude<ExtArgs> | null
    where?: WeightLogWhereInput
    orderBy?: WeightLogOrderByWithRelationInput | WeightLogOrderByWithRelationInput[]
    cursor?: WeightLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeightLogScalarFieldEnum | WeightLogScalarFieldEnum[]
  }

  /**
   * Livestock.metrics
   */
  export type Livestock$metricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivestockMetric
     */
    select?: LivestockMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivestockMetric
     */
    omit?: LivestockMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockMetricInclude<ExtArgs> | null
    where?: LivestockMetricWhereInput
    orderBy?: LivestockMetricOrderByWithRelationInput | LivestockMetricOrderByWithRelationInput[]
    cursor?: LivestockMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LivestockMetricScalarFieldEnum | LivestockMetricScalarFieldEnum[]
  }

  /**
   * Livestock without action
   */
  export type LivestockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livestock
     */
    select?: LivestockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livestock
     */
    omit?: LivestockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockInclude<ExtArgs> | null
  }


  /**
   * Model CropSpray
   */

  export type AggregateCropSpray = {
    _count: CropSprayCountAggregateOutputType | null
    _min: CropSprayMinAggregateOutputType | null
    _max: CropSprayMaxAggregateOutputType | null
  }

  export type CropSprayMinAggregateOutputType = {
    id: string | null
    cropId: string | null
    sprayedAt: Date | null
    pesticide: string | null
    createdAt: Date | null
  }

  export type CropSprayMaxAggregateOutputType = {
    id: string | null
    cropId: string | null
    sprayedAt: Date | null
    pesticide: string | null
    createdAt: Date | null
  }

  export type CropSprayCountAggregateOutputType = {
    id: number
    cropId: number
    sprayedAt: number
    pesticide: number
    createdAt: number
    _all: number
  }


  export type CropSprayMinAggregateInputType = {
    id?: true
    cropId?: true
    sprayedAt?: true
    pesticide?: true
    createdAt?: true
  }

  export type CropSprayMaxAggregateInputType = {
    id?: true
    cropId?: true
    sprayedAt?: true
    pesticide?: true
    createdAt?: true
  }

  export type CropSprayCountAggregateInputType = {
    id?: true
    cropId?: true
    sprayedAt?: true
    pesticide?: true
    createdAt?: true
    _all?: true
  }

  export type CropSprayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CropSpray to aggregate.
     */
    where?: CropSprayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CropSprays to fetch.
     */
    orderBy?: CropSprayOrderByWithRelationInput | CropSprayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CropSprayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CropSprays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CropSprays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CropSprays
    **/
    _count?: true | CropSprayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CropSprayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CropSprayMaxAggregateInputType
  }

  export type GetCropSprayAggregateType<T extends CropSprayAggregateArgs> = {
        [P in keyof T & keyof AggregateCropSpray]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCropSpray[P]>
      : GetScalarType<T[P], AggregateCropSpray[P]>
  }




  export type CropSprayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CropSprayWhereInput
    orderBy?: CropSprayOrderByWithAggregationInput | CropSprayOrderByWithAggregationInput[]
    by: CropSprayScalarFieldEnum[] | CropSprayScalarFieldEnum
    having?: CropSprayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CropSprayCountAggregateInputType | true
    _min?: CropSprayMinAggregateInputType
    _max?: CropSprayMaxAggregateInputType
  }

  export type CropSprayGroupByOutputType = {
    id: string
    cropId: string
    sprayedAt: Date
    pesticide: string | null
    createdAt: Date
    _count: CropSprayCountAggregateOutputType | null
    _min: CropSprayMinAggregateOutputType | null
    _max: CropSprayMaxAggregateOutputType | null
  }

  type GetCropSprayGroupByPayload<T extends CropSprayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CropSprayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CropSprayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CropSprayGroupByOutputType[P]>
            : GetScalarType<T[P], CropSprayGroupByOutputType[P]>
        }
      >
    >


  export type CropSpraySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cropId?: boolean
    sprayedAt?: boolean
    pesticide?: boolean
    createdAt?: boolean
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cropSpray"]>

  export type CropSpraySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cropId?: boolean
    sprayedAt?: boolean
    pesticide?: boolean
    createdAt?: boolean
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cropSpray"]>

  export type CropSpraySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cropId?: boolean
    sprayedAt?: boolean
    pesticide?: boolean
    createdAt?: boolean
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cropSpray"]>

  export type CropSpraySelectScalar = {
    id?: boolean
    cropId?: boolean
    sprayedAt?: boolean
    pesticide?: boolean
    createdAt?: boolean
  }

  export type CropSprayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cropId" | "sprayedAt" | "pesticide" | "createdAt", ExtArgs["result"]["cropSpray"]>
  export type CropSprayInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }
  export type CropSprayIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }
  export type CropSprayIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }

  export type $CropSprayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CropSpray"
    objects: {
      crop: Prisma.$CropPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cropId: string
      sprayedAt: Date
      pesticide: string | null
      createdAt: Date
    }, ExtArgs["result"]["cropSpray"]>
    composites: {}
  }

  type CropSprayGetPayload<S extends boolean | null | undefined | CropSprayDefaultArgs> = $Result.GetResult<Prisma.$CropSprayPayload, S>

  type CropSprayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CropSprayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CropSprayCountAggregateInputType | true
    }

  export interface CropSprayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CropSpray'], meta: { name: 'CropSpray' } }
    /**
     * Find zero or one CropSpray that matches the filter.
     * @param {CropSprayFindUniqueArgs} args - Arguments to find a CropSpray
     * @example
     * // Get one CropSpray
     * const cropSpray = await prisma.cropSpray.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CropSprayFindUniqueArgs>(args: SelectSubset<T, CropSprayFindUniqueArgs<ExtArgs>>): Prisma__CropSprayClient<$Result.GetResult<Prisma.$CropSprayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CropSpray that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CropSprayFindUniqueOrThrowArgs} args - Arguments to find a CropSpray
     * @example
     * // Get one CropSpray
     * const cropSpray = await prisma.cropSpray.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CropSprayFindUniqueOrThrowArgs>(args: SelectSubset<T, CropSprayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CropSprayClient<$Result.GetResult<Prisma.$CropSprayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CropSpray that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropSprayFindFirstArgs} args - Arguments to find a CropSpray
     * @example
     * // Get one CropSpray
     * const cropSpray = await prisma.cropSpray.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CropSprayFindFirstArgs>(args?: SelectSubset<T, CropSprayFindFirstArgs<ExtArgs>>): Prisma__CropSprayClient<$Result.GetResult<Prisma.$CropSprayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CropSpray that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropSprayFindFirstOrThrowArgs} args - Arguments to find a CropSpray
     * @example
     * // Get one CropSpray
     * const cropSpray = await prisma.cropSpray.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CropSprayFindFirstOrThrowArgs>(args?: SelectSubset<T, CropSprayFindFirstOrThrowArgs<ExtArgs>>): Prisma__CropSprayClient<$Result.GetResult<Prisma.$CropSprayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CropSprays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropSprayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CropSprays
     * const cropSprays = await prisma.cropSpray.findMany()
     * 
     * // Get first 10 CropSprays
     * const cropSprays = await prisma.cropSpray.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cropSprayWithIdOnly = await prisma.cropSpray.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CropSprayFindManyArgs>(args?: SelectSubset<T, CropSprayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropSprayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CropSpray.
     * @param {CropSprayCreateArgs} args - Arguments to create a CropSpray.
     * @example
     * // Create one CropSpray
     * const CropSpray = await prisma.cropSpray.create({
     *   data: {
     *     // ... data to create a CropSpray
     *   }
     * })
     * 
     */
    create<T extends CropSprayCreateArgs>(args: SelectSubset<T, CropSprayCreateArgs<ExtArgs>>): Prisma__CropSprayClient<$Result.GetResult<Prisma.$CropSprayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CropSprays.
     * @param {CropSprayCreateManyArgs} args - Arguments to create many CropSprays.
     * @example
     * // Create many CropSprays
     * const cropSpray = await prisma.cropSpray.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CropSprayCreateManyArgs>(args?: SelectSubset<T, CropSprayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CropSprays and returns the data saved in the database.
     * @param {CropSprayCreateManyAndReturnArgs} args - Arguments to create many CropSprays.
     * @example
     * // Create many CropSprays
     * const cropSpray = await prisma.cropSpray.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CropSprays and only return the `id`
     * const cropSprayWithIdOnly = await prisma.cropSpray.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CropSprayCreateManyAndReturnArgs>(args?: SelectSubset<T, CropSprayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropSprayPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CropSpray.
     * @param {CropSprayDeleteArgs} args - Arguments to delete one CropSpray.
     * @example
     * // Delete one CropSpray
     * const CropSpray = await prisma.cropSpray.delete({
     *   where: {
     *     // ... filter to delete one CropSpray
     *   }
     * })
     * 
     */
    delete<T extends CropSprayDeleteArgs>(args: SelectSubset<T, CropSprayDeleteArgs<ExtArgs>>): Prisma__CropSprayClient<$Result.GetResult<Prisma.$CropSprayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CropSpray.
     * @param {CropSprayUpdateArgs} args - Arguments to update one CropSpray.
     * @example
     * // Update one CropSpray
     * const cropSpray = await prisma.cropSpray.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CropSprayUpdateArgs>(args: SelectSubset<T, CropSprayUpdateArgs<ExtArgs>>): Prisma__CropSprayClient<$Result.GetResult<Prisma.$CropSprayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CropSprays.
     * @param {CropSprayDeleteManyArgs} args - Arguments to filter CropSprays to delete.
     * @example
     * // Delete a few CropSprays
     * const { count } = await prisma.cropSpray.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CropSprayDeleteManyArgs>(args?: SelectSubset<T, CropSprayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CropSprays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropSprayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CropSprays
     * const cropSpray = await prisma.cropSpray.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CropSprayUpdateManyArgs>(args: SelectSubset<T, CropSprayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CropSprays and returns the data updated in the database.
     * @param {CropSprayUpdateManyAndReturnArgs} args - Arguments to update many CropSprays.
     * @example
     * // Update many CropSprays
     * const cropSpray = await prisma.cropSpray.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CropSprays and only return the `id`
     * const cropSprayWithIdOnly = await prisma.cropSpray.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CropSprayUpdateManyAndReturnArgs>(args: SelectSubset<T, CropSprayUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropSprayPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CropSpray.
     * @param {CropSprayUpsertArgs} args - Arguments to update or create a CropSpray.
     * @example
     * // Update or create a CropSpray
     * const cropSpray = await prisma.cropSpray.upsert({
     *   create: {
     *     // ... data to create a CropSpray
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CropSpray we want to update
     *   }
     * })
     */
    upsert<T extends CropSprayUpsertArgs>(args: SelectSubset<T, CropSprayUpsertArgs<ExtArgs>>): Prisma__CropSprayClient<$Result.GetResult<Prisma.$CropSprayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CropSprays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropSprayCountArgs} args - Arguments to filter CropSprays to count.
     * @example
     * // Count the number of CropSprays
     * const count = await prisma.cropSpray.count({
     *   where: {
     *     // ... the filter for the CropSprays we want to count
     *   }
     * })
    **/
    count<T extends CropSprayCountArgs>(
      args?: Subset<T, CropSprayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CropSprayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CropSpray.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropSprayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CropSprayAggregateArgs>(args: Subset<T, CropSprayAggregateArgs>): Prisma.PrismaPromise<GetCropSprayAggregateType<T>>

    /**
     * Group by CropSpray.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropSprayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CropSprayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CropSprayGroupByArgs['orderBy'] }
        : { orderBy?: CropSprayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CropSprayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCropSprayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CropSpray model
   */
  readonly fields: CropSprayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CropSpray.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CropSprayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    crop<T extends CropDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CropDefaultArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CropSpray model
   */
  interface CropSprayFieldRefs {
    readonly id: FieldRef<"CropSpray", 'String'>
    readonly cropId: FieldRef<"CropSpray", 'String'>
    readonly sprayedAt: FieldRef<"CropSpray", 'DateTime'>
    readonly pesticide: FieldRef<"CropSpray", 'String'>
    readonly createdAt: FieldRef<"CropSpray", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CropSpray findUnique
   */
  export type CropSprayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropSpray
     */
    select?: CropSpraySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropSpray
     */
    omit?: CropSprayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropSprayInclude<ExtArgs> | null
    /**
     * Filter, which CropSpray to fetch.
     */
    where: CropSprayWhereUniqueInput
  }

  /**
   * CropSpray findUniqueOrThrow
   */
  export type CropSprayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropSpray
     */
    select?: CropSpraySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropSpray
     */
    omit?: CropSprayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropSprayInclude<ExtArgs> | null
    /**
     * Filter, which CropSpray to fetch.
     */
    where: CropSprayWhereUniqueInput
  }

  /**
   * CropSpray findFirst
   */
  export type CropSprayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropSpray
     */
    select?: CropSpraySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropSpray
     */
    omit?: CropSprayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropSprayInclude<ExtArgs> | null
    /**
     * Filter, which CropSpray to fetch.
     */
    where?: CropSprayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CropSprays to fetch.
     */
    orderBy?: CropSprayOrderByWithRelationInput | CropSprayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CropSprays.
     */
    cursor?: CropSprayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CropSprays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CropSprays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CropSprays.
     */
    distinct?: CropSprayScalarFieldEnum | CropSprayScalarFieldEnum[]
  }

  /**
   * CropSpray findFirstOrThrow
   */
  export type CropSprayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropSpray
     */
    select?: CropSpraySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropSpray
     */
    omit?: CropSprayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropSprayInclude<ExtArgs> | null
    /**
     * Filter, which CropSpray to fetch.
     */
    where?: CropSprayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CropSprays to fetch.
     */
    orderBy?: CropSprayOrderByWithRelationInput | CropSprayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CropSprays.
     */
    cursor?: CropSprayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CropSprays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CropSprays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CropSprays.
     */
    distinct?: CropSprayScalarFieldEnum | CropSprayScalarFieldEnum[]
  }

  /**
   * CropSpray findMany
   */
  export type CropSprayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropSpray
     */
    select?: CropSpraySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropSpray
     */
    omit?: CropSprayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropSprayInclude<ExtArgs> | null
    /**
     * Filter, which CropSprays to fetch.
     */
    where?: CropSprayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CropSprays to fetch.
     */
    orderBy?: CropSprayOrderByWithRelationInput | CropSprayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CropSprays.
     */
    cursor?: CropSprayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CropSprays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CropSprays.
     */
    skip?: number
    distinct?: CropSprayScalarFieldEnum | CropSprayScalarFieldEnum[]
  }

  /**
   * CropSpray create
   */
  export type CropSprayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropSpray
     */
    select?: CropSpraySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropSpray
     */
    omit?: CropSprayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropSprayInclude<ExtArgs> | null
    /**
     * The data needed to create a CropSpray.
     */
    data: XOR<CropSprayCreateInput, CropSprayUncheckedCreateInput>
  }

  /**
   * CropSpray createMany
   */
  export type CropSprayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CropSprays.
     */
    data: CropSprayCreateManyInput | CropSprayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CropSpray createManyAndReturn
   */
  export type CropSprayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropSpray
     */
    select?: CropSpraySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CropSpray
     */
    omit?: CropSprayOmit<ExtArgs> | null
    /**
     * The data used to create many CropSprays.
     */
    data: CropSprayCreateManyInput | CropSprayCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropSprayIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CropSpray update
   */
  export type CropSprayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropSpray
     */
    select?: CropSpraySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropSpray
     */
    omit?: CropSprayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropSprayInclude<ExtArgs> | null
    /**
     * The data needed to update a CropSpray.
     */
    data: XOR<CropSprayUpdateInput, CropSprayUncheckedUpdateInput>
    /**
     * Choose, which CropSpray to update.
     */
    where: CropSprayWhereUniqueInput
  }

  /**
   * CropSpray updateMany
   */
  export type CropSprayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CropSprays.
     */
    data: XOR<CropSprayUpdateManyMutationInput, CropSprayUncheckedUpdateManyInput>
    /**
     * Filter which CropSprays to update
     */
    where?: CropSprayWhereInput
    /**
     * Limit how many CropSprays to update.
     */
    limit?: number
  }

  /**
   * CropSpray updateManyAndReturn
   */
  export type CropSprayUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropSpray
     */
    select?: CropSpraySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CropSpray
     */
    omit?: CropSprayOmit<ExtArgs> | null
    /**
     * The data used to update CropSprays.
     */
    data: XOR<CropSprayUpdateManyMutationInput, CropSprayUncheckedUpdateManyInput>
    /**
     * Filter which CropSprays to update
     */
    where?: CropSprayWhereInput
    /**
     * Limit how many CropSprays to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropSprayIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CropSpray upsert
   */
  export type CropSprayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropSpray
     */
    select?: CropSpraySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropSpray
     */
    omit?: CropSprayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropSprayInclude<ExtArgs> | null
    /**
     * The filter to search for the CropSpray to update in case it exists.
     */
    where: CropSprayWhereUniqueInput
    /**
     * In case the CropSpray found by the `where` argument doesn't exist, create a new CropSpray with this data.
     */
    create: XOR<CropSprayCreateInput, CropSprayUncheckedCreateInput>
    /**
     * In case the CropSpray was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CropSprayUpdateInput, CropSprayUncheckedUpdateInput>
  }

  /**
   * CropSpray delete
   */
  export type CropSprayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropSpray
     */
    select?: CropSpraySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropSpray
     */
    omit?: CropSprayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropSprayInclude<ExtArgs> | null
    /**
     * Filter which CropSpray to delete.
     */
    where: CropSprayWhereUniqueInput
  }

  /**
   * CropSpray deleteMany
   */
  export type CropSprayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CropSprays to delete
     */
    where?: CropSprayWhereInput
    /**
     * Limit how many CropSprays to delete.
     */
    limit?: number
  }

  /**
   * CropSpray without action
   */
  export type CropSprayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropSpray
     */
    select?: CropSpraySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropSpray
     */
    omit?: CropSprayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropSprayInclude<ExtArgs> | null
  }


  /**
   * Model CropHarvest
   */

  export type AggregateCropHarvest = {
    _count: CropHarvestCountAggregateOutputType | null
    _avg: CropHarvestAvgAggregateOutputType | null
    _sum: CropHarvestSumAggregateOutputType | null
    _min: CropHarvestMinAggregateOutputType | null
    _max: CropHarvestMaxAggregateOutputType | null
  }

  export type CropHarvestAvgAggregateOutputType = {
    amountTon: number | null
    yieldTonPerHa: number | null
  }

  export type CropHarvestSumAggregateOutputType = {
    amountTon: number | null
    yieldTonPerHa: number | null
  }

  export type CropHarvestMinAggregateOutputType = {
    id: string | null
    cropId: string | null
    harvestedAt: Date | null
    amountTon: number | null
    yieldTonPerHa: number | null
    createdAt: Date | null
  }

  export type CropHarvestMaxAggregateOutputType = {
    id: string | null
    cropId: string | null
    harvestedAt: Date | null
    amountTon: number | null
    yieldTonPerHa: number | null
    createdAt: Date | null
  }

  export type CropHarvestCountAggregateOutputType = {
    id: number
    cropId: number
    harvestedAt: number
    amountTon: number
    yieldTonPerHa: number
    createdAt: number
    _all: number
  }


  export type CropHarvestAvgAggregateInputType = {
    amountTon?: true
    yieldTonPerHa?: true
  }

  export type CropHarvestSumAggregateInputType = {
    amountTon?: true
    yieldTonPerHa?: true
  }

  export type CropHarvestMinAggregateInputType = {
    id?: true
    cropId?: true
    harvestedAt?: true
    amountTon?: true
    yieldTonPerHa?: true
    createdAt?: true
  }

  export type CropHarvestMaxAggregateInputType = {
    id?: true
    cropId?: true
    harvestedAt?: true
    amountTon?: true
    yieldTonPerHa?: true
    createdAt?: true
  }

  export type CropHarvestCountAggregateInputType = {
    id?: true
    cropId?: true
    harvestedAt?: true
    amountTon?: true
    yieldTonPerHa?: true
    createdAt?: true
    _all?: true
  }

  export type CropHarvestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CropHarvest to aggregate.
     */
    where?: CropHarvestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CropHarvests to fetch.
     */
    orderBy?: CropHarvestOrderByWithRelationInput | CropHarvestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CropHarvestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CropHarvests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CropHarvests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CropHarvests
    **/
    _count?: true | CropHarvestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CropHarvestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CropHarvestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CropHarvestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CropHarvestMaxAggregateInputType
  }

  export type GetCropHarvestAggregateType<T extends CropHarvestAggregateArgs> = {
        [P in keyof T & keyof AggregateCropHarvest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCropHarvest[P]>
      : GetScalarType<T[P], AggregateCropHarvest[P]>
  }




  export type CropHarvestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CropHarvestWhereInput
    orderBy?: CropHarvestOrderByWithAggregationInput | CropHarvestOrderByWithAggregationInput[]
    by: CropHarvestScalarFieldEnum[] | CropHarvestScalarFieldEnum
    having?: CropHarvestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CropHarvestCountAggregateInputType | true
    _avg?: CropHarvestAvgAggregateInputType
    _sum?: CropHarvestSumAggregateInputType
    _min?: CropHarvestMinAggregateInputType
    _max?: CropHarvestMaxAggregateInputType
  }

  export type CropHarvestGroupByOutputType = {
    id: string
    cropId: string
    harvestedAt: Date
    amountTon: number
    yieldTonPerHa: number | null
    createdAt: Date
    _count: CropHarvestCountAggregateOutputType | null
    _avg: CropHarvestAvgAggregateOutputType | null
    _sum: CropHarvestSumAggregateOutputType | null
    _min: CropHarvestMinAggregateOutputType | null
    _max: CropHarvestMaxAggregateOutputType | null
  }

  type GetCropHarvestGroupByPayload<T extends CropHarvestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CropHarvestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CropHarvestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CropHarvestGroupByOutputType[P]>
            : GetScalarType<T[P], CropHarvestGroupByOutputType[P]>
        }
      >
    >


  export type CropHarvestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cropId?: boolean
    harvestedAt?: boolean
    amountTon?: boolean
    yieldTonPerHa?: boolean
    createdAt?: boolean
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cropHarvest"]>

  export type CropHarvestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cropId?: boolean
    harvestedAt?: boolean
    amountTon?: boolean
    yieldTonPerHa?: boolean
    createdAt?: boolean
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cropHarvest"]>

  export type CropHarvestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cropId?: boolean
    harvestedAt?: boolean
    amountTon?: boolean
    yieldTonPerHa?: boolean
    createdAt?: boolean
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cropHarvest"]>

  export type CropHarvestSelectScalar = {
    id?: boolean
    cropId?: boolean
    harvestedAt?: boolean
    amountTon?: boolean
    yieldTonPerHa?: boolean
    createdAt?: boolean
  }

  export type CropHarvestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cropId" | "harvestedAt" | "amountTon" | "yieldTonPerHa" | "createdAt", ExtArgs["result"]["cropHarvest"]>
  export type CropHarvestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }
  export type CropHarvestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }
  export type CropHarvestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }

  export type $CropHarvestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CropHarvest"
    objects: {
      crop: Prisma.$CropPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cropId: string
      harvestedAt: Date
      amountTon: number
      yieldTonPerHa: number | null
      createdAt: Date
    }, ExtArgs["result"]["cropHarvest"]>
    composites: {}
  }

  type CropHarvestGetPayload<S extends boolean | null | undefined | CropHarvestDefaultArgs> = $Result.GetResult<Prisma.$CropHarvestPayload, S>

  type CropHarvestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CropHarvestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CropHarvestCountAggregateInputType | true
    }

  export interface CropHarvestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CropHarvest'], meta: { name: 'CropHarvest' } }
    /**
     * Find zero or one CropHarvest that matches the filter.
     * @param {CropHarvestFindUniqueArgs} args - Arguments to find a CropHarvest
     * @example
     * // Get one CropHarvest
     * const cropHarvest = await prisma.cropHarvest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CropHarvestFindUniqueArgs>(args: SelectSubset<T, CropHarvestFindUniqueArgs<ExtArgs>>): Prisma__CropHarvestClient<$Result.GetResult<Prisma.$CropHarvestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CropHarvest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CropHarvestFindUniqueOrThrowArgs} args - Arguments to find a CropHarvest
     * @example
     * // Get one CropHarvest
     * const cropHarvest = await prisma.cropHarvest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CropHarvestFindUniqueOrThrowArgs>(args: SelectSubset<T, CropHarvestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CropHarvestClient<$Result.GetResult<Prisma.$CropHarvestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CropHarvest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropHarvestFindFirstArgs} args - Arguments to find a CropHarvest
     * @example
     * // Get one CropHarvest
     * const cropHarvest = await prisma.cropHarvest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CropHarvestFindFirstArgs>(args?: SelectSubset<T, CropHarvestFindFirstArgs<ExtArgs>>): Prisma__CropHarvestClient<$Result.GetResult<Prisma.$CropHarvestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CropHarvest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropHarvestFindFirstOrThrowArgs} args - Arguments to find a CropHarvest
     * @example
     * // Get one CropHarvest
     * const cropHarvest = await prisma.cropHarvest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CropHarvestFindFirstOrThrowArgs>(args?: SelectSubset<T, CropHarvestFindFirstOrThrowArgs<ExtArgs>>): Prisma__CropHarvestClient<$Result.GetResult<Prisma.$CropHarvestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CropHarvests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropHarvestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CropHarvests
     * const cropHarvests = await prisma.cropHarvest.findMany()
     * 
     * // Get first 10 CropHarvests
     * const cropHarvests = await prisma.cropHarvest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cropHarvestWithIdOnly = await prisma.cropHarvest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CropHarvestFindManyArgs>(args?: SelectSubset<T, CropHarvestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropHarvestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CropHarvest.
     * @param {CropHarvestCreateArgs} args - Arguments to create a CropHarvest.
     * @example
     * // Create one CropHarvest
     * const CropHarvest = await prisma.cropHarvest.create({
     *   data: {
     *     // ... data to create a CropHarvest
     *   }
     * })
     * 
     */
    create<T extends CropHarvestCreateArgs>(args: SelectSubset<T, CropHarvestCreateArgs<ExtArgs>>): Prisma__CropHarvestClient<$Result.GetResult<Prisma.$CropHarvestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CropHarvests.
     * @param {CropHarvestCreateManyArgs} args - Arguments to create many CropHarvests.
     * @example
     * // Create many CropHarvests
     * const cropHarvest = await prisma.cropHarvest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CropHarvestCreateManyArgs>(args?: SelectSubset<T, CropHarvestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CropHarvests and returns the data saved in the database.
     * @param {CropHarvestCreateManyAndReturnArgs} args - Arguments to create many CropHarvests.
     * @example
     * // Create many CropHarvests
     * const cropHarvest = await prisma.cropHarvest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CropHarvests and only return the `id`
     * const cropHarvestWithIdOnly = await prisma.cropHarvest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CropHarvestCreateManyAndReturnArgs>(args?: SelectSubset<T, CropHarvestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropHarvestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CropHarvest.
     * @param {CropHarvestDeleteArgs} args - Arguments to delete one CropHarvest.
     * @example
     * // Delete one CropHarvest
     * const CropHarvest = await prisma.cropHarvest.delete({
     *   where: {
     *     // ... filter to delete one CropHarvest
     *   }
     * })
     * 
     */
    delete<T extends CropHarvestDeleteArgs>(args: SelectSubset<T, CropHarvestDeleteArgs<ExtArgs>>): Prisma__CropHarvestClient<$Result.GetResult<Prisma.$CropHarvestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CropHarvest.
     * @param {CropHarvestUpdateArgs} args - Arguments to update one CropHarvest.
     * @example
     * // Update one CropHarvest
     * const cropHarvest = await prisma.cropHarvest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CropHarvestUpdateArgs>(args: SelectSubset<T, CropHarvestUpdateArgs<ExtArgs>>): Prisma__CropHarvestClient<$Result.GetResult<Prisma.$CropHarvestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CropHarvests.
     * @param {CropHarvestDeleteManyArgs} args - Arguments to filter CropHarvests to delete.
     * @example
     * // Delete a few CropHarvests
     * const { count } = await prisma.cropHarvest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CropHarvestDeleteManyArgs>(args?: SelectSubset<T, CropHarvestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CropHarvests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropHarvestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CropHarvests
     * const cropHarvest = await prisma.cropHarvest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CropHarvestUpdateManyArgs>(args: SelectSubset<T, CropHarvestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CropHarvests and returns the data updated in the database.
     * @param {CropHarvestUpdateManyAndReturnArgs} args - Arguments to update many CropHarvests.
     * @example
     * // Update many CropHarvests
     * const cropHarvest = await prisma.cropHarvest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CropHarvests and only return the `id`
     * const cropHarvestWithIdOnly = await prisma.cropHarvest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CropHarvestUpdateManyAndReturnArgs>(args: SelectSubset<T, CropHarvestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropHarvestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CropHarvest.
     * @param {CropHarvestUpsertArgs} args - Arguments to update or create a CropHarvest.
     * @example
     * // Update or create a CropHarvest
     * const cropHarvest = await prisma.cropHarvest.upsert({
     *   create: {
     *     // ... data to create a CropHarvest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CropHarvest we want to update
     *   }
     * })
     */
    upsert<T extends CropHarvestUpsertArgs>(args: SelectSubset<T, CropHarvestUpsertArgs<ExtArgs>>): Prisma__CropHarvestClient<$Result.GetResult<Prisma.$CropHarvestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CropHarvests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropHarvestCountArgs} args - Arguments to filter CropHarvests to count.
     * @example
     * // Count the number of CropHarvests
     * const count = await prisma.cropHarvest.count({
     *   where: {
     *     // ... the filter for the CropHarvests we want to count
     *   }
     * })
    **/
    count<T extends CropHarvestCountArgs>(
      args?: Subset<T, CropHarvestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CropHarvestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CropHarvest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropHarvestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CropHarvestAggregateArgs>(args: Subset<T, CropHarvestAggregateArgs>): Prisma.PrismaPromise<GetCropHarvestAggregateType<T>>

    /**
     * Group by CropHarvest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropHarvestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CropHarvestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CropHarvestGroupByArgs['orderBy'] }
        : { orderBy?: CropHarvestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CropHarvestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCropHarvestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CropHarvest model
   */
  readonly fields: CropHarvestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CropHarvest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CropHarvestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    crop<T extends CropDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CropDefaultArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CropHarvest model
   */
  interface CropHarvestFieldRefs {
    readonly id: FieldRef<"CropHarvest", 'String'>
    readonly cropId: FieldRef<"CropHarvest", 'String'>
    readonly harvestedAt: FieldRef<"CropHarvest", 'DateTime'>
    readonly amountTon: FieldRef<"CropHarvest", 'Float'>
    readonly yieldTonPerHa: FieldRef<"CropHarvest", 'Float'>
    readonly createdAt: FieldRef<"CropHarvest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CropHarvest findUnique
   */
  export type CropHarvestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropHarvest
     */
    select?: CropHarvestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropHarvest
     */
    omit?: CropHarvestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropHarvestInclude<ExtArgs> | null
    /**
     * Filter, which CropHarvest to fetch.
     */
    where: CropHarvestWhereUniqueInput
  }

  /**
   * CropHarvest findUniqueOrThrow
   */
  export type CropHarvestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropHarvest
     */
    select?: CropHarvestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropHarvest
     */
    omit?: CropHarvestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropHarvestInclude<ExtArgs> | null
    /**
     * Filter, which CropHarvest to fetch.
     */
    where: CropHarvestWhereUniqueInput
  }

  /**
   * CropHarvest findFirst
   */
  export type CropHarvestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropHarvest
     */
    select?: CropHarvestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropHarvest
     */
    omit?: CropHarvestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropHarvestInclude<ExtArgs> | null
    /**
     * Filter, which CropHarvest to fetch.
     */
    where?: CropHarvestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CropHarvests to fetch.
     */
    orderBy?: CropHarvestOrderByWithRelationInput | CropHarvestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CropHarvests.
     */
    cursor?: CropHarvestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CropHarvests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CropHarvests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CropHarvests.
     */
    distinct?: CropHarvestScalarFieldEnum | CropHarvestScalarFieldEnum[]
  }

  /**
   * CropHarvest findFirstOrThrow
   */
  export type CropHarvestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropHarvest
     */
    select?: CropHarvestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropHarvest
     */
    omit?: CropHarvestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropHarvestInclude<ExtArgs> | null
    /**
     * Filter, which CropHarvest to fetch.
     */
    where?: CropHarvestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CropHarvests to fetch.
     */
    orderBy?: CropHarvestOrderByWithRelationInput | CropHarvestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CropHarvests.
     */
    cursor?: CropHarvestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CropHarvests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CropHarvests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CropHarvests.
     */
    distinct?: CropHarvestScalarFieldEnum | CropHarvestScalarFieldEnum[]
  }

  /**
   * CropHarvest findMany
   */
  export type CropHarvestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropHarvest
     */
    select?: CropHarvestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropHarvest
     */
    omit?: CropHarvestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropHarvestInclude<ExtArgs> | null
    /**
     * Filter, which CropHarvests to fetch.
     */
    where?: CropHarvestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CropHarvests to fetch.
     */
    orderBy?: CropHarvestOrderByWithRelationInput | CropHarvestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CropHarvests.
     */
    cursor?: CropHarvestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CropHarvests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CropHarvests.
     */
    skip?: number
    distinct?: CropHarvestScalarFieldEnum | CropHarvestScalarFieldEnum[]
  }

  /**
   * CropHarvest create
   */
  export type CropHarvestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropHarvest
     */
    select?: CropHarvestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropHarvest
     */
    omit?: CropHarvestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropHarvestInclude<ExtArgs> | null
    /**
     * The data needed to create a CropHarvest.
     */
    data: XOR<CropHarvestCreateInput, CropHarvestUncheckedCreateInput>
  }

  /**
   * CropHarvest createMany
   */
  export type CropHarvestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CropHarvests.
     */
    data: CropHarvestCreateManyInput | CropHarvestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CropHarvest createManyAndReturn
   */
  export type CropHarvestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropHarvest
     */
    select?: CropHarvestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CropHarvest
     */
    omit?: CropHarvestOmit<ExtArgs> | null
    /**
     * The data used to create many CropHarvests.
     */
    data: CropHarvestCreateManyInput | CropHarvestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropHarvestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CropHarvest update
   */
  export type CropHarvestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropHarvest
     */
    select?: CropHarvestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropHarvest
     */
    omit?: CropHarvestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropHarvestInclude<ExtArgs> | null
    /**
     * The data needed to update a CropHarvest.
     */
    data: XOR<CropHarvestUpdateInput, CropHarvestUncheckedUpdateInput>
    /**
     * Choose, which CropHarvest to update.
     */
    where: CropHarvestWhereUniqueInput
  }

  /**
   * CropHarvest updateMany
   */
  export type CropHarvestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CropHarvests.
     */
    data: XOR<CropHarvestUpdateManyMutationInput, CropHarvestUncheckedUpdateManyInput>
    /**
     * Filter which CropHarvests to update
     */
    where?: CropHarvestWhereInput
    /**
     * Limit how many CropHarvests to update.
     */
    limit?: number
  }

  /**
   * CropHarvest updateManyAndReturn
   */
  export type CropHarvestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropHarvest
     */
    select?: CropHarvestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CropHarvest
     */
    omit?: CropHarvestOmit<ExtArgs> | null
    /**
     * The data used to update CropHarvests.
     */
    data: XOR<CropHarvestUpdateManyMutationInput, CropHarvestUncheckedUpdateManyInput>
    /**
     * Filter which CropHarvests to update
     */
    where?: CropHarvestWhereInput
    /**
     * Limit how many CropHarvests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropHarvestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CropHarvest upsert
   */
  export type CropHarvestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropHarvest
     */
    select?: CropHarvestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropHarvest
     */
    omit?: CropHarvestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropHarvestInclude<ExtArgs> | null
    /**
     * The filter to search for the CropHarvest to update in case it exists.
     */
    where: CropHarvestWhereUniqueInput
    /**
     * In case the CropHarvest found by the `where` argument doesn't exist, create a new CropHarvest with this data.
     */
    create: XOR<CropHarvestCreateInput, CropHarvestUncheckedCreateInput>
    /**
     * In case the CropHarvest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CropHarvestUpdateInput, CropHarvestUncheckedUpdateInput>
  }

  /**
   * CropHarvest delete
   */
  export type CropHarvestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropHarvest
     */
    select?: CropHarvestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropHarvest
     */
    omit?: CropHarvestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropHarvestInclude<ExtArgs> | null
    /**
     * Filter which CropHarvest to delete.
     */
    where: CropHarvestWhereUniqueInput
  }

  /**
   * CropHarvest deleteMany
   */
  export type CropHarvestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CropHarvests to delete
     */
    where?: CropHarvestWhereInput
    /**
     * Limit how many CropHarvests to delete.
     */
    limit?: number
  }

  /**
   * CropHarvest without action
   */
  export type CropHarvestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropHarvest
     */
    select?: CropHarvestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropHarvest
     */
    omit?: CropHarvestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropHarvestInclude<ExtArgs> | null
  }


  /**
   * Model MilkLog
   */

  export type AggregateMilkLog = {
    _count: MilkLogCountAggregateOutputType | null
    _avg: MilkLogAvgAggregateOutputType | null
    _sum: MilkLogSumAggregateOutputType | null
    _min: MilkLogMinAggregateOutputType | null
    _max: MilkLogMaxAggregateOutputType | null
  }

  export type MilkLogAvgAggregateOutputType = {
    quantityL: number | null
    fatPercent: number | null
  }

  export type MilkLogSumAggregateOutputType = {
    quantityL: number | null
    fatPercent: number | null
  }

  export type MilkLogMinAggregateOutputType = {
    id: string | null
    livestockId: string | null
    measuredAt: Date | null
    quantityL: number | null
    fatPercent: number | null
    createdAt: Date | null
  }

  export type MilkLogMaxAggregateOutputType = {
    id: string | null
    livestockId: string | null
    measuredAt: Date | null
    quantityL: number | null
    fatPercent: number | null
    createdAt: Date | null
  }

  export type MilkLogCountAggregateOutputType = {
    id: number
    livestockId: number
    measuredAt: number
    quantityL: number
    fatPercent: number
    createdAt: number
    _all: number
  }


  export type MilkLogAvgAggregateInputType = {
    quantityL?: true
    fatPercent?: true
  }

  export type MilkLogSumAggregateInputType = {
    quantityL?: true
    fatPercent?: true
  }

  export type MilkLogMinAggregateInputType = {
    id?: true
    livestockId?: true
    measuredAt?: true
    quantityL?: true
    fatPercent?: true
    createdAt?: true
  }

  export type MilkLogMaxAggregateInputType = {
    id?: true
    livestockId?: true
    measuredAt?: true
    quantityL?: true
    fatPercent?: true
    createdAt?: true
  }

  export type MilkLogCountAggregateInputType = {
    id?: true
    livestockId?: true
    measuredAt?: true
    quantityL?: true
    fatPercent?: true
    createdAt?: true
    _all?: true
  }

  export type MilkLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MilkLog to aggregate.
     */
    where?: MilkLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MilkLogs to fetch.
     */
    orderBy?: MilkLogOrderByWithRelationInput | MilkLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MilkLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MilkLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MilkLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MilkLogs
    **/
    _count?: true | MilkLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MilkLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MilkLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MilkLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MilkLogMaxAggregateInputType
  }

  export type GetMilkLogAggregateType<T extends MilkLogAggregateArgs> = {
        [P in keyof T & keyof AggregateMilkLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMilkLog[P]>
      : GetScalarType<T[P], AggregateMilkLog[P]>
  }




  export type MilkLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilkLogWhereInput
    orderBy?: MilkLogOrderByWithAggregationInput | MilkLogOrderByWithAggregationInput[]
    by: MilkLogScalarFieldEnum[] | MilkLogScalarFieldEnum
    having?: MilkLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MilkLogCountAggregateInputType | true
    _avg?: MilkLogAvgAggregateInputType
    _sum?: MilkLogSumAggregateInputType
    _min?: MilkLogMinAggregateInputType
    _max?: MilkLogMaxAggregateInputType
  }

  export type MilkLogGroupByOutputType = {
    id: string
    livestockId: string
    measuredAt: Date
    quantityL: number
    fatPercent: number | null
    createdAt: Date
    _count: MilkLogCountAggregateOutputType | null
    _avg: MilkLogAvgAggregateOutputType | null
    _sum: MilkLogSumAggregateOutputType | null
    _min: MilkLogMinAggregateOutputType | null
    _max: MilkLogMaxAggregateOutputType | null
  }

  type GetMilkLogGroupByPayload<T extends MilkLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MilkLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MilkLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MilkLogGroupByOutputType[P]>
            : GetScalarType<T[P], MilkLogGroupByOutputType[P]>
        }
      >
    >


  export type MilkLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    livestockId?: boolean
    measuredAt?: boolean
    quantityL?: boolean
    fatPercent?: boolean
    createdAt?: boolean
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milkLog"]>

  export type MilkLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    livestockId?: boolean
    measuredAt?: boolean
    quantityL?: boolean
    fatPercent?: boolean
    createdAt?: boolean
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milkLog"]>

  export type MilkLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    livestockId?: boolean
    measuredAt?: boolean
    quantityL?: boolean
    fatPercent?: boolean
    createdAt?: boolean
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milkLog"]>

  export type MilkLogSelectScalar = {
    id?: boolean
    livestockId?: boolean
    measuredAt?: boolean
    quantityL?: boolean
    fatPercent?: boolean
    createdAt?: boolean
  }

  export type MilkLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "livestockId" | "measuredAt" | "quantityL" | "fatPercent" | "createdAt", ExtArgs["result"]["milkLog"]>
  export type MilkLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }
  export type MilkLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }
  export type MilkLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }

  export type $MilkLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MilkLog"
    objects: {
      livestock: Prisma.$LivestockPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      livestockId: string
      measuredAt: Date
      quantityL: number
      fatPercent: number | null
      createdAt: Date
    }, ExtArgs["result"]["milkLog"]>
    composites: {}
  }

  type MilkLogGetPayload<S extends boolean | null | undefined | MilkLogDefaultArgs> = $Result.GetResult<Prisma.$MilkLogPayload, S>

  type MilkLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MilkLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MilkLogCountAggregateInputType | true
    }

  export interface MilkLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MilkLog'], meta: { name: 'MilkLog' } }
    /**
     * Find zero or one MilkLog that matches the filter.
     * @param {MilkLogFindUniqueArgs} args - Arguments to find a MilkLog
     * @example
     * // Get one MilkLog
     * const milkLog = await prisma.milkLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MilkLogFindUniqueArgs>(args: SelectSubset<T, MilkLogFindUniqueArgs<ExtArgs>>): Prisma__MilkLogClient<$Result.GetResult<Prisma.$MilkLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MilkLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MilkLogFindUniqueOrThrowArgs} args - Arguments to find a MilkLog
     * @example
     * // Get one MilkLog
     * const milkLog = await prisma.milkLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MilkLogFindUniqueOrThrowArgs>(args: SelectSubset<T, MilkLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MilkLogClient<$Result.GetResult<Prisma.$MilkLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MilkLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilkLogFindFirstArgs} args - Arguments to find a MilkLog
     * @example
     * // Get one MilkLog
     * const milkLog = await prisma.milkLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MilkLogFindFirstArgs>(args?: SelectSubset<T, MilkLogFindFirstArgs<ExtArgs>>): Prisma__MilkLogClient<$Result.GetResult<Prisma.$MilkLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MilkLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilkLogFindFirstOrThrowArgs} args - Arguments to find a MilkLog
     * @example
     * // Get one MilkLog
     * const milkLog = await prisma.milkLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MilkLogFindFirstOrThrowArgs>(args?: SelectSubset<T, MilkLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__MilkLogClient<$Result.GetResult<Prisma.$MilkLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MilkLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilkLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MilkLogs
     * const milkLogs = await prisma.milkLog.findMany()
     * 
     * // Get first 10 MilkLogs
     * const milkLogs = await prisma.milkLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const milkLogWithIdOnly = await prisma.milkLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MilkLogFindManyArgs>(args?: SelectSubset<T, MilkLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilkLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MilkLog.
     * @param {MilkLogCreateArgs} args - Arguments to create a MilkLog.
     * @example
     * // Create one MilkLog
     * const MilkLog = await prisma.milkLog.create({
     *   data: {
     *     // ... data to create a MilkLog
     *   }
     * })
     * 
     */
    create<T extends MilkLogCreateArgs>(args: SelectSubset<T, MilkLogCreateArgs<ExtArgs>>): Prisma__MilkLogClient<$Result.GetResult<Prisma.$MilkLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MilkLogs.
     * @param {MilkLogCreateManyArgs} args - Arguments to create many MilkLogs.
     * @example
     * // Create many MilkLogs
     * const milkLog = await prisma.milkLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MilkLogCreateManyArgs>(args?: SelectSubset<T, MilkLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MilkLogs and returns the data saved in the database.
     * @param {MilkLogCreateManyAndReturnArgs} args - Arguments to create many MilkLogs.
     * @example
     * // Create many MilkLogs
     * const milkLog = await prisma.milkLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MilkLogs and only return the `id`
     * const milkLogWithIdOnly = await prisma.milkLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MilkLogCreateManyAndReturnArgs>(args?: SelectSubset<T, MilkLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilkLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MilkLog.
     * @param {MilkLogDeleteArgs} args - Arguments to delete one MilkLog.
     * @example
     * // Delete one MilkLog
     * const MilkLog = await prisma.milkLog.delete({
     *   where: {
     *     // ... filter to delete one MilkLog
     *   }
     * })
     * 
     */
    delete<T extends MilkLogDeleteArgs>(args: SelectSubset<T, MilkLogDeleteArgs<ExtArgs>>): Prisma__MilkLogClient<$Result.GetResult<Prisma.$MilkLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MilkLog.
     * @param {MilkLogUpdateArgs} args - Arguments to update one MilkLog.
     * @example
     * // Update one MilkLog
     * const milkLog = await prisma.milkLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MilkLogUpdateArgs>(args: SelectSubset<T, MilkLogUpdateArgs<ExtArgs>>): Prisma__MilkLogClient<$Result.GetResult<Prisma.$MilkLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MilkLogs.
     * @param {MilkLogDeleteManyArgs} args - Arguments to filter MilkLogs to delete.
     * @example
     * // Delete a few MilkLogs
     * const { count } = await prisma.milkLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MilkLogDeleteManyArgs>(args?: SelectSubset<T, MilkLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MilkLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilkLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MilkLogs
     * const milkLog = await prisma.milkLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MilkLogUpdateManyArgs>(args: SelectSubset<T, MilkLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MilkLogs and returns the data updated in the database.
     * @param {MilkLogUpdateManyAndReturnArgs} args - Arguments to update many MilkLogs.
     * @example
     * // Update many MilkLogs
     * const milkLog = await prisma.milkLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MilkLogs and only return the `id`
     * const milkLogWithIdOnly = await prisma.milkLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MilkLogUpdateManyAndReturnArgs>(args: SelectSubset<T, MilkLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilkLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MilkLog.
     * @param {MilkLogUpsertArgs} args - Arguments to update or create a MilkLog.
     * @example
     * // Update or create a MilkLog
     * const milkLog = await prisma.milkLog.upsert({
     *   create: {
     *     // ... data to create a MilkLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MilkLog we want to update
     *   }
     * })
     */
    upsert<T extends MilkLogUpsertArgs>(args: SelectSubset<T, MilkLogUpsertArgs<ExtArgs>>): Prisma__MilkLogClient<$Result.GetResult<Prisma.$MilkLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MilkLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilkLogCountArgs} args - Arguments to filter MilkLogs to count.
     * @example
     * // Count the number of MilkLogs
     * const count = await prisma.milkLog.count({
     *   where: {
     *     // ... the filter for the MilkLogs we want to count
     *   }
     * })
    **/
    count<T extends MilkLogCountArgs>(
      args?: Subset<T, MilkLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MilkLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MilkLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilkLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MilkLogAggregateArgs>(args: Subset<T, MilkLogAggregateArgs>): Prisma.PrismaPromise<GetMilkLogAggregateType<T>>

    /**
     * Group by MilkLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilkLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MilkLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MilkLogGroupByArgs['orderBy'] }
        : { orderBy?: MilkLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MilkLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMilkLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MilkLog model
   */
  readonly fields: MilkLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MilkLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MilkLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    livestock<T extends LivestockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LivestockDefaultArgs<ExtArgs>>): Prisma__LivestockClient<$Result.GetResult<Prisma.$LivestockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MilkLog model
   */
  interface MilkLogFieldRefs {
    readonly id: FieldRef<"MilkLog", 'String'>
    readonly livestockId: FieldRef<"MilkLog", 'String'>
    readonly measuredAt: FieldRef<"MilkLog", 'DateTime'>
    readonly quantityL: FieldRef<"MilkLog", 'Float'>
    readonly fatPercent: FieldRef<"MilkLog", 'Float'>
    readonly createdAt: FieldRef<"MilkLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MilkLog findUnique
   */
  export type MilkLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilkLog
     */
    select?: MilkLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MilkLog
     */
    omit?: MilkLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilkLogInclude<ExtArgs> | null
    /**
     * Filter, which MilkLog to fetch.
     */
    where: MilkLogWhereUniqueInput
  }

  /**
   * MilkLog findUniqueOrThrow
   */
  export type MilkLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilkLog
     */
    select?: MilkLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MilkLog
     */
    omit?: MilkLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilkLogInclude<ExtArgs> | null
    /**
     * Filter, which MilkLog to fetch.
     */
    where: MilkLogWhereUniqueInput
  }

  /**
   * MilkLog findFirst
   */
  export type MilkLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilkLog
     */
    select?: MilkLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MilkLog
     */
    omit?: MilkLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilkLogInclude<ExtArgs> | null
    /**
     * Filter, which MilkLog to fetch.
     */
    where?: MilkLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MilkLogs to fetch.
     */
    orderBy?: MilkLogOrderByWithRelationInput | MilkLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MilkLogs.
     */
    cursor?: MilkLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MilkLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MilkLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MilkLogs.
     */
    distinct?: MilkLogScalarFieldEnum | MilkLogScalarFieldEnum[]
  }

  /**
   * MilkLog findFirstOrThrow
   */
  export type MilkLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilkLog
     */
    select?: MilkLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MilkLog
     */
    omit?: MilkLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilkLogInclude<ExtArgs> | null
    /**
     * Filter, which MilkLog to fetch.
     */
    where?: MilkLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MilkLogs to fetch.
     */
    orderBy?: MilkLogOrderByWithRelationInput | MilkLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MilkLogs.
     */
    cursor?: MilkLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MilkLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MilkLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MilkLogs.
     */
    distinct?: MilkLogScalarFieldEnum | MilkLogScalarFieldEnum[]
  }

  /**
   * MilkLog findMany
   */
  export type MilkLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilkLog
     */
    select?: MilkLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MilkLog
     */
    omit?: MilkLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilkLogInclude<ExtArgs> | null
    /**
     * Filter, which MilkLogs to fetch.
     */
    where?: MilkLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MilkLogs to fetch.
     */
    orderBy?: MilkLogOrderByWithRelationInput | MilkLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MilkLogs.
     */
    cursor?: MilkLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MilkLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MilkLogs.
     */
    skip?: number
    distinct?: MilkLogScalarFieldEnum | MilkLogScalarFieldEnum[]
  }

  /**
   * MilkLog create
   */
  export type MilkLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilkLog
     */
    select?: MilkLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MilkLog
     */
    omit?: MilkLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilkLogInclude<ExtArgs> | null
    /**
     * The data needed to create a MilkLog.
     */
    data: XOR<MilkLogCreateInput, MilkLogUncheckedCreateInput>
  }

  /**
   * MilkLog createMany
   */
  export type MilkLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MilkLogs.
     */
    data: MilkLogCreateManyInput | MilkLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MilkLog createManyAndReturn
   */
  export type MilkLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilkLog
     */
    select?: MilkLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MilkLog
     */
    omit?: MilkLogOmit<ExtArgs> | null
    /**
     * The data used to create many MilkLogs.
     */
    data: MilkLogCreateManyInput | MilkLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilkLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MilkLog update
   */
  export type MilkLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilkLog
     */
    select?: MilkLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MilkLog
     */
    omit?: MilkLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilkLogInclude<ExtArgs> | null
    /**
     * The data needed to update a MilkLog.
     */
    data: XOR<MilkLogUpdateInput, MilkLogUncheckedUpdateInput>
    /**
     * Choose, which MilkLog to update.
     */
    where: MilkLogWhereUniqueInput
  }

  /**
   * MilkLog updateMany
   */
  export type MilkLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MilkLogs.
     */
    data: XOR<MilkLogUpdateManyMutationInput, MilkLogUncheckedUpdateManyInput>
    /**
     * Filter which MilkLogs to update
     */
    where?: MilkLogWhereInput
    /**
     * Limit how many MilkLogs to update.
     */
    limit?: number
  }

  /**
   * MilkLog updateManyAndReturn
   */
  export type MilkLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilkLog
     */
    select?: MilkLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MilkLog
     */
    omit?: MilkLogOmit<ExtArgs> | null
    /**
     * The data used to update MilkLogs.
     */
    data: XOR<MilkLogUpdateManyMutationInput, MilkLogUncheckedUpdateManyInput>
    /**
     * Filter which MilkLogs to update
     */
    where?: MilkLogWhereInput
    /**
     * Limit how many MilkLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilkLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MilkLog upsert
   */
  export type MilkLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilkLog
     */
    select?: MilkLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MilkLog
     */
    omit?: MilkLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilkLogInclude<ExtArgs> | null
    /**
     * The filter to search for the MilkLog to update in case it exists.
     */
    where: MilkLogWhereUniqueInput
    /**
     * In case the MilkLog found by the `where` argument doesn't exist, create a new MilkLog with this data.
     */
    create: XOR<MilkLogCreateInput, MilkLogUncheckedCreateInput>
    /**
     * In case the MilkLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MilkLogUpdateInput, MilkLogUncheckedUpdateInput>
  }

  /**
   * MilkLog delete
   */
  export type MilkLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilkLog
     */
    select?: MilkLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MilkLog
     */
    omit?: MilkLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilkLogInclude<ExtArgs> | null
    /**
     * Filter which MilkLog to delete.
     */
    where: MilkLogWhereUniqueInput
  }

  /**
   * MilkLog deleteMany
   */
  export type MilkLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MilkLogs to delete
     */
    where?: MilkLogWhereInput
    /**
     * Limit how many MilkLogs to delete.
     */
    limit?: number
  }

  /**
   * MilkLog without action
   */
  export type MilkLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilkLog
     */
    select?: MilkLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MilkLog
     */
    omit?: MilkLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilkLogInclude<ExtArgs> | null
  }


  /**
   * Model EggLog
   */

  export type AggregateEggLog = {
    _count: EggLogCountAggregateOutputType | null
    _avg: EggLogAvgAggregateOutputType | null
    _sum: EggLogSumAggregateOutputType | null
    _min: EggLogMinAggregateOutputType | null
    _max: EggLogMaxAggregateOutputType | null
  }

  export type EggLogAvgAggregateOutputType = {
    eggCount: number | null
    avgWeightGram: number | null
  }

  export type EggLogSumAggregateOutputType = {
    eggCount: number | null
    avgWeightGram: number | null
  }

  export type EggLogMinAggregateOutputType = {
    id: string | null
    livestockId: string | null
    measuredAt: Date | null
    eggCount: number | null
    avgWeightGram: number | null
    createdAt: Date | null
  }

  export type EggLogMaxAggregateOutputType = {
    id: string | null
    livestockId: string | null
    measuredAt: Date | null
    eggCount: number | null
    avgWeightGram: number | null
    createdAt: Date | null
  }

  export type EggLogCountAggregateOutputType = {
    id: number
    livestockId: number
    measuredAt: number
    eggCount: number
    avgWeightGram: number
    createdAt: number
    _all: number
  }


  export type EggLogAvgAggregateInputType = {
    eggCount?: true
    avgWeightGram?: true
  }

  export type EggLogSumAggregateInputType = {
    eggCount?: true
    avgWeightGram?: true
  }

  export type EggLogMinAggregateInputType = {
    id?: true
    livestockId?: true
    measuredAt?: true
    eggCount?: true
    avgWeightGram?: true
    createdAt?: true
  }

  export type EggLogMaxAggregateInputType = {
    id?: true
    livestockId?: true
    measuredAt?: true
    eggCount?: true
    avgWeightGram?: true
    createdAt?: true
  }

  export type EggLogCountAggregateInputType = {
    id?: true
    livestockId?: true
    measuredAt?: true
    eggCount?: true
    avgWeightGram?: true
    createdAt?: true
    _all?: true
  }

  export type EggLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EggLog to aggregate.
     */
    where?: EggLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EggLogs to fetch.
     */
    orderBy?: EggLogOrderByWithRelationInput | EggLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EggLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EggLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EggLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EggLogs
    **/
    _count?: true | EggLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EggLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EggLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EggLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EggLogMaxAggregateInputType
  }

  export type GetEggLogAggregateType<T extends EggLogAggregateArgs> = {
        [P in keyof T & keyof AggregateEggLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEggLog[P]>
      : GetScalarType<T[P], AggregateEggLog[P]>
  }




  export type EggLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EggLogWhereInput
    orderBy?: EggLogOrderByWithAggregationInput | EggLogOrderByWithAggregationInput[]
    by: EggLogScalarFieldEnum[] | EggLogScalarFieldEnum
    having?: EggLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EggLogCountAggregateInputType | true
    _avg?: EggLogAvgAggregateInputType
    _sum?: EggLogSumAggregateInputType
    _min?: EggLogMinAggregateInputType
    _max?: EggLogMaxAggregateInputType
  }

  export type EggLogGroupByOutputType = {
    id: string
    livestockId: string
    measuredAt: Date
    eggCount: number
    avgWeightGram: number | null
    createdAt: Date
    _count: EggLogCountAggregateOutputType | null
    _avg: EggLogAvgAggregateOutputType | null
    _sum: EggLogSumAggregateOutputType | null
    _min: EggLogMinAggregateOutputType | null
    _max: EggLogMaxAggregateOutputType | null
  }

  type GetEggLogGroupByPayload<T extends EggLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EggLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EggLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EggLogGroupByOutputType[P]>
            : GetScalarType<T[P], EggLogGroupByOutputType[P]>
        }
      >
    >


  export type EggLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    livestockId?: boolean
    measuredAt?: boolean
    eggCount?: boolean
    avgWeightGram?: boolean
    createdAt?: boolean
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eggLog"]>

  export type EggLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    livestockId?: boolean
    measuredAt?: boolean
    eggCount?: boolean
    avgWeightGram?: boolean
    createdAt?: boolean
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eggLog"]>

  export type EggLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    livestockId?: boolean
    measuredAt?: boolean
    eggCount?: boolean
    avgWeightGram?: boolean
    createdAt?: boolean
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eggLog"]>

  export type EggLogSelectScalar = {
    id?: boolean
    livestockId?: boolean
    measuredAt?: boolean
    eggCount?: boolean
    avgWeightGram?: boolean
    createdAt?: boolean
  }

  export type EggLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "livestockId" | "measuredAt" | "eggCount" | "avgWeightGram" | "createdAt", ExtArgs["result"]["eggLog"]>
  export type EggLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }
  export type EggLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }
  export type EggLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }

  export type $EggLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EggLog"
    objects: {
      livestock: Prisma.$LivestockPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      livestockId: string
      measuredAt: Date
      eggCount: number
      avgWeightGram: number | null
      createdAt: Date
    }, ExtArgs["result"]["eggLog"]>
    composites: {}
  }

  type EggLogGetPayload<S extends boolean | null | undefined | EggLogDefaultArgs> = $Result.GetResult<Prisma.$EggLogPayload, S>

  type EggLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EggLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EggLogCountAggregateInputType | true
    }

  export interface EggLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EggLog'], meta: { name: 'EggLog' } }
    /**
     * Find zero or one EggLog that matches the filter.
     * @param {EggLogFindUniqueArgs} args - Arguments to find a EggLog
     * @example
     * // Get one EggLog
     * const eggLog = await prisma.eggLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EggLogFindUniqueArgs>(args: SelectSubset<T, EggLogFindUniqueArgs<ExtArgs>>): Prisma__EggLogClient<$Result.GetResult<Prisma.$EggLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EggLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EggLogFindUniqueOrThrowArgs} args - Arguments to find a EggLog
     * @example
     * // Get one EggLog
     * const eggLog = await prisma.eggLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EggLogFindUniqueOrThrowArgs>(args: SelectSubset<T, EggLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EggLogClient<$Result.GetResult<Prisma.$EggLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EggLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EggLogFindFirstArgs} args - Arguments to find a EggLog
     * @example
     * // Get one EggLog
     * const eggLog = await prisma.eggLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EggLogFindFirstArgs>(args?: SelectSubset<T, EggLogFindFirstArgs<ExtArgs>>): Prisma__EggLogClient<$Result.GetResult<Prisma.$EggLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EggLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EggLogFindFirstOrThrowArgs} args - Arguments to find a EggLog
     * @example
     * // Get one EggLog
     * const eggLog = await prisma.eggLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EggLogFindFirstOrThrowArgs>(args?: SelectSubset<T, EggLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__EggLogClient<$Result.GetResult<Prisma.$EggLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EggLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EggLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EggLogs
     * const eggLogs = await prisma.eggLog.findMany()
     * 
     * // Get first 10 EggLogs
     * const eggLogs = await prisma.eggLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eggLogWithIdOnly = await prisma.eggLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EggLogFindManyArgs>(args?: SelectSubset<T, EggLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EggLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EggLog.
     * @param {EggLogCreateArgs} args - Arguments to create a EggLog.
     * @example
     * // Create one EggLog
     * const EggLog = await prisma.eggLog.create({
     *   data: {
     *     // ... data to create a EggLog
     *   }
     * })
     * 
     */
    create<T extends EggLogCreateArgs>(args: SelectSubset<T, EggLogCreateArgs<ExtArgs>>): Prisma__EggLogClient<$Result.GetResult<Prisma.$EggLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EggLogs.
     * @param {EggLogCreateManyArgs} args - Arguments to create many EggLogs.
     * @example
     * // Create many EggLogs
     * const eggLog = await prisma.eggLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EggLogCreateManyArgs>(args?: SelectSubset<T, EggLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EggLogs and returns the data saved in the database.
     * @param {EggLogCreateManyAndReturnArgs} args - Arguments to create many EggLogs.
     * @example
     * // Create many EggLogs
     * const eggLog = await prisma.eggLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EggLogs and only return the `id`
     * const eggLogWithIdOnly = await prisma.eggLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EggLogCreateManyAndReturnArgs>(args?: SelectSubset<T, EggLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EggLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EggLog.
     * @param {EggLogDeleteArgs} args - Arguments to delete one EggLog.
     * @example
     * // Delete one EggLog
     * const EggLog = await prisma.eggLog.delete({
     *   where: {
     *     // ... filter to delete one EggLog
     *   }
     * })
     * 
     */
    delete<T extends EggLogDeleteArgs>(args: SelectSubset<T, EggLogDeleteArgs<ExtArgs>>): Prisma__EggLogClient<$Result.GetResult<Prisma.$EggLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EggLog.
     * @param {EggLogUpdateArgs} args - Arguments to update one EggLog.
     * @example
     * // Update one EggLog
     * const eggLog = await prisma.eggLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EggLogUpdateArgs>(args: SelectSubset<T, EggLogUpdateArgs<ExtArgs>>): Prisma__EggLogClient<$Result.GetResult<Prisma.$EggLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EggLogs.
     * @param {EggLogDeleteManyArgs} args - Arguments to filter EggLogs to delete.
     * @example
     * // Delete a few EggLogs
     * const { count } = await prisma.eggLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EggLogDeleteManyArgs>(args?: SelectSubset<T, EggLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EggLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EggLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EggLogs
     * const eggLog = await prisma.eggLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EggLogUpdateManyArgs>(args: SelectSubset<T, EggLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EggLogs and returns the data updated in the database.
     * @param {EggLogUpdateManyAndReturnArgs} args - Arguments to update many EggLogs.
     * @example
     * // Update many EggLogs
     * const eggLog = await prisma.eggLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EggLogs and only return the `id`
     * const eggLogWithIdOnly = await prisma.eggLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EggLogUpdateManyAndReturnArgs>(args: SelectSubset<T, EggLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EggLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EggLog.
     * @param {EggLogUpsertArgs} args - Arguments to update or create a EggLog.
     * @example
     * // Update or create a EggLog
     * const eggLog = await prisma.eggLog.upsert({
     *   create: {
     *     // ... data to create a EggLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EggLog we want to update
     *   }
     * })
     */
    upsert<T extends EggLogUpsertArgs>(args: SelectSubset<T, EggLogUpsertArgs<ExtArgs>>): Prisma__EggLogClient<$Result.GetResult<Prisma.$EggLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EggLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EggLogCountArgs} args - Arguments to filter EggLogs to count.
     * @example
     * // Count the number of EggLogs
     * const count = await prisma.eggLog.count({
     *   where: {
     *     // ... the filter for the EggLogs we want to count
     *   }
     * })
    **/
    count<T extends EggLogCountArgs>(
      args?: Subset<T, EggLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EggLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EggLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EggLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EggLogAggregateArgs>(args: Subset<T, EggLogAggregateArgs>): Prisma.PrismaPromise<GetEggLogAggregateType<T>>

    /**
     * Group by EggLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EggLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EggLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EggLogGroupByArgs['orderBy'] }
        : { orderBy?: EggLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EggLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEggLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EggLog model
   */
  readonly fields: EggLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EggLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EggLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    livestock<T extends LivestockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LivestockDefaultArgs<ExtArgs>>): Prisma__LivestockClient<$Result.GetResult<Prisma.$LivestockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EggLog model
   */
  interface EggLogFieldRefs {
    readonly id: FieldRef<"EggLog", 'String'>
    readonly livestockId: FieldRef<"EggLog", 'String'>
    readonly measuredAt: FieldRef<"EggLog", 'DateTime'>
    readonly eggCount: FieldRef<"EggLog", 'Int'>
    readonly avgWeightGram: FieldRef<"EggLog", 'Float'>
    readonly createdAt: FieldRef<"EggLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EggLog findUnique
   */
  export type EggLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggLog
     */
    select?: EggLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggLog
     */
    omit?: EggLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggLogInclude<ExtArgs> | null
    /**
     * Filter, which EggLog to fetch.
     */
    where: EggLogWhereUniqueInput
  }

  /**
   * EggLog findUniqueOrThrow
   */
  export type EggLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggLog
     */
    select?: EggLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggLog
     */
    omit?: EggLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggLogInclude<ExtArgs> | null
    /**
     * Filter, which EggLog to fetch.
     */
    where: EggLogWhereUniqueInput
  }

  /**
   * EggLog findFirst
   */
  export type EggLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggLog
     */
    select?: EggLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggLog
     */
    omit?: EggLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggLogInclude<ExtArgs> | null
    /**
     * Filter, which EggLog to fetch.
     */
    where?: EggLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EggLogs to fetch.
     */
    orderBy?: EggLogOrderByWithRelationInput | EggLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EggLogs.
     */
    cursor?: EggLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EggLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EggLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EggLogs.
     */
    distinct?: EggLogScalarFieldEnum | EggLogScalarFieldEnum[]
  }

  /**
   * EggLog findFirstOrThrow
   */
  export type EggLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggLog
     */
    select?: EggLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggLog
     */
    omit?: EggLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggLogInclude<ExtArgs> | null
    /**
     * Filter, which EggLog to fetch.
     */
    where?: EggLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EggLogs to fetch.
     */
    orderBy?: EggLogOrderByWithRelationInput | EggLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EggLogs.
     */
    cursor?: EggLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EggLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EggLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EggLogs.
     */
    distinct?: EggLogScalarFieldEnum | EggLogScalarFieldEnum[]
  }

  /**
   * EggLog findMany
   */
  export type EggLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggLog
     */
    select?: EggLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggLog
     */
    omit?: EggLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggLogInclude<ExtArgs> | null
    /**
     * Filter, which EggLogs to fetch.
     */
    where?: EggLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EggLogs to fetch.
     */
    orderBy?: EggLogOrderByWithRelationInput | EggLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EggLogs.
     */
    cursor?: EggLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EggLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EggLogs.
     */
    skip?: number
    distinct?: EggLogScalarFieldEnum | EggLogScalarFieldEnum[]
  }

  /**
   * EggLog create
   */
  export type EggLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggLog
     */
    select?: EggLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggLog
     */
    omit?: EggLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggLogInclude<ExtArgs> | null
    /**
     * The data needed to create a EggLog.
     */
    data: XOR<EggLogCreateInput, EggLogUncheckedCreateInput>
  }

  /**
   * EggLog createMany
   */
  export type EggLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EggLogs.
     */
    data: EggLogCreateManyInput | EggLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EggLog createManyAndReturn
   */
  export type EggLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggLog
     */
    select?: EggLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EggLog
     */
    omit?: EggLogOmit<ExtArgs> | null
    /**
     * The data used to create many EggLogs.
     */
    data: EggLogCreateManyInput | EggLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EggLog update
   */
  export type EggLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggLog
     */
    select?: EggLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggLog
     */
    omit?: EggLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggLogInclude<ExtArgs> | null
    /**
     * The data needed to update a EggLog.
     */
    data: XOR<EggLogUpdateInput, EggLogUncheckedUpdateInput>
    /**
     * Choose, which EggLog to update.
     */
    where: EggLogWhereUniqueInput
  }

  /**
   * EggLog updateMany
   */
  export type EggLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EggLogs.
     */
    data: XOR<EggLogUpdateManyMutationInput, EggLogUncheckedUpdateManyInput>
    /**
     * Filter which EggLogs to update
     */
    where?: EggLogWhereInput
    /**
     * Limit how many EggLogs to update.
     */
    limit?: number
  }

  /**
   * EggLog updateManyAndReturn
   */
  export type EggLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggLog
     */
    select?: EggLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EggLog
     */
    omit?: EggLogOmit<ExtArgs> | null
    /**
     * The data used to update EggLogs.
     */
    data: XOR<EggLogUpdateManyMutationInput, EggLogUncheckedUpdateManyInput>
    /**
     * Filter which EggLogs to update
     */
    where?: EggLogWhereInput
    /**
     * Limit how many EggLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EggLog upsert
   */
  export type EggLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggLog
     */
    select?: EggLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggLog
     */
    omit?: EggLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggLogInclude<ExtArgs> | null
    /**
     * The filter to search for the EggLog to update in case it exists.
     */
    where: EggLogWhereUniqueInput
    /**
     * In case the EggLog found by the `where` argument doesn't exist, create a new EggLog with this data.
     */
    create: XOR<EggLogCreateInput, EggLogUncheckedCreateInput>
    /**
     * In case the EggLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EggLogUpdateInput, EggLogUncheckedUpdateInput>
  }

  /**
   * EggLog delete
   */
  export type EggLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggLog
     */
    select?: EggLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggLog
     */
    omit?: EggLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggLogInclude<ExtArgs> | null
    /**
     * Filter which EggLog to delete.
     */
    where: EggLogWhereUniqueInput
  }

  /**
   * EggLog deleteMany
   */
  export type EggLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EggLogs to delete
     */
    where?: EggLogWhereInput
    /**
     * Limit how many EggLogs to delete.
     */
    limit?: number
  }

  /**
   * EggLog without action
   */
  export type EggLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggLog
     */
    select?: EggLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggLog
     */
    omit?: EggLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggLogInclude<ExtArgs> | null
  }


  /**
   * Model HoneyLog
   */

  export type AggregateHoneyLog = {
    _count: HoneyLogCountAggregateOutputType | null
    _avg: HoneyLogAvgAggregateOutputType | null
    _sum: HoneyLogSumAggregateOutputType | null
    _min: HoneyLogMinAggregateOutputType | null
    _max: HoneyLogMaxAggregateOutputType | null
  }

  export type HoneyLogAvgAggregateOutputType = {
    amountKg: number | null
  }

  export type HoneyLogSumAggregateOutputType = {
    amountKg: number | null
  }

  export type HoneyLogMinAggregateOutputType = {
    id: string | null
    livestockId: string | null
    measuredAt: Date | null
    amountKg: number | null
    qualityGrade: string | null
    createdAt: Date | null
  }

  export type HoneyLogMaxAggregateOutputType = {
    id: string | null
    livestockId: string | null
    measuredAt: Date | null
    amountKg: number | null
    qualityGrade: string | null
    createdAt: Date | null
  }

  export type HoneyLogCountAggregateOutputType = {
    id: number
    livestockId: number
    measuredAt: number
    amountKg: number
    qualityGrade: number
    createdAt: number
    _all: number
  }


  export type HoneyLogAvgAggregateInputType = {
    amountKg?: true
  }

  export type HoneyLogSumAggregateInputType = {
    amountKg?: true
  }

  export type HoneyLogMinAggregateInputType = {
    id?: true
    livestockId?: true
    measuredAt?: true
    amountKg?: true
    qualityGrade?: true
    createdAt?: true
  }

  export type HoneyLogMaxAggregateInputType = {
    id?: true
    livestockId?: true
    measuredAt?: true
    amountKg?: true
    qualityGrade?: true
    createdAt?: true
  }

  export type HoneyLogCountAggregateInputType = {
    id?: true
    livestockId?: true
    measuredAt?: true
    amountKg?: true
    qualityGrade?: true
    createdAt?: true
    _all?: true
  }

  export type HoneyLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HoneyLog to aggregate.
     */
    where?: HoneyLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HoneyLogs to fetch.
     */
    orderBy?: HoneyLogOrderByWithRelationInput | HoneyLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HoneyLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HoneyLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HoneyLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HoneyLogs
    **/
    _count?: true | HoneyLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HoneyLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HoneyLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HoneyLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HoneyLogMaxAggregateInputType
  }

  export type GetHoneyLogAggregateType<T extends HoneyLogAggregateArgs> = {
        [P in keyof T & keyof AggregateHoneyLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHoneyLog[P]>
      : GetScalarType<T[P], AggregateHoneyLog[P]>
  }




  export type HoneyLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HoneyLogWhereInput
    orderBy?: HoneyLogOrderByWithAggregationInput | HoneyLogOrderByWithAggregationInput[]
    by: HoneyLogScalarFieldEnum[] | HoneyLogScalarFieldEnum
    having?: HoneyLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HoneyLogCountAggregateInputType | true
    _avg?: HoneyLogAvgAggregateInputType
    _sum?: HoneyLogSumAggregateInputType
    _min?: HoneyLogMinAggregateInputType
    _max?: HoneyLogMaxAggregateInputType
  }

  export type HoneyLogGroupByOutputType = {
    id: string
    livestockId: string
    measuredAt: Date
    amountKg: number
    qualityGrade: string | null
    createdAt: Date
    _count: HoneyLogCountAggregateOutputType | null
    _avg: HoneyLogAvgAggregateOutputType | null
    _sum: HoneyLogSumAggregateOutputType | null
    _min: HoneyLogMinAggregateOutputType | null
    _max: HoneyLogMaxAggregateOutputType | null
  }

  type GetHoneyLogGroupByPayload<T extends HoneyLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HoneyLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HoneyLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HoneyLogGroupByOutputType[P]>
            : GetScalarType<T[P], HoneyLogGroupByOutputType[P]>
        }
      >
    >


  export type HoneyLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    livestockId?: boolean
    measuredAt?: boolean
    amountKg?: boolean
    qualityGrade?: boolean
    createdAt?: boolean
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["honeyLog"]>

  export type HoneyLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    livestockId?: boolean
    measuredAt?: boolean
    amountKg?: boolean
    qualityGrade?: boolean
    createdAt?: boolean
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["honeyLog"]>

  export type HoneyLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    livestockId?: boolean
    measuredAt?: boolean
    amountKg?: boolean
    qualityGrade?: boolean
    createdAt?: boolean
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["honeyLog"]>

  export type HoneyLogSelectScalar = {
    id?: boolean
    livestockId?: boolean
    measuredAt?: boolean
    amountKg?: boolean
    qualityGrade?: boolean
    createdAt?: boolean
  }

  export type HoneyLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "livestockId" | "measuredAt" | "amountKg" | "qualityGrade" | "createdAt", ExtArgs["result"]["honeyLog"]>
  export type HoneyLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }
  export type HoneyLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }
  export type HoneyLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }

  export type $HoneyLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HoneyLog"
    objects: {
      livestock: Prisma.$LivestockPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      livestockId: string
      measuredAt: Date
      amountKg: number
      qualityGrade: string | null
      createdAt: Date
    }, ExtArgs["result"]["honeyLog"]>
    composites: {}
  }

  type HoneyLogGetPayload<S extends boolean | null | undefined | HoneyLogDefaultArgs> = $Result.GetResult<Prisma.$HoneyLogPayload, S>

  type HoneyLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HoneyLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HoneyLogCountAggregateInputType | true
    }

  export interface HoneyLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HoneyLog'], meta: { name: 'HoneyLog' } }
    /**
     * Find zero or one HoneyLog that matches the filter.
     * @param {HoneyLogFindUniqueArgs} args - Arguments to find a HoneyLog
     * @example
     * // Get one HoneyLog
     * const honeyLog = await prisma.honeyLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HoneyLogFindUniqueArgs>(args: SelectSubset<T, HoneyLogFindUniqueArgs<ExtArgs>>): Prisma__HoneyLogClient<$Result.GetResult<Prisma.$HoneyLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HoneyLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HoneyLogFindUniqueOrThrowArgs} args - Arguments to find a HoneyLog
     * @example
     * // Get one HoneyLog
     * const honeyLog = await prisma.honeyLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HoneyLogFindUniqueOrThrowArgs>(args: SelectSubset<T, HoneyLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HoneyLogClient<$Result.GetResult<Prisma.$HoneyLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HoneyLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoneyLogFindFirstArgs} args - Arguments to find a HoneyLog
     * @example
     * // Get one HoneyLog
     * const honeyLog = await prisma.honeyLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HoneyLogFindFirstArgs>(args?: SelectSubset<T, HoneyLogFindFirstArgs<ExtArgs>>): Prisma__HoneyLogClient<$Result.GetResult<Prisma.$HoneyLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HoneyLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoneyLogFindFirstOrThrowArgs} args - Arguments to find a HoneyLog
     * @example
     * // Get one HoneyLog
     * const honeyLog = await prisma.honeyLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HoneyLogFindFirstOrThrowArgs>(args?: SelectSubset<T, HoneyLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__HoneyLogClient<$Result.GetResult<Prisma.$HoneyLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HoneyLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoneyLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HoneyLogs
     * const honeyLogs = await prisma.honeyLog.findMany()
     * 
     * // Get first 10 HoneyLogs
     * const honeyLogs = await prisma.honeyLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const honeyLogWithIdOnly = await prisma.honeyLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HoneyLogFindManyArgs>(args?: SelectSubset<T, HoneyLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoneyLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HoneyLog.
     * @param {HoneyLogCreateArgs} args - Arguments to create a HoneyLog.
     * @example
     * // Create one HoneyLog
     * const HoneyLog = await prisma.honeyLog.create({
     *   data: {
     *     // ... data to create a HoneyLog
     *   }
     * })
     * 
     */
    create<T extends HoneyLogCreateArgs>(args: SelectSubset<T, HoneyLogCreateArgs<ExtArgs>>): Prisma__HoneyLogClient<$Result.GetResult<Prisma.$HoneyLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HoneyLogs.
     * @param {HoneyLogCreateManyArgs} args - Arguments to create many HoneyLogs.
     * @example
     * // Create many HoneyLogs
     * const honeyLog = await prisma.honeyLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HoneyLogCreateManyArgs>(args?: SelectSubset<T, HoneyLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HoneyLogs and returns the data saved in the database.
     * @param {HoneyLogCreateManyAndReturnArgs} args - Arguments to create many HoneyLogs.
     * @example
     * // Create many HoneyLogs
     * const honeyLog = await prisma.honeyLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HoneyLogs and only return the `id`
     * const honeyLogWithIdOnly = await prisma.honeyLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HoneyLogCreateManyAndReturnArgs>(args?: SelectSubset<T, HoneyLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoneyLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HoneyLog.
     * @param {HoneyLogDeleteArgs} args - Arguments to delete one HoneyLog.
     * @example
     * // Delete one HoneyLog
     * const HoneyLog = await prisma.honeyLog.delete({
     *   where: {
     *     // ... filter to delete one HoneyLog
     *   }
     * })
     * 
     */
    delete<T extends HoneyLogDeleteArgs>(args: SelectSubset<T, HoneyLogDeleteArgs<ExtArgs>>): Prisma__HoneyLogClient<$Result.GetResult<Prisma.$HoneyLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HoneyLog.
     * @param {HoneyLogUpdateArgs} args - Arguments to update one HoneyLog.
     * @example
     * // Update one HoneyLog
     * const honeyLog = await prisma.honeyLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HoneyLogUpdateArgs>(args: SelectSubset<T, HoneyLogUpdateArgs<ExtArgs>>): Prisma__HoneyLogClient<$Result.GetResult<Prisma.$HoneyLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HoneyLogs.
     * @param {HoneyLogDeleteManyArgs} args - Arguments to filter HoneyLogs to delete.
     * @example
     * // Delete a few HoneyLogs
     * const { count } = await prisma.honeyLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HoneyLogDeleteManyArgs>(args?: SelectSubset<T, HoneyLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HoneyLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoneyLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HoneyLogs
     * const honeyLog = await prisma.honeyLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HoneyLogUpdateManyArgs>(args: SelectSubset<T, HoneyLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HoneyLogs and returns the data updated in the database.
     * @param {HoneyLogUpdateManyAndReturnArgs} args - Arguments to update many HoneyLogs.
     * @example
     * // Update many HoneyLogs
     * const honeyLog = await prisma.honeyLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HoneyLogs and only return the `id`
     * const honeyLogWithIdOnly = await prisma.honeyLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HoneyLogUpdateManyAndReturnArgs>(args: SelectSubset<T, HoneyLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoneyLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HoneyLog.
     * @param {HoneyLogUpsertArgs} args - Arguments to update or create a HoneyLog.
     * @example
     * // Update or create a HoneyLog
     * const honeyLog = await prisma.honeyLog.upsert({
     *   create: {
     *     // ... data to create a HoneyLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HoneyLog we want to update
     *   }
     * })
     */
    upsert<T extends HoneyLogUpsertArgs>(args: SelectSubset<T, HoneyLogUpsertArgs<ExtArgs>>): Prisma__HoneyLogClient<$Result.GetResult<Prisma.$HoneyLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HoneyLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoneyLogCountArgs} args - Arguments to filter HoneyLogs to count.
     * @example
     * // Count the number of HoneyLogs
     * const count = await prisma.honeyLog.count({
     *   where: {
     *     // ... the filter for the HoneyLogs we want to count
     *   }
     * })
    **/
    count<T extends HoneyLogCountArgs>(
      args?: Subset<T, HoneyLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HoneyLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HoneyLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoneyLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HoneyLogAggregateArgs>(args: Subset<T, HoneyLogAggregateArgs>): Prisma.PrismaPromise<GetHoneyLogAggregateType<T>>

    /**
     * Group by HoneyLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoneyLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HoneyLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HoneyLogGroupByArgs['orderBy'] }
        : { orderBy?: HoneyLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HoneyLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHoneyLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HoneyLog model
   */
  readonly fields: HoneyLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HoneyLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HoneyLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    livestock<T extends LivestockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LivestockDefaultArgs<ExtArgs>>): Prisma__LivestockClient<$Result.GetResult<Prisma.$LivestockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HoneyLog model
   */
  interface HoneyLogFieldRefs {
    readonly id: FieldRef<"HoneyLog", 'String'>
    readonly livestockId: FieldRef<"HoneyLog", 'String'>
    readonly measuredAt: FieldRef<"HoneyLog", 'DateTime'>
    readonly amountKg: FieldRef<"HoneyLog", 'Float'>
    readonly qualityGrade: FieldRef<"HoneyLog", 'String'>
    readonly createdAt: FieldRef<"HoneyLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HoneyLog findUnique
   */
  export type HoneyLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoneyLog
     */
    select?: HoneyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HoneyLog
     */
    omit?: HoneyLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoneyLogInclude<ExtArgs> | null
    /**
     * Filter, which HoneyLog to fetch.
     */
    where: HoneyLogWhereUniqueInput
  }

  /**
   * HoneyLog findUniqueOrThrow
   */
  export type HoneyLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoneyLog
     */
    select?: HoneyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HoneyLog
     */
    omit?: HoneyLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoneyLogInclude<ExtArgs> | null
    /**
     * Filter, which HoneyLog to fetch.
     */
    where: HoneyLogWhereUniqueInput
  }

  /**
   * HoneyLog findFirst
   */
  export type HoneyLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoneyLog
     */
    select?: HoneyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HoneyLog
     */
    omit?: HoneyLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoneyLogInclude<ExtArgs> | null
    /**
     * Filter, which HoneyLog to fetch.
     */
    where?: HoneyLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HoneyLogs to fetch.
     */
    orderBy?: HoneyLogOrderByWithRelationInput | HoneyLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HoneyLogs.
     */
    cursor?: HoneyLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HoneyLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HoneyLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HoneyLogs.
     */
    distinct?: HoneyLogScalarFieldEnum | HoneyLogScalarFieldEnum[]
  }

  /**
   * HoneyLog findFirstOrThrow
   */
  export type HoneyLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoneyLog
     */
    select?: HoneyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HoneyLog
     */
    omit?: HoneyLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoneyLogInclude<ExtArgs> | null
    /**
     * Filter, which HoneyLog to fetch.
     */
    where?: HoneyLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HoneyLogs to fetch.
     */
    orderBy?: HoneyLogOrderByWithRelationInput | HoneyLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HoneyLogs.
     */
    cursor?: HoneyLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HoneyLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HoneyLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HoneyLogs.
     */
    distinct?: HoneyLogScalarFieldEnum | HoneyLogScalarFieldEnum[]
  }

  /**
   * HoneyLog findMany
   */
  export type HoneyLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoneyLog
     */
    select?: HoneyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HoneyLog
     */
    omit?: HoneyLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoneyLogInclude<ExtArgs> | null
    /**
     * Filter, which HoneyLogs to fetch.
     */
    where?: HoneyLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HoneyLogs to fetch.
     */
    orderBy?: HoneyLogOrderByWithRelationInput | HoneyLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HoneyLogs.
     */
    cursor?: HoneyLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HoneyLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HoneyLogs.
     */
    skip?: number
    distinct?: HoneyLogScalarFieldEnum | HoneyLogScalarFieldEnum[]
  }

  /**
   * HoneyLog create
   */
  export type HoneyLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoneyLog
     */
    select?: HoneyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HoneyLog
     */
    omit?: HoneyLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoneyLogInclude<ExtArgs> | null
    /**
     * The data needed to create a HoneyLog.
     */
    data: XOR<HoneyLogCreateInput, HoneyLogUncheckedCreateInput>
  }

  /**
   * HoneyLog createMany
   */
  export type HoneyLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HoneyLogs.
     */
    data: HoneyLogCreateManyInput | HoneyLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HoneyLog createManyAndReturn
   */
  export type HoneyLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoneyLog
     */
    select?: HoneyLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HoneyLog
     */
    omit?: HoneyLogOmit<ExtArgs> | null
    /**
     * The data used to create many HoneyLogs.
     */
    data: HoneyLogCreateManyInput | HoneyLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoneyLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HoneyLog update
   */
  export type HoneyLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoneyLog
     */
    select?: HoneyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HoneyLog
     */
    omit?: HoneyLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoneyLogInclude<ExtArgs> | null
    /**
     * The data needed to update a HoneyLog.
     */
    data: XOR<HoneyLogUpdateInput, HoneyLogUncheckedUpdateInput>
    /**
     * Choose, which HoneyLog to update.
     */
    where: HoneyLogWhereUniqueInput
  }

  /**
   * HoneyLog updateMany
   */
  export type HoneyLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HoneyLogs.
     */
    data: XOR<HoneyLogUpdateManyMutationInput, HoneyLogUncheckedUpdateManyInput>
    /**
     * Filter which HoneyLogs to update
     */
    where?: HoneyLogWhereInput
    /**
     * Limit how many HoneyLogs to update.
     */
    limit?: number
  }

  /**
   * HoneyLog updateManyAndReturn
   */
  export type HoneyLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoneyLog
     */
    select?: HoneyLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HoneyLog
     */
    omit?: HoneyLogOmit<ExtArgs> | null
    /**
     * The data used to update HoneyLogs.
     */
    data: XOR<HoneyLogUpdateManyMutationInput, HoneyLogUncheckedUpdateManyInput>
    /**
     * Filter which HoneyLogs to update
     */
    where?: HoneyLogWhereInput
    /**
     * Limit how many HoneyLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoneyLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HoneyLog upsert
   */
  export type HoneyLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoneyLog
     */
    select?: HoneyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HoneyLog
     */
    omit?: HoneyLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoneyLogInclude<ExtArgs> | null
    /**
     * The filter to search for the HoneyLog to update in case it exists.
     */
    where: HoneyLogWhereUniqueInput
    /**
     * In case the HoneyLog found by the `where` argument doesn't exist, create a new HoneyLog with this data.
     */
    create: XOR<HoneyLogCreateInput, HoneyLogUncheckedCreateInput>
    /**
     * In case the HoneyLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HoneyLogUpdateInput, HoneyLogUncheckedUpdateInput>
  }

  /**
   * HoneyLog delete
   */
  export type HoneyLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoneyLog
     */
    select?: HoneyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HoneyLog
     */
    omit?: HoneyLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoneyLogInclude<ExtArgs> | null
    /**
     * Filter which HoneyLog to delete.
     */
    where: HoneyLogWhereUniqueInput
  }

  /**
   * HoneyLog deleteMany
   */
  export type HoneyLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HoneyLogs to delete
     */
    where?: HoneyLogWhereInput
    /**
     * Limit how many HoneyLogs to delete.
     */
    limit?: number
  }

  /**
   * HoneyLog without action
   */
  export type HoneyLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoneyLog
     */
    select?: HoneyLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HoneyLog
     */
    omit?: HoneyLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoneyLogInclude<ExtArgs> | null
  }


  /**
   * Model WoolLog
   */

  export type AggregateWoolLog = {
    _count: WoolLogCountAggregateOutputType | null
    _avg: WoolLogAvgAggregateOutputType | null
    _sum: WoolLogSumAggregateOutputType | null
    _min: WoolLogMinAggregateOutputType | null
    _max: WoolLogMaxAggregateOutputType | null
  }

  export type WoolLogAvgAggregateOutputType = {
    amountKg: number | null
  }

  export type WoolLogSumAggregateOutputType = {
    amountKg: number | null
  }

  export type WoolLogMinAggregateOutputType = {
    id: string | null
    livestockId: string | null
    shearedAt: Date | null
    amountKg: number | null
    qualityGrade: string | null
    createdAt: Date | null
  }

  export type WoolLogMaxAggregateOutputType = {
    id: string | null
    livestockId: string | null
    shearedAt: Date | null
    amountKg: number | null
    qualityGrade: string | null
    createdAt: Date | null
  }

  export type WoolLogCountAggregateOutputType = {
    id: number
    livestockId: number
    shearedAt: number
    amountKg: number
    qualityGrade: number
    createdAt: number
    _all: number
  }


  export type WoolLogAvgAggregateInputType = {
    amountKg?: true
  }

  export type WoolLogSumAggregateInputType = {
    amountKg?: true
  }

  export type WoolLogMinAggregateInputType = {
    id?: true
    livestockId?: true
    shearedAt?: true
    amountKg?: true
    qualityGrade?: true
    createdAt?: true
  }

  export type WoolLogMaxAggregateInputType = {
    id?: true
    livestockId?: true
    shearedAt?: true
    amountKg?: true
    qualityGrade?: true
    createdAt?: true
  }

  export type WoolLogCountAggregateInputType = {
    id?: true
    livestockId?: true
    shearedAt?: true
    amountKg?: true
    qualityGrade?: true
    createdAt?: true
    _all?: true
  }

  export type WoolLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WoolLog to aggregate.
     */
    where?: WoolLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WoolLogs to fetch.
     */
    orderBy?: WoolLogOrderByWithRelationInput | WoolLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WoolLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WoolLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WoolLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WoolLogs
    **/
    _count?: true | WoolLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WoolLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WoolLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WoolLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WoolLogMaxAggregateInputType
  }

  export type GetWoolLogAggregateType<T extends WoolLogAggregateArgs> = {
        [P in keyof T & keyof AggregateWoolLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWoolLog[P]>
      : GetScalarType<T[P], AggregateWoolLog[P]>
  }




  export type WoolLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WoolLogWhereInput
    orderBy?: WoolLogOrderByWithAggregationInput | WoolLogOrderByWithAggregationInput[]
    by: WoolLogScalarFieldEnum[] | WoolLogScalarFieldEnum
    having?: WoolLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WoolLogCountAggregateInputType | true
    _avg?: WoolLogAvgAggregateInputType
    _sum?: WoolLogSumAggregateInputType
    _min?: WoolLogMinAggregateInputType
    _max?: WoolLogMaxAggregateInputType
  }

  export type WoolLogGroupByOutputType = {
    id: string
    livestockId: string
    shearedAt: Date
    amountKg: number
    qualityGrade: string | null
    createdAt: Date
    _count: WoolLogCountAggregateOutputType | null
    _avg: WoolLogAvgAggregateOutputType | null
    _sum: WoolLogSumAggregateOutputType | null
    _min: WoolLogMinAggregateOutputType | null
    _max: WoolLogMaxAggregateOutputType | null
  }

  type GetWoolLogGroupByPayload<T extends WoolLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WoolLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WoolLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WoolLogGroupByOutputType[P]>
            : GetScalarType<T[P], WoolLogGroupByOutputType[P]>
        }
      >
    >


  export type WoolLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    livestockId?: boolean
    shearedAt?: boolean
    amountKg?: boolean
    qualityGrade?: boolean
    createdAt?: boolean
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["woolLog"]>

  export type WoolLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    livestockId?: boolean
    shearedAt?: boolean
    amountKg?: boolean
    qualityGrade?: boolean
    createdAt?: boolean
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["woolLog"]>

  export type WoolLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    livestockId?: boolean
    shearedAt?: boolean
    amountKg?: boolean
    qualityGrade?: boolean
    createdAt?: boolean
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["woolLog"]>

  export type WoolLogSelectScalar = {
    id?: boolean
    livestockId?: boolean
    shearedAt?: boolean
    amountKg?: boolean
    qualityGrade?: boolean
    createdAt?: boolean
  }

  export type WoolLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "livestockId" | "shearedAt" | "amountKg" | "qualityGrade" | "createdAt", ExtArgs["result"]["woolLog"]>
  export type WoolLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }
  export type WoolLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }
  export type WoolLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }

  export type $WoolLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WoolLog"
    objects: {
      livestock: Prisma.$LivestockPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      livestockId: string
      shearedAt: Date
      amountKg: number
      qualityGrade: string | null
      createdAt: Date
    }, ExtArgs["result"]["woolLog"]>
    composites: {}
  }

  type WoolLogGetPayload<S extends boolean | null | undefined | WoolLogDefaultArgs> = $Result.GetResult<Prisma.$WoolLogPayload, S>

  type WoolLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WoolLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WoolLogCountAggregateInputType | true
    }

  export interface WoolLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WoolLog'], meta: { name: 'WoolLog' } }
    /**
     * Find zero or one WoolLog that matches the filter.
     * @param {WoolLogFindUniqueArgs} args - Arguments to find a WoolLog
     * @example
     * // Get one WoolLog
     * const woolLog = await prisma.woolLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WoolLogFindUniqueArgs>(args: SelectSubset<T, WoolLogFindUniqueArgs<ExtArgs>>): Prisma__WoolLogClient<$Result.GetResult<Prisma.$WoolLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WoolLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WoolLogFindUniqueOrThrowArgs} args - Arguments to find a WoolLog
     * @example
     * // Get one WoolLog
     * const woolLog = await prisma.woolLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WoolLogFindUniqueOrThrowArgs>(args: SelectSubset<T, WoolLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WoolLogClient<$Result.GetResult<Prisma.$WoolLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WoolLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WoolLogFindFirstArgs} args - Arguments to find a WoolLog
     * @example
     * // Get one WoolLog
     * const woolLog = await prisma.woolLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WoolLogFindFirstArgs>(args?: SelectSubset<T, WoolLogFindFirstArgs<ExtArgs>>): Prisma__WoolLogClient<$Result.GetResult<Prisma.$WoolLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WoolLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WoolLogFindFirstOrThrowArgs} args - Arguments to find a WoolLog
     * @example
     * // Get one WoolLog
     * const woolLog = await prisma.woolLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WoolLogFindFirstOrThrowArgs>(args?: SelectSubset<T, WoolLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__WoolLogClient<$Result.GetResult<Prisma.$WoolLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WoolLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WoolLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WoolLogs
     * const woolLogs = await prisma.woolLog.findMany()
     * 
     * // Get first 10 WoolLogs
     * const woolLogs = await prisma.woolLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const woolLogWithIdOnly = await prisma.woolLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WoolLogFindManyArgs>(args?: SelectSubset<T, WoolLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WoolLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WoolLog.
     * @param {WoolLogCreateArgs} args - Arguments to create a WoolLog.
     * @example
     * // Create one WoolLog
     * const WoolLog = await prisma.woolLog.create({
     *   data: {
     *     // ... data to create a WoolLog
     *   }
     * })
     * 
     */
    create<T extends WoolLogCreateArgs>(args: SelectSubset<T, WoolLogCreateArgs<ExtArgs>>): Prisma__WoolLogClient<$Result.GetResult<Prisma.$WoolLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WoolLogs.
     * @param {WoolLogCreateManyArgs} args - Arguments to create many WoolLogs.
     * @example
     * // Create many WoolLogs
     * const woolLog = await prisma.woolLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WoolLogCreateManyArgs>(args?: SelectSubset<T, WoolLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WoolLogs and returns the data saved in the database.
     * @param {WoolLogCreateManyAndReturnArgs} args - Arguments to create many WoolLogs.
     * @example
     * // Create many WoolLogs
     * const woolLog = await prisma.woolLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WoolLogs and only return the `id`
     * const woolLogWithIdOnly = await prisma.woolLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WoolLogCreateManyAndReturnArgs>(args?: SelectSubset<T, WoolLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WoolLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WoolLog.
     * @param {WoolLogDeleteArgs} args - Arguments to delete one WoolLog.
     * @example
     * // Delete one WoolLog
     * const WoolLog = await prisma.woolLog.delete({
     *   where: {
     *     // ... filter to delete one WoolLog
     *   }
     * })
     * 
     */
    delete<T extends WoolLogDeleteArgs>(args: SelectSubset<T, WoolLogDeleteArgs<ExtArgs>>): Prisma__WoolLogClient<$Result.GetResult<Prisma.$WoolLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WoolLog.
     * @param {WoolLogUpdateArgs} args - Arguments to update one WoolLog.
     * @example
     * // Update one WoolLog
     * const woolLog = await prisma.woolLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WoolLogUpdateArgs>(args: SelectSubset<T, WoolLogUpdateArgs<ExtArgs>>): Prisma__WoolLogClient<$Result.GetResult<Prisma.$WoolLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WoolLogs.
     * @param {WoolLogDeleteManyArgs} args - Arguments to filter WoolLogs to delete.
     * @example
     * // Delete a few WoolLogs
     * const { count } = await prisma.woolLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WoolLogDeleteManyArgs>(args?: SelectSubset<T, WoolLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WoolLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WoolLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WoolLogs
     * const woolLog = await prisma.woolLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WoolLogUpdateManyArgs>(args: SelectSubset<T, WoolLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WoolLogs and returns the data updated in the database.
     * @param {WoolLogUpdateManyAndReturnArgs} args - Arguments to update many WoolLogs.
     * @example
     * // Update many WoolLogs
     * const woolLog = await prisma.woolLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WoolLogs and only return the `id`
     * const woolLogWithIdOnly = await prisma.woolLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WoolLogUpdateManyAndReturnArgs>(args: SelectSubset<T, WoolLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WoolLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WoolLog.
     * @param {WoolLogUpsertArgs} args - Arguments to update or create a WoolLog.
     * @example
     * // Update or create a WoolLog
     * const woolLog = await prisma.woolLog.upsert({
     *   create: {
     *     // ... data to create a WoolLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WoolLog we want to update
     *   }
     * })
     */
    upsert<T extends WoolLogUpsertArgs>(args: SelectSubset<T, WoolLogUpsertArgs<ExtArgs>>): Prisma__WoolLogClient<$Result.GetResult<Prisma.$WoolLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WoolLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WoolLogCountArgs} args - Arguments to filter WoolLogs to count.
     * @example
     * // Count the number of WoolLogs
     * const count = await prisma.woolLog.count({
     *   where: {
     *     // ... the filter for the WoolLogs we want to count
     *   }
     * })
    **/
    count<T extends WoolLogCountArgs>(
      args?: Subset<T, WoolLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WoolLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WoolLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WoolLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WoolLogAggregateArgs>(args: Subset<T, WoolLogAggregateArgs>): Prisma.PrismaPromise<GetWoolLogAggregateType<T>>

    /**
     * Group by WoolLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WoolLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WoolLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WoolLogGroupByArgs['orderBy'] }
        : { orderBy?: WoolLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WoolLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWoolLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WoolLog model
   */
  readonly fields: WoolLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WoolLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WoolLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    livestock<T extends LivestockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LivestockDefaultArgs<ExtArgs>>): Prisma__LivestockClient<$Result.GetResult<Prisma.$LivestockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WoolLog model
   */
  interface WoolLogFieldRefs {
    readonly id: FieldRef<"WoolLog", 'String'>
    readonly livestockId: FieldRef<"WoolLog", 'String'>
    readonly shearedAt: FieldRef<"WoolLog", 'DateTime'>
    readonly amountKg: FieldRef<"WoolLog", 'Float'>
    readonly qualityGrade: FieldRef<"WoolLog", 'String'>
    readonly createdAt: FieldRef<"WoolLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WoolLog findUnique
   */
  export type WoolLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WoolLog
     */
    select?: WoolLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WoolLog
     */
    omit?: WoolLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WoolLogInclude<ExtArgs> | null
    /**
     * Filter, which WoolLog to fetch.
     */
    where: WoolLogWhereUniqueInput
  }

  /**
   * WoolLog findUniqueOrThrow
   */
  export type WoolLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WoolLog
     */
    select?: WoolLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WoolLog
     */
    omit?: WoolLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WoolLogInclude<ExtArgs> | null
    /**
     * Filter, which WoolLog to fetch.
     */
    where: WoolLogWhereUniqueInput
  }

  /**
   * WoolLog findFirst
   */
  export type WoolLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WoolLog
     */
    select?: WoolLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WoolLog
     */
    omit?: WoolLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WoolLogInclude<ExtArgs> | null
    /**
     * Filter, which WoolLog to fetch.
     */
    where?: WoolLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WoolLogs to fetch.
     */
    orderBy?: WoolLogOrderByWithRelationInput | WoolLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WoolLogs.
     */
    cursor?: WoolLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WoolLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WoolLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WoolLogs.
     */
    distinct?: WoolLogScalarFieldEnum | WoolLogScalarFieldEnum[]
  }

  /**
   * WoolLog findFirstOrThrow
   */
  export type WoolLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WoolLog
     */
    select?: WoolLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WoolLog
     */
    omit?: WoolLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WoolLogInclude<ExtArgs> | null
    /**
     * Filter, which WoolLog to fetch.
     */
    where?: WoolLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WoolLogs to fetch.
     */
    orderBy?: WoolLogOrderByWithRelationInput | WoolLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WoolLogs.
     */
    cursor?: WoolLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WoolLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WoolLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WoolLogs.
     */
    distinct?: WoolLogScalarFieldEnum | WoolLogScalarFieldEnum[]
  }

  /**
   * WoolLog findMany
   */
  export type WoolLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WoolLog
     */
    select?: WoolLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WoolLog
     */
    omit?: WoolLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WoolLogInclude<ExtArgs> | null
    /**
     * Filter, which WoolLogs to fetch.
     */
    where?: WoolLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WoolLogs to fetch.
     */
    orderBy?: WoolLogOrderByWithRelationInput | WoolLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WoolLogs.
     */
    cursor?: WoolLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WoolLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WoolLogs.
     */
    skip?: number
    distinct?: WoolLogScalarFieldEnum | WoolLogScalarFieldEnum[]
  }

  /**
   * WoolLog create
   */
  export type WoolLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WoolLog
     */
    select?: WoolLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WoolLog
     */
    omit?: WoolLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WoolLogInclude<ExtArgs> | null
    /**
     * The data needed to create a WoolLog.
     */
    data: XOR<WoolLogCreateInput, WoolLogUncheckedCreateInput>
  }

  /**
   * WoolLog createMany
   */
  export type WoolLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WoolLogs.
     */
    data: WoolLogCreateManyInput | WoolLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WoolLog createManyAndReturn
   */
  export type WoolLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WoolLog
     */
    select?: WoolLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WoolLog
     */
    omit?: WoolLogOmit<ExtArgs> | null
    /**
     * The data used to create many WoolLogs.
     */
    data: WoolLogCreateManyInput | WoolLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WoolLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WoolLog update
   */
  export type WoolLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WoolLog
     */
    select?: WoolLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WoolLog
     */
    omit?: WoolLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WoolLogInclude<ExtArgs> | null
    /**
     * The data needed to update a WoolLog.
     */
    data: XOR<WoolLogUpdateInput, WoolLogUncheckedUpdateInput>
    /**
     * Choose, which WoolLog to update.
     */
    where: WoolLogWhereUniqueInput
  }

  /**
   * WoolLog updateMany
   */
  export type WoolLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WoolLogs.
     */
    data: XOR<WoolLogUpdateManyMutationInput, WoolLogUncheckedUpdateManyInput>
    /**
     * Filter which WoolLogs to update
     */
    where?: WoolLogWhereInput
    /**
     * Limit how many WoolLogs to update.
     */
    limit?: number
  }

  /**
   * WoolLog updateManyAndReturn
   */
  export type WoolLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WoolLog
     */
    select?: WoolLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WoolLog
     */
    omit?: WoolLogOmit<ExtArgs> | null
    /**
     * The data used to update WoolLogs.
     */
    data: XOR<WoolLogUpdateManyMutationInput, WoolLogUncheckedUpdateManyInput>
    /**
     * Filter which WoolLogs to update
     */
    where?: WoolLogWhereInput
    /**
     * Limit how many WoolLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WoolLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WoolLog upsert
   */
  export type WoolLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WoolLog
     */
    select?: WoolLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WoolLog
     */
    omit?: WoolLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WoolLogInclude<ExtArgs> | null
    /**
     * The filter to search for the WoolLog to update in case it exists.
     */
    where: WoolLogWhereUniqueInput
    /**
     * In case the WoolLog found by the `where` argument doesn't exist, create a new WoolLog with this data.
     */
    create: XOR<WoolLogCreateInput, WoolLogUncheckedCreateInput>
    /**
     * In case the WoolLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WoolLogUpdateInput, WoolLogUncheckedUpdateInput>
  }

  /**
   * WoolLog delete
   */
  export type WoolLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WoolLog
     */
    select?: WoolLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WoolLog
     */
    omit?: WoolLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WoolLogInclude<ExtArgs> | null
    /**
     * Filter which WoolLog to delete.
     */
    where: WoolLogWhereUniqueInput
  }

  /**
   * WoolLog deleteMany
   */
  export type WoolLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WoolLogs to delete
     */
    where?: WoolLogWhereInput
    /**
     * Limit how many WoolLogs to delete.
     */
    limit?: number
  }

  /**
   * WoolLog without action
   */
  export type WoolLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WoolLog
     */
    select?: WoolLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WoolLog
     */
    omit?: WoolLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WoolLogInclude<ExtArgs> | null
  }


  /**
   * Model WeightLog
   */

  export type AggregateWeightLog = {
    _count: WeightLogCountAggregateOutputType | null
    _avg: WeightLogAvgAggregateOutputType | null
    _sum: WeightLogSumAggregateOutputType | null
    _min: WeightLogMinAggregateOutputType | null
    _max: WeightLogMaxAggregateOutputType | null
  }

  export type WeightLogAvgAggregateOutputType = {
    weightKg: number | null
  }

  export type WeightLogSumAggregateOutputType = {
    weightKg: number | null
  }

  export type WeightLogMinAggregateOutputType = {
    id: string | null
    livestockId: string | null
    measuredAt: Date | null
    weightKg: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type WeightLogMaxAggregateOutputType = {
    id: string | null
    livestockId: string | null
    measuredAt: Date | null
    weightKg: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type WeightLogCountAggregateOutputType = {
    id: number
    livestockId: number
    measuredAt: number
    weightKg: number
    notes: number
    createdAt: number
    _all: number
  }


  export type WeightLogAvgAggregateInputType = {
    weightKg?: true
  }

  export type WeightLogSumAggregateInputType = {
    weightKg?: true
  }

  export type WeightLogMinAggregateInputType = {
    id?: true
    livestockId?: true
    measuredAt?: true
    weightKg?: true
    notes?: true
    createdAt?: true
  }

  export type WeightLogMaxAggregateInputType = {
    id?: true
    livestockId?: true
    measuredAt?: true
    weightKg?: true
    notes?: true
    createdAt?: true
  }

  export type WeightLogCountAggregateInputType = {
    id?: true
    livestockId?: true
    measuredAt?: true
    weightKg?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type WeightLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeightLog to aggregate.
     */
    where?: WeightLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeightLogs to fetch.
     */
    orderBy?: WeightLogOrderByWithRelationInput | WeightLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeightLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeightLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeightLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeightLogs
    **/
    _count?: true | WeightLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeightLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeightLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeightLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeightLogMaxAggregateInputType
  }

  export type GetWeightLogAggregateType<T extends WeightLogAggregateArgs> = {
        [P in keyof T & keyof AggregateWeightLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeightLog[P]>
      : GetScalarType<T[P], AggregateWeightLog[P]>
  }




  export type WeightLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeightLogWhereInput
    orderBy?: WeightLogOrderByWithAggregationInput | WeightLogOrderByWithAggregationInput[]
    by: WeightLogScalarFieldEnum[] | WeightLogScalarFieldEnum
    having?: WeightLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeightLogCountAggregateInputType | true
    _avg?: WeightLogAvgAggregateInputType
    _sum?: WeightLogSumAggregateInputType
    _min?: WeightLogMinAggregateInputType
    _max?: WeightLogMaxAggregateInputType
  }

  export type WeightLogGroupByOutputType = {
    id: string
    livestockId: string
    measuredAt: Date
    weightKg: number
    notes: string | null
    createdAt: Date
    _count: WeightLogCountAggregateOutputType | null
    _avg: WeightLogAvgAggregateOutputType | null
    _sum: WeightLogSumAggregateOutputType | null
    _min: WeightLogMinAggregateOutputType | null
    _max: WeightLogMaxAggregateOutputType | null
  }

  type GetWeightLogGroupByPayload<T extends WeightLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeightLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeightLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeightLogGroupByOutputType[P]>
            : GetScalarType<T[P], WeightLogGroupByOutputType[P]>
        }
      >
    >


  export type WeightLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    livestockId?: boolean
    measuredAt?: boolean
    weightKg?: boolean
    notes?: boolean
    createdAt?: boolean
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weightLog"]>

  export type WeightLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    livestockId?: boolean
    measuredAt?: boolean
    weightKg?: boolean
    notes?: boolean
    createdAt?: boolean
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weightLog"]>

  export type WeightLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    livestockId?: boolean
    measuredAt?: boolean
    weightKg?: boolean
    notes?: boolean
    createdAt?: boolean
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weightLog"]>

  export type WeightLogSelectScalar = {
    id?: boolean
    livestockId?: boolean
    measuredAt?: boolean
    weightKg?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type WeightLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "livestockId" | "measuredAt" | "weightKg" | "notes" | "createdAt", ExtArgs["result"]["weightLog"]>
  export type WeightLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }
  export type WeightLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }
  export type WeightLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }

  export type $WeightLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeightLog"
    objects: {
      livestock: Prisma.$LivestockPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      livestockId: string
      measuredAt: Date
      weightKg: number
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["weightLog"]>
    composites: {}
  }

  type WeightLogGetPayload<S extends boolean | null | undefined | WeightLogDefaultArgs> = $Result.GetResult<Prisma.$WeightLogPayload, S>

  type WeightLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeightLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeightLogCountAggregateInputType | true
    }

  export interface WeightLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeightLog'], meta: { name: 'WeightLog' } }
    /**
     * Find zero or one WeightLog that matches the filter.
     * @param {WeightLogFindUniqueArgs} args - Arguments to find a WeightLog
     * @example
     * // Get one WeightLog
     * const weightLog = await prisma.weightLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeightLogFindUniqueArgs>(args: SelectSubset<T, WeightLogFindUniqueArgs<ExtArgs>>): Prisma__WeightLogClient<$Result.GetResult<Prisma.$WeightLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WeightLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeightLogFindUniqueOrThrowArgs} args - Arguments to find a WeightLog
     * @example
     * // Get one WeightLog
     * const weightLog = await prisma.weightLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeightLogFindUniqueOrThrowArgs>(args: SelectSubset<T, WeightLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeightLogClient<$Result.GetResult<Prisma.$WeightLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeightLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightLogFindFirstArgs} args - Arguments to find a WeightLog
     * @example
     * // Get one WeightLog
     * const weightLog = await prisma.weightLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeightLogFindFirstArgs>(args?: SelectSubset<T, WeightLogFindFirstArgs<ExtArgs>>): Prisma__WeightLogClient<$Result.GetResult<Prisma.$WeightLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeightLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightLogFindFirstOrThrowArgs} args - Arguments to find a WeightLog
     * @example
     * // Get one WeightLog
     * const weightLog = await prisma.weightLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeightLogFindFirstOrThrowArgs>(args?: SelectSubset<T, WeightLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeightLogClient<$Result.GetResult<Prisma.$WeightLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WeightLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeightLogs
     * const weightLogs = await prisma.weightLog.findMany()
     * 
     * // Get first 10 WeightLogs
     * const weightLogs = await prisma.weightLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weightLogWithIdOnly = await prisma.weightLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeightLogFindManyArgs>(args?: SelectSubset<T, WeightLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeightLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WeightLog.
     * @param {WeightLogCreateArgs} args - Arguments to create a WeightLog.
     * @example
     * // Create one WeightLog
     * const WeightLog = await prisma.weightLog.create({
     *   data: {
     *     // ... data to create a WeightLog
     *   }
     * })
     * 
     */
    create<T extends WeightLogCreateArgs>(args: SelectSubset<T, WeightLogCreateArgs<ExtArgs>>): Prisma__WeightLogClient<$Result.GetResult<Prisma.$WeightLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WeightLogs.
     * @param {WeightLogCreateManyArgs} args - Arguments to create many WeightLogs.
     * @example
     * // Create many WeightLogs
     * const weightLog = await prisma.weightLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeightLogCreateManyArgs>(args?: SelectSubset<T, WeightLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WeightLogs and returns the data saved in the database.
     * @param {WeightLogCreateManyAndReturnArgs} args - Arguments to create many WeightLogs.
     * @example
     * // Create many WeightLogs
     * const weightLog = await prisma.weightLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WeightLogs and only return the `id`
     * const weightLogWithIdOnly = await prisma.weightLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeightLogCreateManyAndReturnArgs>(args?: SelectSubset<T, WeightLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeightLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WeightLog.
     * @param {WeightLogDeleteArgs} args - Arguments to delete one WeightLog.
     * @example
     * // Delete one WeightLog
     * const WeightLog = await prisma.weightLog.delete({
     *   where: {
     *     // ... filter to delete one WeightLog
     *   }
     * })
     * 
     */
    delete<T extends WeightLogDeleteArgs>(args: SelectSubset<T, WeightLogDeleteArgs<ExtArgs>>): Prisma__WeightLogClient<$Result.GetResult<Prisma.$WeightLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WeightLog.
     * @param {WeightLogUpdateArgs} args - Arguments to update one WeightLog.
     * @example
     * // Update one WeightLog
     * const weightLog = await prisma.weightLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeightLogUpdateArgs>(args: SelectSubset<T, WeightLogUpdateArgs<ExtArgs>>): Prisma__WeightLogClient<$Result.GetResult<Prisma.$WeightLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WeightLogs.
     * @param {WeightLogDeleteManyArgs} args - Arguments to filter WeightLogs to delete.
     * @example
     * // Delete a few WeightLogs
     * const { count } = await prisma.weightLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeightLogDeleteManyArgs>(args?: SelectSubset<T, WeightLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeightLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeightLogs
     * const weightLog = await prisma.weightLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeightLogUpdateManyArgs>(args: SelectSubset<T, WeightLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeightLogs and returns the data updated in the database.
     * @param {WeightLogUpdateManyAndReturnArgs} args - Arguments to update many WeightLogs.
     * @example
     * // Update many WeightLogs
     * const weightLog = await prisma.weightLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WeightLogs and only return the `id`
     * const weightLogWithIdOnly = await prisma.weightLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WeightLogUpdateManyAndReturnArgs>(args: SelectSubset<T, WeightLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeightLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WeightLog.
     * @param {WeightLogUpsertArgs} args - Arguments to update or create a WeightLog.
     * @example
     * // Update or create a WeightLog
     * const weightLog = await prisma.weightLog.upsert({
     *   create: {
     *     // ... data to create a WeightLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeightLog we want to update
     *   }
     * })
     */
    upsert<T extends WeightLogUpsertArgs>(args: SelectSubset<T, WeightLogUpsertArgs<ExtArgs>>): Prisma__WeightLogClient<$Result.GetResult<Prisma.$WeightLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WeightLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightLogCountArgs} args - Arguments to filter WeightLogs to count.
     * @example
     * // Count the number of WeightLogs
     * const count = await prisma.weightLog.count({
     *   where: {
     *     // ... the filter for the WeightLogs we want to count
     *   }
     * })
    **/
    count<T extends WeightLogCountArgs>(
      args?: Subset<T, WeightLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeightLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeightLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeightLogAggregateArgs>(args: Subset<T, WeightLogAggregateArgs>): Prisma.PrismaPromise<GetWeightLogAggregateType<T>>

    /**
     * Group by WeightLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeightLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeightLogGroupByArgs['orderBy'] }
        : { orderBy?: WeightLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeightLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeightLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeightLog model
   */
  readonly fields: WeightLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeightLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeightLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    livestock<T extends LivestockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LivestockDefaultArgs<ExtArgs>>): Prisma__LivestockClient<$Result.GetResult<Prisma.$LivestockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeightLog model
   */
  interface WeightLogFieldRefs {
    readonly id: FieldRef<"WeightLog", 'String'>
    readonly livestockId: FieldRef<"WeightLog", 'String'>
    readonly measuredAt: FieldRef<"WeightLog", 'DateTime'>
    readonly weightKg: FieldRef<"WeightLog", 'Float'>
    readonly notes: FieldRef<"WeightLog", 'String'>
    readonly createdAt: FieldRef<"WeightLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WeightLog findUnique
   */
  export type WeightLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightLog
     */
    select?: WeightLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeightLog
     */
    omit?: WeightLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightLogInclude<ExtArgs> | null
    /**
     * Filter, which WeightLog to fetch.
     */
    where: WeightLogWhereUniqueInput
  }

  /**
   * WeightLog findUniqueOrThrow
   */
  export type WeightLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightLog
     */
    select?: WeightLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeightLog
     */
    omit?: WeightLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightLogInclude<ExtArgs> | null
    /**
     * Filter, which WeightLog to fetch.
     */
    where: WeightLogWhereUniqueInput
  }

  /**
   * WeightLog findFirst
   */
  export type WeightLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightLog
     */
    select?: WeightLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeightLog
     */
    omit?: WeightLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightLogInclude<ExtArgs> | null
    /**
     * Filter, which WeightLog to fetch.
     */
    where?: WeightLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeightLogs to fetch.
     */
    orderBy?: WeightLogOrderByWithRelationInput | WeightLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeightLogs.
     */
    cursor?: WeightLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeightLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeightLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeightLogs.
     */
    distinct?: WeightLogScalarFieldEnum | WeightLogScalarFieldEnum[]
  }

  /**
   * WeightLog findFirstOrThrow
   */
  export type WeightLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightLog
     */
    select?: WeightLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeightLog
     */
    omit?: WeightLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightLogInclude<ExtArgs> | null
    /**
     * Filter, which WeightLog to fetch.
     */
    where?: WeightLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeightLogs to fetch.
     */
    orderBy?: WeightLogOrderByWithRelationInput | WeightLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeightLogs.
     */
    cursor?: WeightLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeightLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeightLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeightLogs.
     */
    distinct?: WeightLogScalarFieldEnum | WeightLogScalarFieldEnum[]
  }

  /**
   * WeightLog findMany
   */
  export type WeightLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightLog
     */
    select?: WeightLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeightLog
     */
    omit?: WeightLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightLogInclude<ExtArgs> | null
    /**
     * Filter, which WeightLogs to fetch.
     */
    where?: WeightLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeightLogs to fetch.
     */
    orderBy?: WeightLogOrderByWithRelationInput | WeightLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeightLogs.
     */
    cursor?: WeightLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeightLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeightLogs.
     */
    skip?: number
    distinct?: WeightLogScalarFieldEnum | WeightLogScalarFieldEnum[]
  }

  /**
   * WeightLog create
   */
  export type WeightLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightLog
     */
    select?: WeightLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeightLog
     */
    omit?: WeightLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightLogInclude<ExtArgs> | null
    /**
     * The data needed to create a WeightLog.
     */
    data: XOR<WeightLogCreateInput, WeightLogUncheckedCreateInput>
  }

  /**
   * WeightLog createMany
   */
  export type WeightLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeightLogs.
     */
    data: WeightLogCreateManyInput | WeightLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeightLog createManyAndReturn
   */
  export type WeightLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightLog
     */
    select?: WeightLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeightLog
     */
    omit?: WeightLogOmit<ExtArgs> | null
    /**
     * The data used to create many WeightLogs.
     */
    data: WeightLogCreateManyInput | WeightLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeightLog update
   */
  export type WeightLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightLog
     */
    select?: WeightLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeightLog
     */
    omit?: WeightLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightLogInclude<ExtArgs> | null
    /**
     * The data needed to update a WeightLog.
     */
    data: XOR<WeightLogUpdateInput, WeightLogUncheckedUpdateInput>
    /**
     * Choose, which WeightLog to update.
     */
    where: WeightLogWhereUniqueInput
  }

  /**
   * WeightLog updateMany
   */
  export type WeightLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeightLogs.
     */
    data: XOR<WeightLogUpdateManyMutationInput, WeightLogUncheckedUpdateManyInput>
    /**
     * Filter which WeightLogs to update
     */
    where?: WeightLogWhereInput
    /**
     * Limit how many WeightLogs to update.
     */
    limit?: number
  }

  /**
   * WeightLog updateManyAndReturn
   */
  export type WeightLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightLog
     */
    select?: WeightLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeightLog
     */
    omit?: WeightLogOmit<ExtArgs> | null
    /**
     * The data used to update WeightLogs.
     */
    data: XOR<WeightLogUpdateManyMutationInput, WeightLogUncheckedUpdateManyInput>
    /**
     * Filter which WeightLogs to update
     */
    where?: WeightLogWhereInput
    /**
     * Limit how many WeightLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeightLog upsert
   */
  export type WeightLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightLog
     */
    select?: WeightLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeightLog
     */
    omit?: WeightLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightLogInclude<ExtArgs> | null
    /**
     * The filter to search for the WeightLog to update in case it exists.
     */
    where: WeightLogWhereUniqueInput
    /**
     * In case the WeightLog found by the `where` argument doesn't exist, create a new WeightLog with this data.
     */
    create: XOR<WeightLogCreateInput, WeightLogUncheckedCreateInput>
    /**
     * In case the WeightLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeightLogUpdateInput, WeightLogUncheckedUpdateInput>
  }

  /**
   * WeightLog delete
   */
  export type WeightLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightLog
     */
    select?: WeightLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeightLog
     */
    omit?: WeightLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightLogInclude<ExtArgs> | null
    /**
     * Filter which WeightLog to delete.
     */
    where: WeightLogWhereUniqueInput
  }

  /**
   * WeightLog deleteMany
   */
  export type WeightLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeightLogs to delete
     */
    where?: WeightLogWhereInput
    /**
     * Limit how many WeightLogs to delete.
     */
    limit?: number
  }

  /**
   * WeightLog without action
   */
  export type WeightLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightLog
     */
    select?: WeightLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeightLog
     */
    omit?: WeightLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightLogInclude<ExtArgs> | null
  }


  /**
   * Model LivestockMetric
   */

  export type AggregateLivestockMetric = {
    _count: LivestockMetricCountAggregateOutputType | null
    _min: LivestockMetricMinAggregateOutputType | null
    _max: LivestockMetricMaxAggregateOutputType | null
  }

  export type LivestockMetricMinAggregateOutputType = {
    id: string | null
    livestockId: string | null
    key: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LivestockMetricMaxAggregateOutputType = {
    id: string | null
    livestockId: string | null
    key: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LivestockMetricCountAggregateOutputType = {
    id: number
    livestockId: number
    key: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LivestockMetricMinAggregateInputType = {
    id?: true
    livestockId?: true
    key?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LivestockMetricMaxAggregateInputType = {
    id?: true
    livestockId?: true
    key?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LivestockMetricCountAggregateInputType = {
    id?: true
    livestockId?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LivestockMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LivestockMetric to aggregate.
     */
    where?: LivestockMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LivestockMetrics to fetch.
     */
    orderBy?: LivestockMetricOrderByWithRelationInput | LivestockMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LivestockMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LivestockMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LivestockMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LivestockMetrics
    **/
    _count?: true | LivestockMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LivestockMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LivestockMetricMaxAggregateInputType
  }

  export type GetLivestockMetricAggregateType<T extends LivestockMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateLivestockMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLivestockMetric[P]>
      : GetScalarType<T[P], AggregateLivestockMetric[P]>
  }




  export type LivestockMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LivestockMetricWhereInput
    orderBy?: LivestockMetricOrderByWithAggregationInput | LivestockMetricOrderByWithAggregationInput[]
    by: LivestockMetricScalarFieldEnum[] | LivestockMetricScalarFieldEnum
    having?: LivestockMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LivestockMetricCountAggregateInputType | true
    _min?: LivestockMetricMinAggregateInputType
    _max?: LivestockMetricMaxAggregateInputType
  }

  export type LivestockMetricGroupByOutputType = {
    id: string
    livestockId: string
    key: string
    value: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: LivestockMetricCountAggregateOutputType | null
    _min: LivestockMetricMinAggregateOutputType | null
    _max: LivestockMetricMaxAggregateOutputType | null
  }

  type GetLivestockMetricGroupByPayload<T extends LivestockMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LivestockMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LivestockMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LivestockMetricGroupByOutputType[P]>
            : GetScalarType<T[P], LivestockMetricGroupByOutputType[P]>
        }
      >
    >


  export type LivestockMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    livestockId?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["livestockMetric"]>

  export type LivestockMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    livestockId?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["livestockMetric"]>

  export type LivestockMetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    livestockId?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["livestockMetric"]>

  export type LivestockMetricSelectScalar = {
    id?: boolean
    livestockId?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LivestockMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "livestockId" | "key" | "value" | "createdAt" | "updatedAt", ExtArgs["result"]["livestockMetric"]>
  export type LivestockMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }
  export type LivestockMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }
  export type LivestockMetricIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    livestock?: boolean | LivestockDefaultArgs<ExtArgs>
  }

  export type $LivestockMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LivestockMetric"
    objects: {
      livestock: Prisma.$LivestockPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      livestockId: string
      key: string
      value: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["livestockMetric"]>
    composites: {}
  }

  type LivestockMetricGetPayload<S extends boolean | null | undefined | LivestockMetricDefaultArgs> = $Result.GetResult<Prisma.$LivestockMetricPayload, S>

  type LivestockMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LivestockMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LivestockMetricCountAggregateInputType | true
    }

  export interface LivestockMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LivestockMetric'], meta: { name: 'LivestockMetric' } }
    /**
     * Find zero or one LivestockMetric that matches the filter.
     * @param {LivestockMetricFindUniqueArgs} args - Arguments to find a LivestockMetric
     * @example
     * // Get one LivestockMetric
     * const livestockMetric = await prisma.livestockMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LivestockMetricFindUniqueArgs>(args: SelectSubset<T, LivestockMetricFindUniqueArgs<ExtArgs>>): Prisma__LivestockMetricClient<$Result.GetResult<Prisma.$LivestockMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LivestockMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LivestockMetricFindUniqueOrThrowArgs} args - Arguments to find a LivestockMetric
     * @example
     * // Get one LivestockMetric
     * const livestockMetric = await prisma.livestockMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LivestockMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, LivestockMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LivestockMetricClient<$Result.GetResult<Prisma.$LivestockMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LivestockMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivestockMetricFindFirstArgs} args - Arguments to find a LivestockMetric
     * @example
     * // Get one LivestockMetric
     * const livestockMetric = await prisma.livestockMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LivestockMetricFindFirstArgs>(args?: SelectSubset<T, LivestockMetricFindFirstArgs<ExtArgs>>): Prisma__LivestockMetricClient<$Result.GetResult<Prisma.$LivestockMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LivestockMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivestockMetricFindFirstOrThrowArgs} args - Arguments to find a LivestockMetric
     * @example
     * // Get one LivestockMetric
     * const livestockMetric = await prisma.livestockMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LivestockMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, LivestockMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__LivestockMetricClient<$Result.GetResult<Prisma.$LivestockMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LivestockMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivestockMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LivestockMetrics
     * const livestockMetrics = await prisma.livestockMetric.findMany()
     * 
     * // Get first 10 LivestockMetrics
     * const livestockMetrics = await prisma.livestockMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const livestockMetricWithIdOnly = await prisma.livestockMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LivestockMetricFindManyArgs>(args?: SelectSubset<T, LivestockMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivestockMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LivestockMetric.
     * @param {LivestockMetricCreateArgs} args - Arguments to create a LivestockMetric.
     * @example
     * // Create one LivestockMetric
     * const LivestockMetric = await prisma.livestockMetric.create({
     *   data: {
     *     // ... data to create a LivestockMetric
     *   }
     * })
     * 
     */
    create<T extends LivestockMetricCreateArgs>(args: SelectSubset<T, LivestockMetricCreateArgs<ExtArgs>>): Prisma__LivestockMetricClient<$Result.GetResult<Prisma.$LivestockMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LivestockMetrics.
     * @param {LivestockMetricCreateManyArgs} args - Arguments to create many LivestockMetrics.
     * @example
     * // Create many LivestockMetrics
     * const livestockMetric = await prisma.livestockMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LivestockMetricCreateManyArgs>(args?: SelectSubset<T, LivestockMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LivestockMetrics and returns the data saved in the database.
     * @param {LivestockMetricCreateManyAndReturnArgs} args - Arguments to create many LivestockMetrics.
     * @example
     * // Create many LivestockMetrics
     * const livestockMetric = await prisma.livestockMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LivestockMetrics and only return the `id`
     * const livestockMetricWithIdOnly = await prisma.livestockMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LivestockMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, LivestockMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivestockMetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LivestockMetric.
     * @param {LivestockMetricDeleteArgs} args - Arguments to delete one LivestockMetric.
     * @example
     * // Delete one LivestockMetric
     * const LivestockMetric = await prisma.livestockMetric.delete({
     *   where: {
     *     // ... filter to delete one LivestockMetric
     *   }
     * })
     * 
     */
    delete<T extends LivestockMetricDeleteArgs>(args: SelectSubset<T, LivestockMetricDeleteArgs<ExtArgs>>): Prisma__LivestockMetricClient<$Result.GetResult<Prisma.$LivestockMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LivestockMetric.
     * @param {LivestockMetricUpdateArgs} args - Arguments to update one LivestockMetric.
     * @example
     * // Update one LivestockMetric
     * const livestockMetric = await prisma.livestockMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LivestockMetricUpdateArgs>(args: SelectSubset<T, LivestockMetricUpdateArgs<ExtArgs>>): Prisma__LivestockMetricClient<$Result.GetResult<Prisma.$LivestockMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LivestockMetrics.
     * @param {LivestockMetricDeleteManyArgs} args - Arguments to filter LivestockMetrics to delete.
     * @example
     * // Delete a few LivestockMetrics
     * const { count } = await prisma.livestockMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LivestockMetricDeleteManyArgs>(args?: SelectSubset<T, LivestockMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LivestockMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivestockMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LivestockMetrics
     * const livestockMetric = await prisma.livestockMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LivestockMetricUpdateManyArgs>(args: SelectSubset<T, LivestockMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LivestockMetrics and returns the data updated in the database.
     * @param {LivestockMetricUpdateManyAndReturnArgs} args - Arguments to update many LivestockMetrics.
     * @example
     * // Update many LivestockMetrics
     * const livestockMetric = await prisma.livestockMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LivestockMetrics and only return the `id`
     * const livestockMetricWithIdOnly = await prisma.livestockMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LivestockMetricUpdateManyAndReturnArgs>(args: SelectSubset<T, LivestockMetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivestockMetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LivestockMetric.
     * @param {LivestockMetricUpsertArgs} args - Arguments to update or create a LivestockMetric.
     * @example
     * // Update or create a LivestockMetric
     * const livestockMetric = await prisma.livestockMetric.upsert({
     *   create: {
     *     // ... data to create a LivestockMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LivestockMetric we want to update
     *   }
     * })
     */
    upsert<T extends LivestockMetricUpsertArgs>(args: SelectSubset<T, LivestockMetricUpsertArgs<ExtArgs>>): Prisma__LivestockMetricClient<$Result.GetResult<Prisma.$LivestockMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LivestockMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivestockMetricCountArgs} args - Arguments to filter LivestockMetrics to count.
     * @example
     * // Count the number of LivestockMetrics
     * const count = await prisma.livestockMetric.count({
     *   where: {
     *     // ... the filter for the LivestockMetrics we want to count
     *   }
     * })
    **/
    count<T extends LivestockMetricCountArgs>(
      args?: Subset<T, LivestockMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LivestockMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LivestockMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivestockMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LivestockMetricAggregateArgs>(args: Subset<T, LivestockMetricAggregateArgs>): Prisma.PrismaPromise<GetLivestockMetricAggregateType<T>>

    /**
     * Group by LivestockMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivestockMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LivestockMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LivestockMetricGroupByArgs['orderBy'] }
        : { orderBy?: LivestockMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LivestockMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLivestockMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LivestockMetric model
   */
  readonly fields: LivestockMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LivestockMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LivestockMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    livestock<T extends LivestockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LivestockDefaultArgs<ExtArgs>>): Prisma__LivestockClient<$Result.GetResult<Prisma.$LivestockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LivestockMetric model
   */
  interface LivestockMetricFieldRefs {
    readonly id: FieldRef<"LivestockMetric", 'String'>
    readonly livestockId: FieldRef<"LivestockMetric", 'String'>
    readonly key: FieldRef<"LivestockMetric", 'String'>
    readonly value: FieldRef<"LivestockMetric", 'Json'>
    readonly createdAt: FieldRef<"LivestockMetric", 'DateTime'>
    readonly updatedAt: FieldRef<"LivestockMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LivestockMetric findUnique
   */
  export type LivestockMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivestockMetric
     */
    select?: LivestockMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivestockMetric
     */
    omit?: LivestockMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockMetricInclude<ExtArgs> | null
    /**
     * Filter, which LivestockMetric to fetch.
     */
    where: LivestockMetricWhereUniqueInput
  }

  /**
   * LivestockMetric findUniqueOrThrow
   */
  export type LivestockMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivestockMetric
     */
    select?: LivestockMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivestockMetric
     */
    omit?: LivestockMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockMetricInclude<ExtArgs> | null
    /**
     * Filter, which LivestockMetric to fetch.
     */
    where: LivestockMetricWhereUniqueInput
  }

  /**
   * LivestockMetric findFirst
   */
  export type LivestockMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivestockMetric
     */
    select?: LivestockMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivestockMetric
     */
    omit?: LivestockMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockMetricInclude<ExtArgs> | null
    /**
     * Filter, which LivestockMetric to fetch.
     */
    where?: LivestockMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LivestockMetrics to fetch.
     */
    orderBy?: LivestockMetricOrderByWithRelationInput | LivestockMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LivestockMetrics.
     */
    cursor?: LivestockMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LivestockMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LivestockMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LivestockMetrics.
     */
    distinct?: LivestockMetricScalarFieldEnum | LivestockMetricScalarFieldEnum[]
  }

  /**
   * LivestockMetric findFirstOrThrow
   */
  export type LivestockMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivestockMetric
     */
    select?: LivestockMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivestockMetric
     */
    omit?: LivestockMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockMetricInclude<ExtArgs> | null
    /**
     * Filter, which LivestockMetric to fetch.
     */
    where?: LivestockMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LivestockMetrics to fetch.
     */
    orderBy?: LivestockMetricOrderByWithRelationInput | LivestockMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LivestockMetrics.
     */
    cursor?: LivestockMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LivestockMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LivestockMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LivestockMetrics.
     */
    distinct?: LivestockMetricScalarFieldEnum | LivestockMetricScalarFieldEnum[]
  }

  /**
   * LivestockMetric findMany
   */
  export type LivestockMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivestockMetric
     */
    select?: LivestockMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivestockMetric
     */
    omit?: LivestockMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockMetricInclude<ExtArgs> | null
    /**
     * Filter, which LivestockMetrics to fetch.
     */
    where?: LivestockMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LivestockMetrics to fetch.
     */
    orderBy?: LivestockMetricOrderByWithRelationInput | LivestockMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LivestockMetrics.
     */
    cursor?: LivestockMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LivestockMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LivestockMetrics.
     */
    skip?: number
    distinct?: LivestockMetricScalarFieldEnum | LivestockMetricScalarFieldEnum[]
  }

  /**
   * LivestockMetric create
   */
  export type LivestockMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivestockMetric
     */
    select?: LivestockMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivestockMetric
     */
    omit?: LivestockMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a LivestockMetric.
     */
    data: XOR<LivestockMetricCreateInput, LivestockMetricUncheckedCreateInput>
  }

  /**
   * LivestockMetric createMany
   */
  export type LivestockMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LivestockMetrics.
     */
    data: LivestockMetricCreateManyInput | LivestockMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LivestockMetric createManyAndReturn
   */
  export type LivestockMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivestockMetric
     */
    select?: LivestockMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LivestockMetric
     */
    omit?: LivestockMetricOmit<ExtArgs> | null
    /**
     * The data used to create many LivestockMetrics.
     */
    data: LivestockMetricCreateManyInput | LivestockMetricCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LivestockMetric update
   */
  export type LivestockMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivestockMetric
     */
    select?: LivestockMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivestockMetric
     */
    omit?: LivestockMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a LivestockMetric.
     */
    data: XOR<LivestockMetricUpdateInput, LivestockMetricUncheckedUpdateInput>
    /**
     * Choose, which LivestockMetric to update.
     */
    where: LivestockMetricWhereUniqueInput
  }

  /**
   * LivestockMetric updateMany
   */
  export type LivestockMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LivestockMetrics.
     */
    data: XOR<LivestockMetricUpdateManyMutationInput, LivestockMetricUncheckedUpdateManyInput>
    /**
     * Filter which LivestockMetrics to update
     */
    where?: LivestockMetricWhereInput
    /**
     * Limit how many LivestockMetrics to update.
     */
    limit?: number
  }

  /**
   * LivestockMetric updateManyAndReturn
   */
  export type LivestockMetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivestockMetric
     */
    select?: LivestockMetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LivestockMetric
     */
    omit?: LivestockMetricOmit<ExtArgs> | null
    /**
     * The data used to update LivestockMetrics.
     */
    data: XOR<LivestockMetricUpdateManyMutationInput, LivestockMetricUncheckedUpdateManyInput>
    /**
     * Filter which LivestockMetrics to update
     */
    where?: LivestockMetricWhereInput
    /**
     * Limit how many LivestockMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockMetricIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LivestockMetric upsert
   */
  export type LivestockMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivestockMetric
     */
    select?: LivestockMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivestockMetric
     */
    omit?: LivestockMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the LivestockMetric to update in case it exists.
     */
    where: LivestockMetricWhereUniqueInput
    /**
     * In case the LivestockMetric found by the `where` argument doesn't exist, create a new LivestockMetric with this data.
     */
    create: XOR<LivestockMetricCreateInput, LivestockMetricUncheckedCreateInput>
    /**
     * In case the LivestockMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LivestockMetricUpdateInput, LivestockMetricUncheckedUpdateInput>
  }

  /**
   * LivestockMetric delete
   */
  export type LivestockMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivestockMetric
     */
    select?: LivestockMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivestockMetric
     */
    omit?: LivestockMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockMetricInclude<ExtArgs> | null
    /**
     * Filter which LivestockMetric to delete.
     */
    where: LivestockMetricWhereUniqueInput
  }

  /**
   * LivestockMetric deleteMany
   */
  export type LivestockMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LivestockMetrics to delete
     */
    where?: LivestockMetricWhereInput
    /**
     * Limit how many LivestockMetrics to delete.
     */
    limit?: number
  }

  /**
   * LivestockMetric without action
   */
  export type LivestockMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivestockMetric
     */
    select?: LivestockMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivestockMetric
     */
    omit?: LivestockMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivestockMetricInclude<ExtArgs> | null
  }


  /**
   * Model CropQualityLog
   */

  export type AggregateCropQualityLog = {
    _count: CropQualityLogCountAggregateOutputType | null
    _avg: CropQualityLogAvgAggregateOutputType | null
    _sum: CropQualityLogSumAggregateOutputType | null
    _min: CropQualityLogMinAggregateOutputType | null
    _max: CropQualityLogMaxAggregateOutputType | null
  }

  export type CropQualityLogAvgAggregateOutputType = {
    proteinPercent: number | null
    moisturePercent: number | null
    sugarPercent: number | null
    oilPercent: number | null
  }

  export type CropQualityLogSumAggregateOutputType = {
    proteinPercent: number | null
    moisturePercent: number | null
    sugarPercent: number | null
    oilPercent: number | null
  }

  export type CropQualityLogMinAggregateOutputType = {
    id: string | null
    cropId: string | null
    measuredAt: Date | null
    proteinPercent: number | null
    moisturePercent: number | null
    sugarPercent: number | null
    oilPercent: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type CropQualityLogMaxAggregateOutputType = {
    id: string | null
    cropId: string | null
    measuredAt: Date | null
    proteinPercent: number | null
    moisturePercent: number | null
    sugarPercent: number | null
    oilPercent: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type CropQualityLogCountAggregateOutputType = {
    id: number
    cropId: number
    measuredAt: number
    proteinPercent: number
    moisturePercent: number
    sugarPercent: number
    oilPercent: number
    notes: number
    createdAt: number
    _all: number
  }


  export type CropQualityLogAvgAggregateInputType = {
    proteinPercent?: true
    moisturePercent?: true
    sugarPercent?: true
    oilPercent?: true
  }

  export type CropQualityLogSumAggregateInputType = {
    proteinPercent?: true
    moisturePercent?: true
    sugarPercent?: true
    oilPercent?: true
  }

  export type CropQualityLogMinAggregateInputType = {
    id?: true
    cropId?: true
    measuredAt?: true
    proteinPercent?: true
    moisturePercent?: true
    sugarPercent?: true
    oilPercent?: true
    notes?: true
    createdAt?: true
  }

  export type CropQualityLogMaxAggregateInputType = {
    id?: true
    cropId?: true
    measuredAt?: true
    proteinPercent?: true
    moisturePercent?: true
    sugarPercent?: true
    oilPercent?: true
    notes?: true
    createdAt?: true
  }

  export type CropQualityLogCountAggregateInputType = {
    id?: true
    cropId?: true
    measuredAt?: true
    proteinPercent?: true
    moisturePercent?: true
    sugarPercent?: true
    oilPercent?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type CropQualityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CropQualityLog to aggregate.
     */
    where?: CropQualityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CropQualityLogs to fetch.
     */
    orderBy?: CropQualityLogOrderByWithRelationInput | CropQualityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CropQualityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CropQualityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CropQualityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CropQualityLogs
    **/
    _count?: true | CropQualityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CropQualityLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CropQualityLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CropQualityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CropQualityLogMaxAggregateInputType
  }

  export type GetCropQualityLogAggregateType<T extends CropQualityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateCropQualityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCropQualityLog[P]>
      : GetScalarType<T[P], AggregateCropQualityLog[P]>
  }




  export type CropQualityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CropQualityLogWhereInput
    orderBy?: CropQualityLogOrderByWithAggregationInput | CropQualityLogOrderByWithAggregationInput[]
    by: CropQualityLogScalarFieldEnum[] | CropQualityLogScalarFieldEnum
    having?: CropQualityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CropQualityLogCountAggregateInputType | true
    _avg?: CropQualityLogAvgAggregateInputType
    _sum?: CropQualityLogSumAggregateInputType
    _min?: CropQualityLogMinAggregateInputType
    _max?: CropQualityLogMaxAggregateInputType
  }

  export type CropQualityLogGroupByOutputType = {
    id: string
    cropId: string
    measuredAt: Date
    proteinPercent: number | null
    moisturePercent: number | null
    sugarPercent: number | null
    oilPercent: number | null
    notes: string | null
    createdAt: Date
    _count: CropQualityLogCountAggregateOutputType | null
    _avg: CropQualityLogAvgAggregateOutputType | null
    _sum: CropQualityLogSumAggregateOutputType | null
    _min: CropQualityLogMinAggregateOutputType | null
    _max: CropQualityLogMaxAggregateOutputType | null
  }

  type GetCropQualityLogGroupByPayload<T extends CropQualityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CropQualityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CropQualityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CropQualityLogGroupByOutputType[P]>
            : GetScalarType<T[P], CropQualityLogGroupByOutputType[P]>
        }
      >
    >


  export type CropQualityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cropId?: boolean
    measuredAt?: boolean
    proteinPercent?: boolean
    moisturePercent?: boolean
    sugarPercent?: boolean
    oilPercent?: boolean
    notes?: boolean
    createdAt?: boolean
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cropQualityLog"]>

  export type CropQualityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cropId?: boolean
    measuredAt?: boolean
    proteinPercent?: boolean
    moisturePercent?: boolean
    sugarPercent?: boolean
    oilPercent?: boolean
    notes?: boolean
    createdAt?: boolean
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cropQualityLog"]>

  export type CropQualityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cropId?: boolean
    measuredAt?: boolean
    proteinPercent?: boolean
    moisturePercent?: boolean
    sugarPercent?: boolean
    oilPercent?: boolean
    notes?: boolean
    createdAt?: boolean
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cropQualityLog"]>

  export type CropQualityLogSelectScalar = {
    id?: boolean
    cropId?: boolean
    measuredAt?: boolean
    proteinPercent?: boolean
    moisturePercent?: boolean
    sugarPercent?: boolean
    oilPercent?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type CropQualityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cropId" | "measuredAt" | "proteinPercent" | "moisturePercent" | "sugarPercent" | "oilPercent" | "notes" | "createdAt", ExtArgs["result"]["cropQualityLog"]>
  export type CropQualityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }
  export type CropQualityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }
  export type CropQualityLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }

  export type $CropQualityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CropQualityLog"
    objects: {
      crop: Prisma.$CropPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cropId: string
      measuredAt: Date
      proteinPercent: number | null
      moisturePercent: number | null
      sugarPercent: number | null
      oilPercent: number | null
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["cropQualityLog"]>
    composites: {}
  }

  type CropQualityLogGetPayload<S extends boolean | null | undefined | CropQualityLogDefaultArgs> = $Result.GetResult<Prisma.$CropQualityLogPayload, S>

  type CropQualityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CropQualityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CropQualityLogCountAggregateInputType | true
    }

  export interface CropQualityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CropQualityLog'], meta: { name: 'CropQualityLog' } }
    /**
     * Find zero or one CropQualityLog that matches the filter.
     * @param {CropQualityLogFindUniqueArgs} args - Arguments to find a CropQualityLog
     * @example
     * // Get one CropQualityLog
     * const cropQualityLog = await prisma.cropQualityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CropQualityLogFindUniqueArgs>(args: SelectSubset<T, CropQualityLogFindUniqueArgs<ExtArgs>>): Prisma__CropQualityLogClient<$Result.GetResult<Prisma.$CropQualityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CropQualityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CropQualityLogFindUniqueOrThrowArgs} args - Arguments to find a CropQualityLog
     * @example
     * // Get one CropQualityLog
     * const cropQualityLog = await prisma.cropQualityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CropQualityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, CropQualityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CropQualityLogClient<$Result.GetResult<Prisma.$CropQualityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CropQualityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropQualityLogFindFirstArgs} args - Arguments to find a CropQualityLog
     * @example
     * // Get one CropQualityLog
     * const cropQualityLog = await prisma.cropQualityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CropQualityLogFindFirstArgs>(args?: SelectSubset<T, CropQualityLogFindFirstArgs<ExtArgs>>): Prisma__CropQualityLogClient<$Result.GetResult<Prisma.$CropQualityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CropQualityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropQualityLogFindFirstOrThrowArgs} args - Arguments to find a CropQualityLog
     * @example
     * // Get one CropQualityLog
     * const cropQualityLog = await prisma.cropQualityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CropQualityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, CropQualityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__CropQualityLogClient<$Result.GetResult<Prisma.$CropQualityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CropQualityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropQualityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CropQualityLogs
     * const cropQualityLogs = await prisma.cropQualityLog.findMany()
     * 
     * // Get first 10 CropQualityLogs
     * const cropQualityLogs = await prisma.cropQualityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cropQualityLogWithIdOnly = await prisma.cropQualityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CropQualityLogFindManyArgs>(args?: SelectSubset<T, CropQualityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropQualityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CropQualityLog.
     * @param {CropQualityLogCreateArgs} args - Arguments to create a CropQualityLog.
     * @example
     * // Create one CropQualityLog
     * const CropQualityLog = await prisma.cropQualityLog.create({
     *   data: {
     *     // ... data to create a CropQualityLog
     *   }
     * })
     * 
     */
    create<T extends CropQualityLogCreateArgs>(args: SelectSubset<T, CropQualityLogCreateArgs<ExtArgs>>): Prisma__CropQualityLogClient<$Result.GetResult<Prisma.$CropQualityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CropQualityLogs.
     * @param {CropQualityLogCreateManyArgs} args - Arguments to create many CropQualityLogs.
     * @example
     * // Create many CropQualityLogs
     * const cropQualityLog = await prisma.cropQualityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CropQualityLogCreateManyArgs>(args?: SelectSubset<T, CropQualityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CropQualityLogs and returns the data saved in the database.
     * @param {CropQualityLogCreateManyAndReturnArgs} args - Arguments to create many CropQualityLogs.
     * @example
     * // Create many CropQualityLogs
     * const cropQualityLog = await prisma.cropQualityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CropQualityLogs and only return the `id`
     * const cropQualityLogWithIdOnly = await prisma.cropQualityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CropQualityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, CropQualityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropQualityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CropQualityLog.
     * @param {CropQualityLogDeleteArgs} args - Arguments to delete one CropQualityLog.
     * @example
     * // Delete one CropQualityLog
     * const CropQualityLog = await prisma.cropQualityLog.delete({
     *   where: {
     *     // ... filter to delete one CropQualityLog
     *   }
     * })
     * 
     */
    delete<T extends CropQualityLogDeleteArgs>(args: SelectSubset<T, CropQualityLogDeleteArgs<ExtArgs>>): Prisma__CropQualityLogClient<$Result.GetResult<Prisma.$CropQualityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CropQualityLog.
     * @param {CropQualityLogUpdateArgs} args - Arguments to update one CropQualityLog.
     * @example
     * // Update one CropQualityLog
     * const cropQualityLog = await prisma.cropQualityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CropQualityLogUpdateArgs>(args: SelectSubset<T, CropQualityLogUpdateArgs<ExtArgs>>): Prisma__CropQualityLogClient<$Result.GetResult<Prisma.$CropQualityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CropQualityLogs.
     * @param {CropQualityLogDeleteManyArgs} args - Arguments to filter CropQualityLogs to delete.
     * @example
     * // Delete a few CropQualityLogs
     * const { count } = await prisma.cropQualityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CropQualityLogDeleteManyArgs>(args?: SelectSubset<T, CropQualityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CropQualityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropQualityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CropQualityLogs
     * const cropQualityLog = await prisma.cropQualityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CropQualityLogUpdateManyArgs>(args: SelectSubset<T, CropQualityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CropQualityLogs and returns the data updated in the database.
     * @param {CropQualityLogUpdateManyAndReturnArgs} args - Arguments to update many CropQualityLogs.
     * @example
     * // Update many CropQualityLogs
     * const cropQualityLog = await prisma.cropQualityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CropQualityLogs and only return the `id`
     * const cropQualityLogWithIdOnly = await prisma.cropQualityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CropQualityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, CropQualityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropQualityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CropQualityLog.
     * @param {CropQualityLogUpsertArgs} args - Arguments to update or create a CropQualityLog.
     * @example
     * // Update or create a CropQualityLog
     * const cropQualityLog = await prisma.cropQualityLog.upsert({
     *   create: {
     *     // ... data to create a CropQualityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CropQualityLog we want to update
     *   }
     * })
     */
    upsert<T extends CropQualityLogUpsertArgs>(args: SelectSubset<T, CropQualityLogUpsertArgs<ExtArgs>>): Prisma__CropQualityLogClient<$Result.GetResult<Prisma.$CropQualityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CropQualityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropQualityLogCountArgs} args - Arguments to filter CropQualityLogs to count.
     * @example
     * // Count the number of CropQualityLogs
     * const count = await prisma.cropQualityLog.count({
     *   where: {
     *     // ... the filter for the CropQualityLogs we want to count
     *   }
     * })
    **/
    count<T extends CropQualityLogCountArgs>(
      args?: Subset<T, CropQualityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CropQualityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CropQualityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropQualityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CropQualityLogAggregateArgs>(args: Subset<T, CropQualityLogAggregateArgs>): Prisma.PrismaPromise<GetCropQualityLogAggregateType<T>>

    /**
     * Group by CropQualityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropQualityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CropQualityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CropQualityLogGroupByArgs['orderBy'] }
        : { orderBy?: CropQualityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CropQualityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCropQualityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CropQualityLog model
   */
  readonly fields: CropQualityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CropQualityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CropQualityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    crop<T extends CropDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CropDefaultArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CropQualityLog model
   */
  interface CropQualityLogFieldRefs {
    readonly id: FieldRef<"CropQualityLog", 'String'>
    readonly cropId: FieldRef<"CropQualityLog", 'String'>
    readonly measuredAt: FieldRef<"CropQualityLog", 'DateTime'>
    readonly proteinPercent: FieldRef<"CropQualityLog", 'Float'>
    readonly moisturePercent: FieldRef<"CropQualityLog", 'Float'>
    readonly sugarPercent: FieldRef<"CropQualityLog", 'Float'>
    readonly oilPercent: FieldRef<"CropQualityLog", 'Float'>
    readonly notes: FieldRef<"CropQualityLog", 'String'>
    readonly createdAt: FieldRef<"CropQualityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CropQualityLog findUnique
   */
  export type CropQualityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropQualityLog
     */
    select?: CropQualityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropQualityLog
     */
    omit?: CropQualityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropQualityLogInclude<ExtArgs> | null
    /**
     * Filter, which CropQualityLog to fetch.
     */
    where: CropQualityLogWhereUniqueInput
  }

  /**
   * CropQualityLog findUniqueOrThrow
   */
  export type CropQualityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropQualityLog
     */
    select?: CropQualityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropQualityLog
     */
    omit?: CropQualityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropQualityLogInclude<ExtArgs> | null
    /**
     * Filter, which CropQualityLog to fetch.
     */
    where: CropQualityLogWhereUniqueInput
  }

  /**
   * CropQualityLog findFirst
   */
  export type CropQualityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropQualityLog
     */
    select?: CropQualityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropQualityLog
     */
    omit?: CropQualityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropQualityLogInclude<ExtArgs> | null
    /**
     * Filter, which CropQualityLog to fetch.
     */
    where?: CropQualityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CropQualityLogs to fetch.
     */
    orderBy?: CropQualityLogOrderByWithRelationInput | CropQualityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CropQualityLogs.
     */
    cursor?: CropQualityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CropQualityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CropQualityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CropQualityLogs.
     */
    distinct?: CropQualityLogScalarFieldEnum | CropQualityLogScalarFieldEnum[]
  }

  /**
   * CropQualityLog findFirstOrThrow
   */
  export type CropQualityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropQualityLog
     */
    select?: CropQualityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropQualityLog
     */
    omit?: CropQualityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropQualityLogInclude<ExtArgs> | null
    /**
     * Filter, which CropQualityLog to fetch.
     */
    where?: CropQualityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CropQualityLogs to fetch.
     */
    orderBy?: CropQualityLogOrderByWithRelationInput | CropQualityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CropQualityLogs.
     */
    cursor?: CropQualityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CropQualityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CropQualityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CropQualityLogs.
     */
    distinct?: CropQualityLogScalarFieldEnum | CropQualityLogScalarFieldEnum[]
  }

  /**
   * CropQualityLog findMany
   */
  export type CropQualityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropQualityLog
     */
    select?: CropQualityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropQualityLog
     */
    omit?: CropQualityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropQualityLogInclude<ExtArgs> | null
    /**
     * Filter, which CropQualityLogs to fetch.
     */
    where?: CropQualityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CropQualityLogs to fetch.
     */
    orderBy?: CropQualityLogOrderByWithRelationInput | CropQualityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CropQualityLogs.
     */
    cursor?: CropQualityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CropQualityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CropQualityLogs.
     */
    skip?: number
    distinct?: CropQualityLogScalarFieldEnum | CropQualityLogScalarFieldEnum[]
  }

  /**
   * CropQualityLog create
   */
  export type CropQualityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropQualityLog
     */
    select?: CropQualityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropQualityLog
     */
    omit?: CropQualityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropQualityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a CropQualityLog.
     */
    data: XOR<CropQualityLogCreateInput, CropQualityLogUncheckedCreateInput>
  }

  /**
   * CropQualityLog createMany
   */
  export type CropQualityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CropQualityLogs.
     */
    data: CropQualityLogCreateManyInput | CropQualityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CropQualityLog createManyAndReturn
   */
  export type CropQualityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropQualityLog
     */
    select?: CropQualityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CropQualityLog
     */
    omit?: CropQualityLogOmit<ExtArgs> | null
    /**
     * The data used to create many CropQualityLogs.
     */
    data: CropQualityLogCreateManyInput | CropQualityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropQualityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CropQualityLog update
   */
  export type CropQualityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropQualityLog
     */
    select?: CropQualityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropQualityLog
     */
    omit?: CropQualityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropQualityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a CropQualityLog.
     */
    data: XOR<CropQualityLogUpdateInput, CropQualityLogUncheckedUpdateInput>
    /**
     * Choose, which CropQualityLog to update.
     */
    where: CropQualityLogWhereUniqueInput
  }

  /**
   * CropQualityLog updateMany
   */
  export type CropQualityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CropQualityLogs.
     */
    data: XOR<CropQualityLogUpdateManyMutationInput, CropQualityLogUncheckedUpdateManyInput>
    /**
     * Filter which CropQualityLogs to update
     */
    where?: CropQualityLogWhereInput
    /**
     * Limit how many CropQualityLogs to update.
     */
    limit?: number
  }

  /**
   * CropQualityLog updateManyAndReturn
   */
  export type CropQualityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropQualityLog
     */
    select?: CropQualityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CropQualityLog
     */
    omit?: CropQualityLogOmit<ExtArgs> | null
    /**
     * The data used to update CropQualityLogs.
     */
    data: XOR<CropQualityLogUpdateManyMutationInput, CropQualityLogUncheckedUpdateManyInput>
    /**
     * Filter which CropQualityLogs to update
     */
    where?: CropQualityLogWhereInput
    /**
     * Limit how many CropQualityLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropQualityLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CropQualityLog upsert
   */
  export type CropQualityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropQualityLog
     */
    select?: CropQualityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropQualityLog
     */
    omit?: CropQualityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropQualityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the CropQualityLog to update in case it exists.
     */
    where: CropQualityLogWhereUniqueInput
    /**
     * In case the CropQualityLog found by the `where` argument doesn't exist, create a new CropQualityLog with this data.
     */
    create: XOR<CropQualityLogCreateInput, CropQualityLogUncheckedCreateInput>
    /**
     * In case the CropQualityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CropQualityLogUpdateInput, CropQualityLogUncheckedUpdateInput>
  }

  /**
   * CropQualityLog delete
   */
  export type CropQualityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropQualityLog
     */
    select?: CropQualityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropQualityLog
     */
    omit?: CropQualityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropQualityLogInclude<ExtArgs> | null
    /**
     * Filter which CropQualityLog to delete.
     */
    where: CropQualityLogWhereUniqueInput
  }

  /**
   * CropQualityLog deleteMany
   */
  export type CropQualityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CropQualityLogs to delete
     */
    where?: CropQualityLogWhereInput
    /**
     * Limit how many CropQualityLogs to delete.
     */
    limit?: number
  }

  /**
   * CropQualityLog without action
   */
  export type CropQualityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropQualityLog
     */
    select?: CropQualityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropQualityLog
     */
    omit?: CropQualityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropQualityLogInclude<ExtArgs> | null
  }


  /**
   * Model CropMetric
   */

  export type AggregateCropMetric = {
    _count: CropMetricCountAggregateOutputType | null
    _min: CropMetricMinAggregateOutputType | null
    _max: CropMetricMaxAggregateOutputType | null
  }

  export type CropMetricMinAggregateOutputType = {
    id: string | null
    cropId: string | null
    key: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CropMetricMaxAggregateOutputType = {
    id: string | null
    cropId: string | null
    key: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CropMetricCountAggregateOutputType = {
    id: number
    cropId: number
    key: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CropMetricMinAggregateInputType = {
    id?: true
    cropId?: true
    key?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CropMetricMaxAggregateInputType = {
    id?: true
    cropId?: true
    key?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CropMetricCountAggregateInputType = {
    id?: true
    cropId?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CropMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CropMetric to aggregate.
     */
    where?: CropMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CropMetrics to fetch.
     */
    orderBy?: CropMetricOrderByWithRelationInput | CropMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CropMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CropMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CropMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CropMetrics
    **/
    _count?: true | CropMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CropMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CropMetricMaxAggregateInputType
  }

  export type GetCropMetricAggregateType<T extends CropMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateCropMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCropMetric[P]>
      : GetScalarType<T[P], AggregateCropMetric[P]>
  }




  export type CropMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CropMetricWhereInput
    orderBy?: CropMetricOrderByWithAggregationInput | CropMetricOrderByWithAggregationInput[]
    by: CropMetricScalarFieldEnum[] | CropMetricScalarFieldEnum
    having?: CropMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CropMetricCountAggregateInputType | true
    _min?: CropMetricMinAggregateInputType
    _max?: CropMetricMaxAggregateInputType
  }

  export type CropMetricGroupByOutputType = {
    id: string
    cropId: string
    key: string
    value: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CropMetricCountAggregateOutputType | null
    _min: CropMetricMinAggregateOutputType | null
    _max: CropMetricMaxAggregateOutputType | null
  }

  type GetCropMetricGroupByPayload<T extends CropMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CropMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CropMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CropMetricGroupByOutputType[P]>
            : GetScalarType<T[P], CropMetricGroupByOutputType[P]>
        }
      >
    >


  export type CropMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cropId?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cropMetric"]>

  export type CropMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cropId?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cropMetric"]>

  export type CropMetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cropId?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cropMetric"]>

  export type CropMetricSelectScalar = {
    id?: boolean
    cropId?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CropMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cropId" | "key" | "value" | "createdAt" | "updatedAt", ExtArgs["result"]["cropMetric"]>
  export type CropMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }
  export type CropMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }
  export type CropMetricIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crop?: boolean | CropDefaultArgs<ExtArgs>
  }

  export type $CropMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CropMetric"
    objects: {
      crop: Prisma.$CropPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cropId: string
      key: string
      value: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cropMetric"]>
    composites: {}
  }

  type CropMetricGetPayload<S extends boolean | null | undefined | CropMetricDefaultArgs> = $Result.GetResult<Prisma.$CropMetricPayload, S>

  type CropMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CropMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CropMetricCountAggregateInputType | true
    }

  export interface CropMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CropMetric'], meta: { name: 'CropMetric' } }
    /**
     * Find zero or one CropMetric that matches the filter.
     * @param {CropMetricFindUniqueArgs} args - Arguments to find a CropMetric
     * @example
     * // Get one CropMetric
     * const cropMetric = await prisma.cropMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CropMetricFindUniqueArgs>(args: SelectSubset<T, CropMetricFindUniqueArgs<ExtArgs>>): Prisma__CropMetricClient<$Result.GetResult<Prisma.$CropMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CropMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CropMetricFindUniqueOrThrowArgs} args - Arguments to find a CropMetric
     * @example
     * // Get one CropMetric
     * const cropMetric = await prisma.cropMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CropMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, CropMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CropMetricClient<$Result.GetResult<Prisma.$CropMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CropMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropMetricFindFirstArgs} args - Arguments to find a CropMetric
     * @example
     * // Get one CropMetric
     * const cropMetric = await prisma.cropMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CropMetricFindFirstArgs>(args?: SelectSubset<T, CropMetricFindFirstArgs<ExtArgs>>): Prisma__CropMetricClient<$Result.GetResult<Prisma.$CropMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CropMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropMetricFindFirstOrThrowArgs} args - Arguments to find a CropMetric
     * @example
     * // Get one CropMetric
     * const cropMetric = await prisma.cropMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CropMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, CropMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__CropMetricClient<$Result.GetResult<Prisma.$CropMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CropMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CropMetrics
     * const cropMetrics = await prisma.cropMetric.findMany()
     * 
     * // Get first 10 CropMetrics
     * const cropMetrics = await prisma.cropMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cropMetricWithIdOnly = await prisma.cropMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CropMetricFindManyArgs>(args?: SelectSubset<T, CropMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CropMetric.
     * @param {CropMetricCreateArgs} args - Arguments to create a CropMetric.
     * @example
     * // Create one CropMetric
     * const CropMetric = await prisma.cropMetric.create({
     *   data: {
     *     // ... data to create a CropMetric
     *   }
     * })
     * 
     */
    create<T extends CropMetricCreateArgs>(args: SelectSubset<T, CropMetricCreateArgs<ExtArgs>>): Prisma__CropMetricClient<$Result.GetResult<Prisma.$CropMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CropMetrics.
     * @param {CropMetricCreateManyArgs} args - Arguments to create many CropMetrics.
     * @example
     * // Create many CropMetrics
     * const cropMetric = await prisma.cropMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CropMetricCreateManyArgs>(args?: SelectSubset<T, CropMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CropMetrics and returns the data saved in the database.
     * @param {CropMetricCreateManyAndReturnArgs} args - Arguments to create many CropMetrics.
     * @example
     * // Create many CropMetrics
     * const cropMetric = await prisma.cropMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CropMetrics and only return the `id`
     * const cropMetricWithIdOnly = await prisma.cropMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CropMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, CropMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropMetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CropMetric.
     * @param {CropMetricDeleteArgs} args - Arguments to delete one CropMetric.
     * @example
     * // Delete one CropMetric
     * const CropMetric = await prisma.cropMetric.delete({
     *   where: {
     *     // ... filter to delete one CropMetric
     *   }
     * })
     * 
     */
    delete<T extends CropMetricDeleteArgs>(args: SelectSubset<T, CropMetricDeleteArgs<ExtArgs>>): Prisma__CropMetricClient<$Result.GetResult<Prisma.$CropMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CropMetric.
     * @param {CropMetricUpdateArgs} args - Arguments to update one CropMetric.
     * @example
     * // Update one CropMetric
     * const cropMetric = await prisma.cropMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CropMetricUpdateArgs>(args: SelectSubset<T, CropMetricUpdateArgs<ExtArgs>>): Prisma__CropMetricClient<$Result.GetResult<Prisma.$CropMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CropMetrics.
     * @param {CropMetricDeleteManyArgs} args - Arguments to filter CropMetrics to delete.
     * @example
     * // Delete a few CropMetrics
     * const { count } = await prisma.cropMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CropMetricDeleteManyArgs>(args?: SelectSubset<T, CropMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CropMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CropMetrics
     * const cropMetric = await prisma.cropMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CropMetricUpdateManyArgs>(args: SelectSubset<T, CropMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CropMetrics and returns the data updated in the database.
     * @param {CropMetricUpdateManyAndReturnArgs} args - Arguments to update many CropMetrics.
     * @example
     * // Update many CropMetrics
     * const cropMetric = await prisma.cropMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CropMetrics and only return the `id`
     * const cropMetricWithIdOnly = await prisma.cropMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CropMetricUpdateManyAndReturnArgs>(args: SelectSubset<T, CropMetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropMetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CropMetric.
     * @param {CropMetricUpsertArgs} args - Arguments to update or create a CropMetric.
     * @example
     * // Update or create a CropMetric
     * const cropMetric = await prisma.cropMetric.upsert({
     *   create: {
     *     // ... data to create a CropMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CropMetric we want to update
     *   }
     * })
     */
    upsert<T extends CropMetricUpsertArgs>(args: SelectSubset<T, CropMetricUpsertArgs<ExtArgs>>): Prisma__CropMetricClient<$Result.GetResult<Prisma.$CropMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CropMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropMetricCountArgs} args - Arguments to filter CropMetrics to count.
     * @example
     * // Count the number of CropMetrics
     * const count = await prisma.cropMetric.count({
     *   where: {
     *     // ... the filter for the CropMetrics we want to count
     *   }
     * })
    **/
    count<T extends CropMetricCountArgs>(
      args?: Subset<T, CropMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CropMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CropMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CropMetricAggregateArgs>(args: Subset<T, CropMetricAggregateArgs>): Prisma.PrismaPromise<GetCropMetricAggregateType<T>>

    /**
     * Group by CropMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CropMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CropMetricGroupByArgs['orderBy'] }
        : { orderBy?: CropMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CropMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCropMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CropMetric model
   */
  readonly fields: CropMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CropMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CropMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    crop<T extends CropDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CropDefaultArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CropMetric model
   */
  interface CropMetricFieldRefs {
    readonly id: FieldRef<"CropMetric", 'String'>
    readonly cropId: FieldRef<"CropMetric", 'String'>
    readonly key: FieldRef<"CropMetric", 'String'>
    readonly value: FieldRef<"CropMetric", 'Json'>
    readonly createdAt: FieldRef<"CropMetric", 'DateTime'>
    readonly updatedAt: FieldRef<"CropMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CropMetric findUnique
   */
  export type CropMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropMetric
     */
    select?: CropMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropMetric
     */
    omit?: CropMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropMetricInclude<ExtArgs> | null
    /**
     * Filter, which CropMetric to fetch.
     */
    where: CropMetricWhereUniqueInput
  }

  /**
   * CropMetric findUniqueOrThrow
   */
  export type CropMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropMetric
     */
    select?: CropMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropMetric
     */
    omit?: CropMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropMetricInclude<ExtArgs> | null
    /**
     * Filter, which CropMetric to fetch.
     */
    where: CropMetricWhereUniqueInput
  }

  /**
   * CropMetric findFirst
   */
  export type CropMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropMetric
     */
    select?: CropMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropMetric
     */
    omit?: CropMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropMetricInclude<ExtArgs> | null
    /**
     * Filter, which CropMetric to fetch.
     */
    where?: CropMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CropMetrics to fetch.
     */
    orderBy?: CropMetricOrderByWithRelationInput | CropMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CropMetrics.
     */
    cursor?: CropMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CropMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CropMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CropMetrics.
     */
    distinct?: CropMetricScalarFieldEnum | CropMetricScalarFieldEnum[]
  }

  /**
   * CropMetric findFirstOrThrow
   */
  export type CropMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropMetric
     */
    select?: CropMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropMetric
     */
    omit?: CropMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropMetricInclude<ExtArgs> | null
    /**
     * Filter, which CropMetric to fetch.
     */
    where?: CropMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CropMetrics to fetch.
     */
    orderBy?: CropMetricOrderByWithRelationInput | CropMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CropMetrics.
     */
    cursor?: CropMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CropMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CropMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CropMetrics.
     */
    distinct?: CropMetricScalarFieldEnum | CropMetricScalarFieldEnum[]
  }

  /**
   * CropMetric findMany
   */
  export type CropMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropMetric
     */
    select?: CropMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropMetric
     */
    omit?: CropMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropMetricInclude<ExtArgs> | null
    /**
     * Filter, which CropMetrics to fetch.
     */
    where?: CropMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CropMetrics to fetch.
     */
    orderBy?: CropMetricOrderByWithRelationInput | CropMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CropMetrics.
     */
    cursor?: CropMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CropMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CropMetrics.
     */
    skip?: number
    distinct?: CropMetricScalarFieldEnum | CropMetricScalarFieldEnum[]
  }

  /**
   * CropMetric create
   */
  export type CropMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropMetric
     */
    select?: CropMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropMetric
     */
    omit?: CropMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a CropMetric.
     */
    data: XOR<CropMetricCreateInput, CropMetricUncheckedCreateInput>
  }

  /**
   * CropMetric createMany
   */
  export type CropMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CropMetrics.
     */
    data: CropMetricCreateManyInput | CropMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CropMetric createManyAndReturn
   */
  export type CropMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropMetric
     */
    select?: CropMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CropMetric
     */
    omit?: CropMetricOmit<ExtArgs> | null
    /**
     * The data used to create many CropMetrics.
     */
    data: CropMetricCreateManyInput | CropMetricCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CropMetric update
   */
  export type CropMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropMetric
     */
    select?: CropMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropMetric
     */
    omit?: CropMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a CropMetric.
     */
    data: XOR<CropMetricUpdateInput, CropMetricUncheckedUpdateInput>
    /**
     * Choose, which CropMetric to update.
     */
    where: CropMetricWhereUniqueInput
  }

  /**
   * CropMetric updateMany
   */
  export type CropMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CropMetrics.
     */
    data: XOR<CropMetricUpdateManyMutationInput, CropMetricUncheckedUpdateManyInput>
    /**
     * Filter which CropMetrics to update
     */
    where?: CropMetricWhereInput
    /**
     * Limit how many CropMetrics to update.
     */
    limit?: number
  }

  /**
   * CropMetric updateManyAndReturn
   */
  export type CropMetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropMetric
     */
    select?: CropMetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CropMetric
     */
    omit?: CropMetricOmit<ExtArgs> | null
    /**
     * The data used to update CropMetrics.
     */
    data: XOR<CropMetricUpdateManyMutationInput, CropMetricUncheckedUpdateManyInput>
    /**
     * Filter which CropMetrics to update
     */
    where?: CropMetricWhereInput
    /**
     * Limit how many CropMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropMetricIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CropMetric upsert
   */
  export type CropMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropMetric
     */
    select?: CropMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropMetric
     */
    omit?: CropMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the CropMetric to update in case it exists.
     */
    where: CropMetricWhereUniqueInput
    /**
     * In case the CropMetric found by the `where` argument doesn't exist, create a new CropMetric with this data.
     */
    create: XOR<CropMetricCreateInput, CropMetricUncheckedCreateInput>
    /**
     * In case the CropMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CropMetricUpdateInput, CropMetricUncheckedUpdateInput>
  }

  /**
   * CropMetric delete
   */
  export type CropMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropMetric
     */
    select?: CropMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropMetric
     */
    omit?: CropMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropMetricInclude<ExtArgs> | null
    /**
     * Filter which CropMetric to delete.
     */
    where: CropMetricWhereUniqueInput
  }

  /**
   * CropMetric deleteMany
   */
  export type CropMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CropMetrics to delete
     */
    where?: CropMetricWhereInput
    /**
     * Limit how many CropMetrics to delete.
     */
    limit?: number
  }

  /**
   * CropMetric without action
   */
  export type CropMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropMetric
     */
    select?: CropMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CropMetric
     */
    omit?: CropMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropMetricInclude<ExtArgs> | null
  }


  /**
   * Model SupportProgram
   */

  export type AggregateSupportProgram = {
    _count: SupportProgramCountAggregateOutputType | null
    _avg: SupportProgramAvgAggregateOutputType | null
    _sum: SupportProgramSumAggregateOutputType | null
    _min: SupportProgramMinAggregateOutputType | null
    _max: SupportProgramMaxAggregateOutputType | null
  }

  export type SupportProgramAvgAggregateOutputType = {
    priority: number | null
  }

  export type SupportProgramSumAggregateOutputType = {
    priority: number | null
  }

  export type SupportProgramMinAggregateOutputType = {
    id: string | null
    title: string | null
    titleEn: string | null
    description: string | null
    descriptionEn: string | null
    category: string | null
    subcategory: string | null
    amount: string | null
    amountEn: string | null
    eligibility: string | null
    eligibilityEn: string | null
    requiredDocs: string | null
    requiredDocsEn: string | null
    applicationStart: Date | null
    applicationDeadline: Date | null
    link: string | null
    status: string | null
    targetCrops: string | null
    targetLivestock: string | null
    region: string | null
    priority: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupportProgramMaxAggregateOutputType = {
    id: string | null
    title: string | null
    titleEn: string | null
    description: string | null
    descriptionEn: string | null
    category: string | null
    subcategory: string | null
    amount: string | null
    amountEn: string | null
    eligibility: string | null
    eligibilityEn: string | null
    requiredDocs: string | null
    requiredDocsEn: string | null
    applicationStart: Date | null
    applicationDeadline: Date | null
    link: string | null
    status: string | null
    targetCrops: string | null
    targetLivestock: string | null
    region: string | null
    priority: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupportProgramCountAggregateOutputType = {
    id: number
    title: number
    titleEn: number
    description: number
    descriptionEn: number
    category: number
    subcategory: number
    amount: number
    amountEn: number
    eligibility: number
    eligibilityEn: number
    requiredDocs: number
    requiredDocsEn: number
    applicationStart: number
    applicationDeadline: number
    link: number
    status: number
    targetCrops: number
    targetLivestock: number
    region: number
    priority: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupportProgramAvgAggregateInputType = {
    priority?: true
  }

  export type SupportProgramSumAggregateInputType = {
    priority?: true
  }

  export type SupportProgramMinAggregateInputType = {
    id?: true
    title?: true
    titleEn?: true
    description?: true
    descriptionEn?: true
    category?: true
    subcategory?: true
    amount?: true
    amountEn?: true
    eligibility?: true
    eligibilityEn?: true
    requiredDocs?: true
    requiredDocsEn?: true
    applicationStart?: true
    applicationDeadline?: true
    link?: true
    status?: true
    targetCrops?: true
    targetLivestock?: true
    region?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupportProgramMaxAggregateInputType = {
    id?: true
    title?: true
    titleEn?: true
    description?: true
    descriptionEn?: true
    category?: true
    subcategory?: true
    amount?: true
    amountEn?: true
    eligibility?: true
    eligibilityEn?: true
    requiredDocs?: true
    requiredDocsEn?: true
    applicationStart?: true
    applicationDeadline?: true
    link?: true
    status?: true
    targetCrops?: true
    targetLivestock?: true
    region?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupportProgramCountAggregateInputType = {
    id?: true
    title?: true
    titleEn?: true
    description?: true
    descriptionEn?: true
    category?: true
    subcategory?: true
    amount?: true
    amountEn?: true
    eligibility?: true
    eligibilityEn?: true
    requiredDocs?: true
    requiredDocsEn?: true
    applicationStart?: true
    applicationDeadline?: true
    link?: true
    status?: true
    targetCrops?: true
    targetLivestock?: true
    region?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupportProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportProgram to aggregate.
     */
    where?: SupportProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportPrograms to fetch.
     */
    orderBy?: SupportProgramOrderByWithRelationInput | SupportProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupportProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupportPrograms
    **/
    _count?: true | SupportProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupportProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupportProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupportProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupportProgramMaxAggregateInputType
  }

  export type GetSupportProgramAggregateType<T extends SupportProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateSupportProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupportProgram[P]>
      : GetScalarType<T[P], AggregateSupportProgram[P]>
  }




  export type SupportProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportProgramWhereInput
    orderBy?: SupportProgramOrderByWithAggregationInput | SupportProgramOrderByWithAggregationInput[]
    by: SupportProgramScalarFieldEnum[] | SupportProgramScalarFieldEnum
    having?: SupportProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupportProgramCountAggregateInputType | true
    _avg?: SupportProgramAvgAggregateInputType
    _sum?: SupportProgramSumAggregateInputType
    _min?: SupportProgramMinAggregateInputType
    _max?: SupportProgramMaxAggregateInputType
  }

  export type SupportProgramGroupByOutputType = {
    id: string
    title: string
    titleEn: string | null
    description: string | null
    descriptionEn: string | null
    category: string
    subcategory: string | null
    amount: string | null
    amountEn: string | null
    eligibility: string | null
    eligibilityEn: string | null
    requiredDocs: string | null
    requiredDocsEn: string | null
    applicationStart: Date | null
    applicationDeadline: Date | null
    link: string | null
    status: string
    targetCrops: string | null
    targetLivestock: string | null
    region: string | null
    priority: number
    createdAt: Date
    updatedAt: Date
    _count: SupportProgramCountAggregateOutputType | null
    _avg: SupportProgramAvgAggregateOutputType | null
    _sum: SupportProgramSumAggregateOutputType | null
    _min: SupportProgramMinAggregateOutputType | null
    _max: SupportProgramMaxAggregateOutputType | null
  }

  type GetSupportProgramGroupByPayload<T extends SupportProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupportProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupportProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupportProgramGroupByOutputType[P]>
            : GetScalarType<T[P], SupportProgramGroupByOutputType[P]>
        }
      >
    >


  export type SupportProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    titleEn?: boolean
    description?: boolean
    descriptionEn?: boolean
    category?: boolean
    subcategory?: boolean
    amount?: boolean
    amountEn?: boolean
    eligibility?: boolean
    eligibilityEn?: boolean
    requiredDocs?: boolean
    requiredDocsEn?: boolean
    applicationStart?: boolean
    applicationDeadline?: boolean
    link?: boolean
    status?: boolean
    targetCrops?: boolean
    targetLivestock?: boolean
    region?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["supportProgram"]>

  export type SupportProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    titleEn?: boolean
    description?: boolean
    descriptionEn?: boolean
    category?: boolean
    subcategory?: boolean
    amount?: boolean
    amountEn?: boolean
    eligibility?: boolean
    eligibilityEn?: boolean
    requiredDocs?: boolean
    requiredDocsEn?: boolean
    applicationStart?: boolean
    applicationDeadline?: boolean
    link?: boolean
    status?: boolean
    targetCrops?: boolean
    targetLivestock?: boolean
    region?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["supportProgram"]>

  export type SupportProgramSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    titleEn?: boolean
    description?: boolean
    descriptionEn?: boolean
    category?: boolean
    subcategory?: boolean
    amount?: boolean
    amountEn?: boolean
    eligibility?: boolean
    eligibilityEn?: boolean
    requiredDocs?: boolean
    requiredDocsEn?: boolean
    applicationStart?: boolean
    applicationDeadline?: boolean
    link?: boolean
    status?: boolean
    targetCrops?: boolean
    targetLivestock?: boolean
    region?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["supportProgram"]>

  export type SupportProgramSelectScalar = {
    id?: boolean
    title?: boolean
    titleEn?: boolean
    description?: boolean
    descriptionEn?: boolean
    category?: boolean
    subcategory?: boolean
    amount?: boolean
    amountEn?: boolean
    eligibility?: boolean
    eligibilityEn?: boolean
    requiredDocs?: boolean
    requiredDocsEn?: boolean
    applicationStart?: boolean
    applicationDeadline?: boolean
    link?: boolean
    status?: boolean
    targetCrops?: boolean
    targetLivestock?: boolean
    region?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupportProgramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "titleEn" | "description" | "descriptionEn" | "category" | "subcategory" | "amount" | "amountEn" | "eligibility" | "eligibilityEn" | "requiredDocs" | "requiredDocsEn" | "applicationStart" | "applicationDeadline" | "link" | "status" | "targetCrops" | "targetLivestock" | "region" | "priority" | "createdAt" | "updatedAt", ExtArgs["result"]["supportProgram"]>

  export type $SupportProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupportProgram"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      titleEn: string | null
      description: string | null
      descriptionEn: string | null
      category: string
      subcategory: string | null
      amount: string | null
      amountEn: string | null
      eligibility: string | null
      eligibilityEn: string | null
      requiredDocs: string | null
      requiredDocsEn: string | null
      applicationStart: Date | null
      applicationDeadline: Date | null
      link: string | null
      status: string
      targetCrops: string | null
      targetLivestock: string | null
      region: string | null
      priority: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supportProgram"]>
    composites: {}
  }

  type SupportProgramGetPayload<S extends boolean | null | undefined | SupportProgramDefaultArgs> = $Result.GetResult<Prisma.$SupportProgramPayload, S>

  type SupportProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupportProgramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupportProgramCountAggregateInputType | true
    }

  export interface SupportProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupportProgram'], meta: { name: 'SupportProgram' } }
    /**
     * Find zero or one SupportProgram that matches the filter.
     * @param {SupportProgramFindUniqueArgs} args - Arguments to find a SupportProgram
     * @example
     * // Get one SupportProgram
     * const supportProgram = await prisma.supportProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupportProgramFindUniqueArgs>(args: SelectSubset<T, SupportProgramFindUniqueArgs<ExtArgs>>): Prisma__SupportProgramClient<$Result.GetResult<Prisma.$SupportProgramPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupportProgram that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupportProgramFindUniqueOrThrowArgs} args - Arguments to find a SupportProgram
     * @example
     * // Get one SupportProgram
     * const supportProgram = await prisma.supportProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupportProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, SupportProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupportProgramClient<$Result.GetResult<Prisma.$SupportProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportProgramFindFirstArgs} args - Arguments to find a SupportProgram
     * @example
     * // Get one SupportProgram
     * const supportProgram = await prisma.supportProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupportProgramFindFirstArgs>(args?: SelectSubset<T, SupportProgramFindFirstArgs<ExtArgs>>): Prisma__SupportProgramClient<$Result.GetResult<Prisma.$SupportProgramPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportProgram that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportProgramFindFirstOrThrowArgs} args - Arguments to find a SupportProgram
     * @example
     * // Get one SupportProgram
     * const supportProgram = await prisma.supportProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupportProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, SupportProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupportProgramClient<$Result.GetResult<Prisma.$SupportProgramPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupportPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupportPrograms
     * const supportPrograms = await prisma.supportProgram.findMany()
     * 
     * // Get first 10 SupportPrograms
     * const supportPrograms = await prisma.supportProgram.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supportProgramWithIdOnly = await prisma.supportProgram.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupportProgramFindManyArgs>(args?: SelectSubset<T, SupportProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupportProgram.
     * @param {SupportProgramCreateArgs} args - Arguments to create a SupportProgram.
     * @example
     * // Create one SupportProgram
     * const SupportProgram = await prisma.supportProgram.create({
     *   data: {
     *     // ... data to create a SupportProgram
     *   }
     * })
     * 
     */
    create<T extends SupportProgramCreateArgs>(args: SelectSubset<T, SupportProgramCreateArgs<ExtArgs>>): Prisma__SupportProgramClient<$Result.GetResult<Prisma.$SupportProgramPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupportPrograms.
     * @param {SupportProgramCreateManyArgs} args - Arguments to create many SupportPrograms.
     * @example
     * // Create many SupportPrograms
     * const supportProgram = await prisma.supportProgram.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupportProgramCreateManyArgs>(args?: SelectSubset<T, SupportProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupportPrograms and returns the data saved in the database.
     * @param {SupportProgramCreateManyAndReturnArgs} args - Arguments to create many SupportPrograms.
     * @example
     * // Create many SupportPrograms
     * const supportProgram = await prisma.supportProgram.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupportPrograms and only return the `id`
     * const supportProgramWithIdOnly = await prisma.supportProgram.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupportProgramCreateManyAndReturnArgs>(args?: SelectSubset<T, SupportProgramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportProgramPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupportProgram.
     * @param {SupportProgramDeleteArgs} args - Arguments to delete one SupportProgram.
     * @example
     * // Delete one SupportProgram
     * const SupportProgram = await prisma.supportProgram.delete({
     *   where: {
     *     // ... filter to delete one SupportProgram
     *   }
     * })
     * 
     */
    delete<T extends SupportProgramDeleteArgs>(args: SelectSubset<T, SupportProgramDeleteArgs<ExtArgs>>): Prisma__SupportProgramClient<$Result.GetResult<Prisma.$SupportProgramPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupportProgram.
     * @param {SupportProgramUpdateArgs} args - Arguments to update one SupportProgram.
     * @example
     * // Update one SupportProgram
     * const supportProgram = await prisma.supportProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupportProgramUpdateArgs>(args: SelectSubset<T, SupportProgramUpdateArgs<ExtArgs>>): Prisma__SupportProgramClient<$Result.GetResult<Prisma.$SupportProgramPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupportPrograms.
     * @param {SupportProgramDeleteManyArgs} args - Arguments to filter SupportPrograms to delete.
     * @example
     * // Delete a few SupportPrograms
     * const { count } = await prisma.supportProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupportProgramDeleteManyArgs>(args?: SelectSubset<T, SupportProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupportPrograms
     * const supportProgram = await prisma.supportProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupportProgramUpdateManyArgs>(args: SelectSubset<T, SupportProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportPrograms and returns the data updated in the database.
     * @param {SupportProgramUpdateManyAndReturnArgs} args - Arguments to update many SupportPrograms.
     * @example
     * // Update many SupportPrograms
     * const supportProgram = await prisma.supportProgram.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupportPrograms and only return the `id`
     * const supportProgramWithIdOnly = await prisma.supportProgram.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupportProgramUpdateManyAndReturnArgs>(args: SelectSubset<T, SupportProgramUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportProgramPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupportProgram.
     * @param {SupportProgramUpsertArgs} args - Arguments to update or create a SupportProgram.
     * @example
     * // Update or create a SupportProgram
     * const supportProgram = await prisma.supportProgram.upsert({
     *   create: {
     *     // ... data to create a SupportProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupportProgram we want to update
     *   }
     * })
     */
    upsert<T extends SupportProgramUpsertArgs>(args: SelectSubset<T, SupportProgramUpsertArgs<ExtArgs>>): Prisma__SupportProgramClient<$Result.GetResult<Prisma.$SupportProgramPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupportPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportProgramCountArgs} args - Arguments to filter SupportPrograms to count.
     * @example
     * // Count the number of SupportPrograms
     * const count = await prisma.supportProgram.count({
     *   where: {
     *     // ... the filter for the SupportPrograms we want to count
     *   }
     * })
    **/
    count<T extends SupportProgramCountArgs>(
      args?: Subset<T, SupportProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupportProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupportProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupportProgramAggregateArgs>(args: Subset<T, SupportProgramAggregateArgs>): Prisma.PrismaPromise<GetSupportProgramAggregateType<T>>

    /**
     * Group by SupportProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupportProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupportProgramGroupByArgs['orderBy'] }
        : { orderBy?: SupportProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupportProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupportProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupportProgram model
   */
  readonly fields: SupportProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupportProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupportProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupportProgram model
   */
  interface SupportProgramFieldRefs {
    readonly id: FieldRef<"SupportProgram", 'String'>
    readonly title: FieldRef<"SupportProgram", 'String'>
    readonly titleEn: FieldRef<"SupportProgram", 'String'>
    readonly description: FieldRef<"SupportProgram", 'String'>
    readonly descriptionEn: FieldRef<"SupportProgram", 'String'>
    readonly category: FieldRef<"SupportProgram", 'String'>
    readonly subcategory: FieldRef<"SupportProgram", 'String'>
    readonly amount: FieldRef<"SupportProgram", 'String'>
    readonly amountEn: FieldRef<"SupportProgram", 'String'>
    readonly eligibility: FieldRef<"SupportProgram", 'String'>
    readonly eligibilityEn: FieldRef<"SupportProgram", 'String'>
    readonly requiredDocs: FieldRef<"SupportProgram", 'String'>
    readonly requiredDocsEn: FieldRef<"SupportProgram", 'String'>
    readonly applicationStart: FieldRef<"SupportProgram", 'DateTime'>
    readonly applicationDeadline: FieldRef<"SupportProgram", 'DateTime'>
    readonly link: FieldRef<"SupportProgram", 'String'>
    readonly status: FieldRef<"SupportProgram", 'String'>
    readonly targetCrops: FieldRef<"SupportProgram", 'String'>
    readonly targetLivestock: FieldRef<"SupportProgram", 'String'>
    readonly region: FieldRef<"SupportProgram", 'String'>
    readonly priority: FieldRef<"SupportProgram", 'Int'>
    readonly createdAt: FieldRef<"SupportProgram", 'DateTime'>
    readonly updatedAt: FieldRef<"SupportProgram", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupportProgram findUnique
   */
  export type SupportProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportProgram
     */
    select?: SupportProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportProgram
     */
    omit?: SupportProgramOmit<ExtArgs> | null
    /**
     * Filter, which SupportProgram to fetch.
     */
    where: SupportProgramWhereUniqueInput
  }

  /**
   * SupportProgram findUniqueOrThrow
   */
  export type SupportProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportProgram
     */
    select?: SupportProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportProgram
     */
    omit?: SupportProgramOmit<ExtArgs> | null
    /**
     * Filter, which SupportProgram to fetch.
     */
    where: SupportProgramWhereUniqueInput
  }

  /**
   * SupportProgram findFirst
   */
  export type SupportProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportProgram
     */
    select?: SupportProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportProgram
     */
    omit?: SupportProgramOmit<ExtArgs> | null
    /**
     * Filter, which SupportProgram to fetch.
     */
    where?: SupportProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportPrograms to fetch.
     */
    orderBy?: SupportProgramOrderByWithRelationInput | SupportProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportPrograms.
     */
    cursor?: SupportProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportPrograms.
     */
    distinct?: SupportProgramScalarFieldEnum | SupportProgramScalarFieldEnum[]
  }

  /**
   * SupportProgram findFirstOrThrow
   */
  export type SupportProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportProgram
     */
    select?: SupportProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportProgram
     */
    omit?: SupportProgramOmit<ExtArgs> | null
    /**
     * Filter, which SupportProgram to fetch.
     */
    where?: SupportProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportPrograms to fetch.
     */
    orderBy?: SupportProgramOrderByWithRelationInput | SupportProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportPrograms.
     */
    cursor?: SupportProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportPrograms.
     */
    distinct?: SupportProgramScalarFieldEnum | SupportProgramScalarFieldEnum[]
  }

  /**
   * SupportProgram findMany
   */
  export type SupportProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportProgram
     */
    select?: SupportProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportProgram
     */
    omit?: SupportProgramOmit<ExtArgs> | null
    /**
     * Filter, which SupportPrograms to fetch.
     */
    where?: SupportProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportPrograms to fetch.
     */
    orderBy?: SupportProgramOrderByWithRelationInput | SupportProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupportPrograms.
     */
    cursor?: SupportProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportPrograms.
     */
    skip?: number
    distinct?: SupportProgramScalarFieldEnum | SupportProgramScalarFieldEnum[]
  }

  /**
   * SupportProgram create
   */
  export type SupportProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportProgram
     */
    select?: SupportProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportProgram
     */
    omit?: SupportProgramOmit<ExtArgs> | null
    /**
     * The data needed to create a SupportProgram.
     */
    data: XOR<SupportProgramCreateInput, SupportProgramUncheckedCreateInput>
  }

  /**
   * SupportProgram createMany
   */
  export type SupportProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupportPrograms.
     */
    data: SupportProgramCreateManyInput | SupportProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupportProgram createManyAndReturn
   */
  export type SupportProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportProgram
     */
    select?: SupportProgramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportProgram
     */
    omit?: SupportProgramOmit<ExtArgs> | null
    /**
     * The data used to create many SupportPrograms.
     */
    data: SupportProgramCreateManyInput | SupportProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupportProgram update
   */
  export type SupportProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportProgram
     */
    select?: SupportProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportProgram
     */
    omit?: SupportProgramOmit<ExtArgs> | null
    /**
     * The data needed to update a SupportProgram.
     */
    data: XOR<SupportProgramUpdateInput, SupportProgramUncheckedUpdateInput>
    /**
     * Choose, which SupportProgram to update.
     */
    where: SupportProgramWhereUniqueInput
  }

  /**
   * SupportProgram updateMany
   */
  export type SupportProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupportPrograms.
     */
    data: XOR<SupportProgramUpdateManyMutationInput, SupportProgramUncheckedUpdateManyInput>
    /**
     * Filter which SupportPrograms to update
     */
    where?: SupportProgramWhereInput
    /**
     * Limit how many SupportPrograms to update.
     */
    limit?: number
  }

  /**
   * SupportProgram updateManyAndReturn
   */
  export type SupportProgramUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportProgram
     */
    select?: SupportProgramSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportProgram
     */
    omit?: SupportProgramOmit<ExtArgs> | null
    /**
     * The data used to update SupportPrograms.
     */
    data: XOR<SupportProgramUpdateManyMutationInput, SupportProgramUncheckedUpdateManyInput>
    /**
     * Filter which SupportPrograms to update
     */
    where?: SupportProgramWhereInput
    /**
     * Limit how many SupportPrograms to update.
     */
    limit?: number
  }

  /**
   * SupportProgram upsert
   */
  export type SupportProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportProgram
     */
    select?: SupportProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportProgram
     */
    omit?: SupportProgramOmit<ExtArgs> | null
    /**
     * The filter to search for the SupportProgram to update in case it exists.
     */
    where: SupportProgramWhereUniqueInput
    /**
     * In case the SupportProgram found by the `where` argument doesn't exist, create a new SupportProgram with this data.
     */
    create: XOR<SupportProgramCreateInput, SupportProgramUncheckedCreateInput>
    /**
     * In case the SupportProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupportProgramUpdateInput, SupportProgramUncheckedUpdateInput>
  }

  /**
   * SupportProgram delete
   */
  export type SupportProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportProgram
     */
    select?: SupportProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportProgram
     */
    omit?: SupportProgramOmit<ExtArgs> | null
    /**
     * Filter which SupportProgram to delete.
     */
    where: SupportProgramWhereUniqueInput
  }

  /**
   * SupportProgram deleteMany
   */
  export type SupportProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportPrograms to delete
     */
    where?: SupportProgramWhereInput
    /**
     * Limit how many SupportPrograms to delete.
     */
    limit?: number
  }

  /**
   * SupportProgram without action
   */
  export type SupportProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportProgram
     */
    select?: SupportProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportProgram
     */
    omit?: SupportProgramOmit<ExtArgs> | null
  }


  /**
   * Model WeatherAlert
   */

  export type AggregateWeatherAlert = {
    _count: WeatherAlertCountAggregateOutputType | null
    _min: WeatherAlertMinAggregateOutputType | null
    _max: WeatherAlertMaxAggregateOutputType | null
  }

  export type WeatherAlertMinAggregateOutputType = {
    id: string | null
    alertType: string | null
    description: string | null
    startsAt: Date | null
    expiresAt: Date | null
    region: string | null
    createdAt: Date | null
  }

  export type WeatherAlertMaxAggregateOutputType = {
    id: string | null
    alertType: string | null
    description: string | null
    startsAt: Date | null
    expiresAt: Date | null
    region: string | null
    createdAt: Date | null
  }

  export type WeatherAlertCountAggregateOutputType = {
    id: number
    alertType: number
    description: number
    startsAt: number
    expiresAt: number
    region: number
    createdAt: number
    _all: number
  }


  export type WeatherAlertMinAggregateInputType = {
    id?: true
    alertType?: true
    description?: true
    startsAt?: true
    expiresAt?: true
    region?: true
    createdAt?: true
  }

  export type WeatherAlertMaxAggregateInputType = {
    id?: true
    alertType?: true
    description?: true
    startsAt?: true
    expiresAt?: true
    region?: true
    createdAt?: true
  }

  export type WeatherAlertCountAggregateInputType = {
    id?: true
    alertType?: true
    description?: true
    startsAt?: true
    expiresAt?: true
    region?: true
    createdAt?: true
    _all?: true
  }

  export type WeatherAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeatherAlert to aggregate.
     */
    where?: WeatherAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherAlerts to fetch.
     */
    orderBy?: WeatherAlertOrderByWithRelationInput | WeatherAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeatherAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeatherAlerts
    **/
    _count?: true | WeatherAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeatherAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeatherAlertMaxAggregateInputType
  }

  export type GetWeatherAlertAggregateType<T extends WeatherAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateWeatherAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeatherAlert[P]>
      : GetScalarType<T[P], AggregateWeatherAlert[P]>
  }




  export type WeatherAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeatherAlertWhereInput
    orderBy?: WeatherAlertOrderByWithAggregationInput | WeatherAlertOrderByWithAggregationInput[]
    by: WeatherAlertScalarFieldEnum[] | WeatherAlertScalarFieldEnum
    having?: WeatherAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeatherAlertCountAggregateInputType | true
    _min?: WeatherAlertMinAggregateInputType
    _max?: WeatherAlertMaxAggregateInputType
  }

  export type WeatherAlertGroupByOutputType = {
    id: string
    alertType: string
    description: string | null
    startsAt: Date | null
    expiresAt: Date | null
    region: string | null
    createdAt: Date
    _count: WeatherAlertCountAggregateOutputType | null
    _min: WeatherAlertMinAggregateOutputType | null
    _max: WeatherAlertMaxAggregateOutputType | null
  }

  type GetWeatherAlertGroupByPayload<T extends WeatherAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeatherAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeatherAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeatherAlertGroupByOutputType[P]>
            : GetScalarType<T[P], WeatherAlertGroupByOutputType[P]>
        }
      >
    >


  export type WeatherAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alertType?: boolean
    description?: boolean
    startsAt?: boolean
    expiresAt?: boolean
    region?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["weatherAlert"]>

  export type WeatherAlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alertType?: boolean
    description?: boolean
    startsAt?: boolean
    expiresAt?: boolean
    region?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["weatherAlert"]>

  export type WeatherAlertSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alertType?: boolean
    description?: boolean
    startsAt?: boolean
    expiresAt?: boolean
    region?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["weatherAlert"]>

  export type WeatherAlertSelectScalar = {
    id?: boolean
    alertType?: boolean
    description?: boolean
    startsAt?: boolean
    expiresAt?: boolean
    region?: boolean
    createdAt?: boolean
  }

  export type WeatherAlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "alertType" | "description" | "startsAt" | "expiresAt" | "region" | "createdAt", ExtArgs["result"]["weatherAlert"]>

  export type $WeatherAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeatherAlert"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      alertType: string
      description: string | null
      startsAt: Date | null
      expiresAt: Date | null
      region: string | null
      createdAt: Date
    }, ExtArgs["result"]["weatherAlert"]>
    composites: {}
  }

  type WeatherAlertGetPayload<S extends boolean | null | undefined | WeatherAlertDefaultArgs> = $Result.GetResult<Prisma.$WeatherAlertPayload, S>

  type WeatherAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeatherAlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeatherAlertCountAggregateInputType | true
    }

  export interface WeatherAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeatherAlert'], meta: { name: 'WeatherAlert' } }
    /**
     * Find zero or one WeatherAlert that matches the filter.
     * @param {WeatherAlertFindUniqueArgs} args - Arguments to find a WeatherAlert
     * @example
     * // Get one WeatherAlert
     * const weatherAlert = await prisma.weatherAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeatherAlertFindUniqueArgs>(args: SelectSubset<T, WeatherAlertFindUniqueArgs<ExtArgs>>): Prisma__WeatherAlertClient<$Result.GetResult<Prisma.$WeatherAlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WeatherAlert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeatherAlertFindUniqueOrThrowArgs} args - Arguments to find a WeatherAlert
     * @example
     * // Get one WeatherAlert
     * const weatherAlert = await prisma.weatherAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeatherAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, WeatherAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeatherAlertClient<$Result.GetResult<Prisma.$WeatherAlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeatherAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherAlertFindFirstArgs} args - Arguments to find a WeatherAlert
     * @example
     * // Get one WeatherAlert
     * const weatherAlert = await prisma.weatherAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeatherAlertFindFirstArgs>(args?: SelectSubset<T, WeatherAlertFindFirstArgs<ExtArgs>>): Prisma__WeatherAlertClient<$Result.GetResult<Prisma.$WeatherAlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeatherAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherAlertFindFirstOrThrowArgs} args - Arguments to find a WeatherAlert
     * @example
     * // Get one WeatherAlert
     * const weatherAlert = await prisma.weatherAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeatherAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, WeatherAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeatherAlertClient<$Result.GetResult<Prisma.$WeatherAlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WeatherAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeatherAlerts
     * const weatherAlerts = await prisma.weatherAlert.findMany()
     * 
     * // Get first 10 WeatherAlerts
     * const weatherAlerts = await prisma.weatherAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weatherAlertWithIdOnly = await prisma.weatherAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeatherAlertFindManyArgs>(args?: SelectSubset<T, WeatherAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WeatherAlert.
     * @param {WeatherAlertCreateArgs} args - Arguments to create a WeatherAlert.
     * @example
     * // Create one WeatherAlert
     * const WeatherAlert = await prisma.weatherAlert.create({
     *   data: {
     *     // ... data to create a WeatherAlert
     *   }
     * })
     * 
     */
    create<T extends WeatherAlertCreateArgs>(args: SelectSubset<T, WeatherAlertCreateArgs<ExtArgs>>): Prisma__WeatherAlertClient<$Result.GetResult<Prisma.$WeatherAlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WeatherAlerts.
     * @param {WeatherAlertCreateManyArgs} args - Arguments to create many WeatherAlerts.
     * @example
     * // Create many WeatherAlerts
     * const weatherAlert = await prisma.weatherAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeatherAlertCreateManyArgs>(args?: SelectSubset<T, WeatherAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WeatherAlerts and returns the data saved in the database.
     * @param {WeatherAlertCreateManyAndReturnArgs} args - Arguments to create many WeatherAlerts.
     * @example
     * // Create many WeatherAlerts
     * const weatherAlert = await prisma.weatherAlert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WeatherAlerts and only return the `id`
     * const weatherAlertWithIdOnly = await prisma.weatherAlert.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeatherAlertCreateManyAndReturnArgs>(args?: SelectSubset<T, WeatherAlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherAlertPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WeatherAlert.
     * @param {WeatherAlertDeleteArgs} args - Arguments to delete one WeatherAlert.
     * @example
     * // Delete one WeatherAlert
     * const WeatherAlert = await prisma.weatherAlert.delete({
     *   where: {
     *     // ... filter to delete one WeatherAlert
     *   }
     * })
     * 
     */
    delete<T extends WeatherAlertDeleteArgs>(args: SelectSubset<T, WeatherAlertDeleteArgs<ExtArgs>>): Prisma__WeatherAlertClient<$Result.GetResult<Prisma.$WeatherAlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WeatherAlert.
     * @param {WeatherAlertUpdateArgs} args - Arguments to update one WeatherAlert.
     * @example
     * // Update one WeatherAlert
     * const weatherAlert = await prisma.weatherAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeatherAlertUpdateArgs>(args: SelectSubset<T, WeatherAlertUpdateArgs<ExtArgs>>): Prisma__WeatherAlertClient<$Result.GetResult<Prisma.$WeatherAlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WeatherAlerts.
     * @param {WeatherAlertDeleteManyArgs} args - Arguments to filter WeatherAlerts to delete.
     * @example
     * // Delete a few WeatherAlerts
     * const { count } = await prisma.weatherAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeatherAlertDeleteManyArgs>(args?: SelectSubset<T, WeatherAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeatherAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeatherAlerts
     * const weatherAlert = await prisma.weatherAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeatherAlertUpdateManyArgs>(args: SelectSubset<T, WeatherAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeatherAlerts and returns the data updated in the database.
     * @param {WeatherAlertUpdateManyAndReturnArgs} args - Arguments to update many WeatherAlerts.
     * @example
     * // Update many WeatherAlerts
     * const weatherAlert = await prisma.weatherAlert.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WeatherAlerts and only return the `id`
     * const weatherAlertWithIdOnly = await prisma.weatherAlert.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WeatherAlertUpdateManyAndReturnArgs>(args: SelectSubset<T, WeatherAlertUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherAlertPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WeatherAlert.
     * @param {WeatherAlertUpsertArgs} args - Arguments to update or create a WeatherAlert.
     * @example
     * // Update or create a WeatherAlert
     * const weatherAlert = await prisma.weatherAlert.upsert({
     *   create: {
     *     // ... data to create a WeatherAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeatherAlert we want to update
     *   }
     * })
     */
    upsert<T extends WeatherAlertUpsertArgs>(args: SelectSubset<T, WeatherAlertUpsertArgs<ExtArgs>>): Prisma__WeatherAlertClient<$Result.GetResult<Prisma.$WeatherAlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WeatherAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherAlertCountArgs} args - Arguments to filter WeatherAlerts to count.
     * @example
     * // Count the number of WeatherAlerts
     * const count = await prisma.weatherAlert.count({
     *   where: {
     *     // ... the filter for the WeatherAlerts we want to count
     *   }
     * })
    **/
    count<T extends WeatherAlertCountArgs>(
      args?: Subset<T, WeatherAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeatherAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeatherAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeatherAlertAggregateArgs>(args: Subset<T, WeatherAlertAggregateArgs>): Prisma.PrismaPromise<GetWeatherAlertAggregateType<T>>

    /**
     * Group by WeatherAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeatherAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeatherAlertGroupByArgs['orderBy'] }
        : { orderBy?: WeatherAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeatherAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeatherAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeatherAlert model
   */
  readonly fields: WeatherAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeatherAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeatherAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeatherAlert model
   */
  interface WeatherAlertFieldRefs {
    readonly id: FieldRef<"WeatherAlert", 'String'>
    readonly alertType: FieldRef<"WeatherAlert", 'String'>
    readonly description: FieldRef<"WeatherAlert", 'String'>
    readonly startsAt: FieldRef<"WeatherAlert", 'DateTime'>
    readonly expiresAt: FieldRef<"WeatherAlert", 'DateTime'>
    readonly region: FieldRef<"WeatherAlert", 'String'>
    readonly createdAt: FieldRef<"WeatherAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WeatherAlert findUnique
   */
  export type WeatherAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherAlert
     */
    select?: WeatherAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherAlert
     */
    omit?: WeatherAlertOmit<ExtArgs> | null
    /**
     * Filter, which WeatherAlert to fetch.
     */
    where: WeatherAlertWhereUniqueInput
  }

  /**
   * WeatherAlert findUniqueOrThrow
   */
  export type WeatherAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherAlert
     */
    select?: WeatherAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherAlert
     */
    omit?: WeatherAlertOmit<ExtArgs> | null
    /**
     * Filter, which WeatherAlert to fetch.
     */
    where: WeatherAlertWhereUniqueInput
  }

  /**
   * WeatherAlert findFirst
   */
  export type WeatherAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherAlert
     */
    select?: WeatherAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherAlert
     */
    omit?: WeatherAlertOmit<ExtArgs> | null
    /**
     * Filter, which WeatherAlert to fetch.
     */
    where?: WeatherAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherAlerts to fetch.
     */
    orderBy?: WeatherAlertOrderByWithRelationInput | WeatherAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeatherAlerts.
     */
    cursor?: WeatherAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeatherAlerts.
     */
    distinct?: WeatherAlertScalarFieldEnum | WeatherAlertScalarFieldEnum[]
  }

  /**
   * WeatherAlert findFirstOrThrow
   */
  export type WeatherAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherAlert
     */
    select?: WeatherAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherAlert
     */
    omit?: WeatherAlertOmit<ExtArgs> | null
    /**
     * Filter, which WeatherAlert to fetch.
     */
    where?: WeatherAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherAlerts to fetch.
     */
    orderBy?: WeatherAlertOrderByWithRelationInput | WeatherAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeatherAlerts.
     */
    cursor?: WeatherAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeatherAlerts.
     */
    distinct?: WeatherAlertScalarFieldEnum | WeatherAlertScalarFieldEnum[]
  }

  /**
   * WeatherAlert findMany
   */
  export type WeatherAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherAlert
     */
    select?: WeatherAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherAlert
     */
    omit?: WeatherAlertOmit<ExtArgs> | null
    /**
     * Filter, which WeatherAlerts to fetch.
     */
    where?: WeatherAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherAlerts to fetch.
     */
    orderBy?: WeatherAlertOrderByWithRelationInput | WeatherAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeatherAlerts.
     */
    cursor?: WeatherAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherAlerts.
     */
    skip?: number
    distinct?: WeatherAlertScalarFieldEnum | WeatherAlertScalarFieldEnum[]
  }

  /**
   * WeatherAlert create
   */
  export type WeatherAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherAlert
     */
    select?: WeatherAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherAlert
     */
    omit?: WeatherAlertOmit<ExtArgs> | null
    /**
     * The data needed to create a WeatherAlert.
     */
    data: XOR<WeatherAlertCreateInput, WeatherAlertUncheckedCreateInput>
  }

  /**
   * WeatherAlert createMany
   */
  export type WeatherAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeatherAlerts.
     */
    data: WeatherAlertCreateManyInput | WeatherAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeatherAlert createManyAndReturn
   */
  export type WeatherAlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherAlert
     */
    select?: WeatherAlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherAlert
     */
    omit?: WeatherAlertOmit<ExtArgs> | null
    /**
     * The data used to create many WeatherAlerts.
     */
    data: WeatherAlertCreateManyInput | WeatherAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeatherAlert update
   */
  export type WeatherAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherAlert
     */
    select?: WeatherAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherAlert
     */
    omit?: WeatherAlertOmit<ExtArgs> | null
    /**
     * The data needed to update a WeatherAlert.
     */
    data: XOR<WeatherAlertUpdateInput, WeatherAlertUncheckedUpdateInput>
    /**
     * Choose, which WeatherAlert to update.
     */
    where: WeatherAlertWhereUniqueInput
  }

  /**
   * WeatherAlert updateMany
   */
  export type WeatherAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeatherAlerts.
     */
    data: XOR<WeatherAlertUpdateManyMutationInput, WeatherAlertUncheckedUpdateManyInput>
    /**
     * Filter which WeatherAlerts to update
     */
    where?: WeatherAlertWhereInput
    /**
     * Limit how many WeatherAlerts to update.
     */
    limit?: number
  }

  /**
   * WeatherAlert updateManyAndReturn
   */
  export type WeatherAlertUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherAlert
     */
    select?: WeatherAlertSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherAlert
     */
    omit?: WeatherAlertOmit<ExtArgs> | null
    /**
     * The data used to update WeatherAlerts.
     */
    data: XOR<WeatherAlertUpdateManyMutationInput, WeatherAlertUncheckedUpdateManyInput>
    /**
     * Filter which WeatherAlerts to update
     */
    where?: WeatherAlertWhereInput
    /**
     * Limit how many WeatherAlerts to update.
     */
    limit?: number
  }

  /**
   * WeatherAlert upsert
   */
  export type WeatherAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherAlert
     */
    select?: WeatherAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherAlert
     */
    omit?: WeatherAlertOmit<ExtArgs> | null
    /**
     * The filter to search for the WeatherAlert to update in case it exists.
     */
    where: WeatherAlertWhereUniqueInput
    /**
     * In case the WeatherAlert found by the `where` argument doesn't exist, create a new WeatherAlert with this data.
     */
    create: XOR<WeatherAlertCreateInput, WeatherAlertUncheckedCreateInput>
    /**
     * In case the WeatherAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeatherAlertUpdateInput, WeatherAlertUncheckedUpdateInput>
  }

  /**
   * WeatherAlert delete
   */
  export type WeatherAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherAlert
     */
    select?: WeatherAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherAlert
     */
    omit?: WeatherAlertOmit<ExtArgs> | null
    /**
     * Filter which WeatherAlert to delete.
     */
    where: WeatherAlertWhereUniqueInput
  }

  /**
   * WeatherAlert deleteMany
   */
  export type WeatherAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeatherAlerts to delete
     */
    where?: WeatherAlertWhereInput
    /**
     * Limit how many WeatherAlerts to delete.
     */
    limit?: number
  }

  /**
   * WeatherAlert without action
   */
  export type WeatherAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherAlert
     */
    select?: WeatherAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherAlert
     */
    omit?: WeatherAlertOmit<ExtArgs> | null
  }


  /**
   * Model MarketListing
   */

  export type AggregateMarketListing = {
    _count: MarketListingCountAggregateOutputType | null
    _avg: MarketListingAvgAggregateOutputType | null
    _sum: MarketListingSumAggregateOutputType | null
    _min: MarketListingMinAggregateOutputType | null
    _max: MarketListingMaxAggregateOutputType | null
  }

  export type MarketListingAvgAggregateOutputType = {
    price: Decimal | null
  }

  export type MarketListingSumAggregateOutputType = {
    price: Decimal | null
  }

  export type MarketListingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    itemType: $Enums.ItemType | null
    itemRef: string | null
    price: Decimal | null
    currency: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type MarketListingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    itemType: $Enums.ItemType | null
    itemRef: string | null
    price: Decimal | null
    currency: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type MarketListingCountAggregateOutputType = {
    id: number
    userId: number
    itemType: number
    itemRef: number
    price: number
    currency: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type MarketListingAvgAggregateInputType = {
    price?: true
  }

  export type MarketListingSumAggregateInputType = {
    price?: true
  }

  export type MarketListingMinAggregateInputType = {
    id?: true
    userId?: true
    itemType?: true
    itemRef?: true
    price?: true
    currency?: true
    isActive?: true
    createdAt?: true
  }

  export type MarketListingMaxAggregateInputType = {
    id?: true
    userId?: true
    itemType?: true
    itemRef?: true
    price?: true
    currency?: true
    isActive?: true
    createdAt?: true
  }

  export type MarketListingCountAggregateInputType = {
    id?: true
    userId?: true
    itemType?: true
    itemRef?: true
    price?: true
    currency?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type MarketListingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketListing to aggregate.
     */
    where?: MarketListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketListings to fetch.
     */
    orderBy?: MarketListingOrderByWithRelationInput | MarketListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketListings
    **/
    _count?: true | MarketListingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketListingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketListingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketListingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketListingMaxAggregateInputType
  }

  export type GetMarketListingAggregateType<T extends MarketListingAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketListing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketListing[P]>
      : GetScalarType<T[P], AggregateMarketListing[P]>
  }




  export type MarketListingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketListingWhereInput
    orderBy?: MarketListingOrderByWithAggregationInput | MarketListingOrderByWithAggregationInput[]
    by: MarketListingScalarFieldEnum[] | MarketListingScalarFieldEnum
    having?: MarketListingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketListingCountAggregateInputType | true
    _avg?: MarketListingAvgAggregateInputType
    _sum?: MarketListingSumAggregateInputType
    _min?: MarketListingMinAggregateInputType
    _max?: MarketListingMaxAggregateInputType
  }

  export type MarketListingGroupByOutputType = {
    id: string
    userId: string
    itemType: $Enums.ItemType
    itemRef: string
    price: Decimal | null
    currency: string
    isActive: boolean
    createdAt: Date
    _count: MarketListingCountAggregateOutputType | null
    _avg: MarketListingAvgAggregateOutputType | null
    _sum: MarketListingSumAggregateOutputType | null
    _min: MarketListingMinAggregateOutputType | null
    _max: MarketListingMaxAggregateOutputType | null
  }

  type GetMarketListingGroupByPayload<T extends MarketListingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketListingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketListingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketListingGroupByOutputType[P]>
            : GetScalarType<T[P], MarketListingGroupByOutputType[P]>
        }
      >
    >


  export type MarketListingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itemType?: boolean
    itemRef?: boolean
    price?: boolean
    currency?: boolean
    isActive?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketListing"]>

  export type MarketListingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itemType?: boolean
    itemRef?: boolean
    price?: boolean
    currency?: boolean
    isActive?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketListing"]>

  export type MarketListingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itemType?: boolean
    itemRef?: boolean
    price?: boolean
    currency?: boolean
    isActive?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketListing"]>

  export type MarketListingSelectScalar = {
    id?: boolean
    userId?: boolean
    itemType?: boolean
    itemRef?: boolean
    price?: boolean
    currency?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type MarketListingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "itemType" | "itemRef" | "price" | "currency" | "isActive" | "createdAt", ExtArgs["result"]["marketListing"]>
  export type MarketListingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MarketListingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MarketListingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MarketListingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketListing"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      itemType: $Enums.ItemType
      itemRef: string
      price: Prisma.Decimal | null
      currency: string
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["marketListing"]>
    composites: {}
  }

  type MarketListingGetPayload<S extends boolean | null | undefined | MarketListingDefaultArgs> = $Result.GetResult<Prisma.$MarketListingPayload, S>

  type MarketListingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarketListingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketListingCountAggregateInputType | true
    }

  export interface MarketListingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketListing'], meta: { name: 'MarketListing' } }
    /**
     * Find zero or one MarketListing that matches the filter.
     * @param {MarketListingFindUniqueArgs} args - Arguments to find a MarketListing
     * @example
     * // Get one MarketListing
     * const marketListing = await prisma.marketListing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketListingFindUniqueArgs>(args: SelectSubset<T, MarketListingFindUniqueArgs<ExtArgs>>): Prisma__MarketListingClient<$Result.GetResult<Prisma.$MarketListingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MarketListing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarketListingFindUniqueOrThrowArgs} args - Arguments to find a MarketListing
     * @example
     * // Get one MarketListing
     * const marketListing = await prisma.marketListing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketListingFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketListingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketListingClient<$Result.GetResult<Prisma.$MarketListingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketListing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketListingFindFirstArgs} args - Arguments to find a MarketListing
     * @example
     * // Get one MarketListing
     * const marketListing = await prisma.marketListing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketListingFindFirstArgs>(args?: SelectSubset<T, MarketListingFindFirstArgs<ExtArgs>>): Prisma__MarketListingClient<$Result.GetResult<Prisma.$MarketListingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketListing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketListingFindFirstOrThrowArgs} args - Arguments to find a MarketListing
     * @example
     * // Get one MarketListing
     * const marketListing = await prisma.marketListing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketListingFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketListingFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketListingClient<$Result.GetResult<Prisma.$MarketListingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketListings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketListingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketListings
     * const marketListings = await prisma.marketListing.findMany()
     * 
     * // Get first 10 MarketListings
     * const marketListings = await prisma.marketListing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketListingWithIdOnly = await prisma.marketListing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketListingFindManyArgs>(args?: SelectSubset<T, MarketListingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MarketListing.
     * @param {MarketListingCreateArgs} args - Arguments to create a MarketListing.
     * @example
     * // Create one MarketListing
     * const MarketListing = await prisma.marketListing.create({
     *   data: {
     *     // ... data to create a MarketListing
     *   }
     * })
     * 
     */
    create<T extends MarketListingCreateArgs>(args: SelectSubset<T, MarketListingCreateArgs<ExtArgs>>): Prisma__MarketListingClient<$Result.GetResult<Prisma.$MarketListingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MarketListings.
     * @param {MarketListingCreateManyArgs} args - Arguments to create many MarketListings.
     * @example
     * // Create many MarketListings
     * const marketListing = await prisma.marketListing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketListingCreateManyArgs>(args?: SelectSubset<T, MarketListingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketListings and returns the data saved in the database.
     * @param {MarketListingCreateManyAndReturnArgs} args - Arguments to create many MarketListings.
     * @example
     * // Create many MarketListings
     * const marketListing = await prisma.marketListing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketListings and only return the `id`
     * const marketListingWithIdOnly = await prisma.marketListing.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketListingCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketListingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketListingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MarketListing.
     * @param {MarketListingDeleteArgs} args - Arguments to delete one MarketListing.
     * @example
     * // Delete one MarketListing
     * const MarketListing = await prisma.marketListing.delete({
     *   where: {
     *     // ... filter to delete one MarketListing
     *   }
     * })
     * 
     */
    delete<T extends MarketListingDeleteArgs>(args: SelectSubset<T, MarketListingDeleteArgs<ExtArgs>>): Prisma__MarketListingClient<$Result.GetResult<Prisma.$MarketListingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MarketListing.
     * @param {MarketListingUpdateArgs} args - Arguments to update one MarketListing.
     * @example
     * // Update one MarketListing
     * const marketListing = await prisma.marketListing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketListingUpdateArgs>(args: SelectSubset<T, MarketListingUpdateArgs<ExtArgs>>): Prisma__MarketListingClient<$Result.GetResult<Prisma.$MarketListingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MarketListings.
     * @param {MarketListingDeleteManyArgs} args - Arguments to filter MarketListings to delete.
     * @example
     * // Delete a few MarketListings
     * const { count } = await prisma.marketListing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketListingDeleteManyArgs>(args?: SelectSubset<T, MarketListingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketListingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketListings
     * const marketListing = await prisma.marketListing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketListingUpdateManyArgs>(args: SelectSubset<T, MarketListingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketListings and returns the data updated in the database.
     * @param {MarketListingUpdateManyAndReturnArgs} args - Arguments to update many MarketListings.
     * @example
     * // Update many MarketListings
     * const marketListing = await prisma.marketListing.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MarketListings and only return the `id`
     * const marketListingWithIdOnly = await prisma.marketListing.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MarketListingUpdateManyAndReturnArgs>(args: SelectSubset<T, MarketListingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketListingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MarketListing.
     * @param {MarketListingUpsertArgs} args - Arguments to update or create a MarketListing.
     * @example
     * // Update or create a MarketListing
     * const marketListing = await prisma.marketListing.upsert({
     *   create: {
     *     // ... data to create a MarketListing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketListing we want to update
     *   }
     * })
     */
    upsert<T extends MarketListingUpsertArgs>(args: SelectSubset<T, MarketListingUpsertArgs<ExtArgs>>): Prisma__MarketListingClient<$Result.GetResult<Prisma.$MarketListingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MarketListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketListingCountArgs} args - Arguments to filter MarketListings to count.
     * @example
     * // Count the number of MarketListings
     * const count = await prisma.marketListing.count({
     *   where: {
     *     // ... the filter for the MarketListings we want to count
     *   }
     * })
    **/
    count<T extends MarketListingCountArgs>(
      args?: Subset<T, MarketListingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketListingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketListingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketListingAggregateArgs>(args: Subset<T, MarketListingAggregateArgs>): Prisma.PrismaPromise<GetMarketListingAggregateType<T>>

    /**
     * Group by MarketListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketListingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketListingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketListingGroupByArgs['orderBy'] }
        : { orderBy?: MarketListingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketListingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketListingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketListing model
   */
  readonly fields: MarketListingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketListing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketListingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketListing model
   */
  interface MarketListingFieldRefs {
    readonly id: FieldRef<"MarketListing", 'String'>
    readonly userId: FieldRef<"MarketListing", 'String'>
    readonly itemType: FieldRef<"MarketListing", 'ItemType'>
    readonly itemRef: FieldRef<"MarketListing", 'String'>
    readonly price: FieldRef<"MarketListing", 'Decimal'>
    readonly currency: FieldRef<"MarketListing", 'String'>
    readonly isActive: FieldRef<"MarketListing", 'Boolean'>
    readonly createdAt: FieldRef<"MarketListing", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketListing findUnique
   */
  export type MarketListingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingInclude<ExtArgs> | null
    /**
     * Filter, which MarketListing to fetch.
     */
    where: MarketListingWhereUniqueInput
  }

  /**
   * MarketListing findUniqueOrThrow
   */
  export type MarketListingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingInclude<ExtArgs> | null
    /**
     * Filter, which MarketListing to fetch.
     */
    where: MarketListingWhereUniqueInput
  }

  /**
   * MarketListing findFirst
   */
  export type MarketListingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingInclude<ExtArgs> | null
    /**
     * Filter, which MarketListing to fetch.
     */
    where?: MarketListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketListings to fetch.
     */
    orderBy?: MarketListingOrderByWithRelationInput | MarketListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketListings.
     */
    cursor?: MarketListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketListings.
     */
    distinct?: MarketListingScalarFieldEnum | MarketListingScalarFieldEnum[]
  }

  /**
   * MarketListing findFirstOrThrow
   */
  export type MarketListingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingInclude<ExtArgs> | null
    /**
     * Filter, which MarketListing to fetch.
     */
    where?: MarketListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketListings to fetch.
     */
    orderBy?: MarketListingOrderByWithRelationInput | MarketListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketListings.
     */
    cursor?: MarketListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketListings.
     */
    distinct?: MarketListingScalarFieldEnum | MarketListingScalarFieldEnum[]
  }

  /**
   * MarketListing findMany
   */
  export type MarketListingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingInclude<ExtArgs> | null
    /**
     * Filter, which MarketListings to fetch.
     */
    where?: MarketListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketListings to fetch.
     */
    orderBy?: MarketListingOrderByWithRelationInput | MarketListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketListings.
     */
    cursor?: MarketListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketListings.
     */
    skip?: number
    distinct?: MarketListingScalarFieldEnum | MarketListingScalarFieldEnum[]
  }

  /**
   * MarketListing create
   */
  export type MarketListingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketListing.
     */
    data: XOR<MarketListingCreateInput, MarketListingUncheckedCreateInput>
  }

  /**
   * MarketListing createMany
   */
  export type MarketListingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketListings.
     */
    data: MarketListingCreateManyInput | MarketListingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketListing createManyAndReturn
   */
  export type MarketListingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * The data used to create many MarketListings.
     */
    data: MarketListingCreateManyInput | MarketListingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketListing update
   */
  export type MarketListingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketListing.
     */
    data: XOR<MarketListingUpdateInput, MarketListingUncheckedUpdateInput>
    /**
     * Choose, which MarketListing to update.
     */
    where: MarketListingWhereUniqueInput
  }

  /**
   * MarketListing updateMany
   */
  export type MarketListingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketListings.
     */
    data: XOR<MarketListingUpdateManyMutationInput, MarketListingUncheckedUpdateManyInput>
    /**
     * Filter which MarketListings to update
     */
    where?: MarketListingWhereInput
    /**
     * Limit how many MarketListings to update.
     */
    limit?: number
  }

  /**
   * MarketListing updateManyAndReturn
   */
  export type MarketListingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * The data used to update MarketListings.
     */
    data: XOR<MarketListingUpdateManyMutationInput, MarketListingUncheckedUpdateManyInput>
    /**
     * Filter which MarketListings to update
     */
    where?: MarketListingWhereInput
    /**
     * Limit how many MarketListings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketListing upsert
   */
  export type MarketListingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketListing to update in case it exists.
     */
    where: MarketListingWhereUniqueInput
    /**
     * In case the MarketListing found by the `where` argument doesn't exist, create a new MarketListing with this data.
     */
    create: XOR<MarketListingCreateInput, MarketListingUncheckedCreateInput>
    /**
     * In case the MarketListing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketListingUpdateInput, MarketListingUncheckedUpdateInput>
  }

  /**
   * MarketListing delete
   */
  export type MarketListingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingInclude<ExtArgs> | null
    /**
     * Filter which MarketListing to delete.
     */
    where: MarketListingWhereUniqueInput
  }

  /**
   * MarketListing deleteMany
   */
  export type MarketListingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketListings to delete
     */
    where?: MarketListingWhereInput
    /**
     * Limit how many MarketListings to delete.
     */
    limit?: number
  }

  /**
   * MarketListing without action
   */
  export type MarketListingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    body: string | null
    category: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    body: string | null
    category: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    body: number
    category: number
    metadata: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    body?: true
    category?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    body?: true
    category?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    body?: true
    category?: true
    metadata?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    title: string
    body: string
    category: string | null
    metadata: JsonValue | null
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    category?: boolean
    metadata?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    category?: boolean
    metadata?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    category?: boolean
    metadata?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    category?: boolean
    metadata?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "body" | "category" | "metadata" | "read" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      body: string
      category: string | null
      metadata: Prisma.JsonValue | null
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly body: FieldRef<"Notification", 'String'>
    readonly category: FieldRef<"Notification", 'String'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    fullName: 'fullName',
    role: 'role',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CropScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    cropType: 'cropType',
    specificType: 'specificType',
    plantingDate: 'plantingDate',
    harvestDate: 'harvestDate',
    notes: 'notes',
    areaHectares: 'areaHectares',
    pesticide: 'pesticide',
    createdAt: 'createdAt',
    nextSprayDueAt: 'nextSprayDueAt',
    lastSprayAlertAt: 'lastSprayAlertAt',
    proteinPercent: 'proteinPercent',
    moisturePercent: 'moisturePercent',
    sugarPercent: 'sugarPercent',
    oilPercent: 'oilPercent',
    healthStatus: 'healthStatus',
    diseaseNotes: 'diseaseNotes',
    qualityScore: 'qualityScore',
    customMetrics: 'customMetrics'
  };

  export type CropScalarFieldEnum = (typeof CropScalarFieldEnum)[keyof typeof CropScalarFieldEnum]


  export const LivestockScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    animalType: 'animalType',
    specificType: 'specificType',
    breed: 'breed',
    birthDate: 'birthDate',
    notes: 'notes',
    createdAt: 'createdAt',
    lastMilkAlertAt: 'lastMilkAlertAt',
    weightKg: 'weightKg',
    healthStatus: 'healthStatus',
    dailyFeedKg: 'dailyFeedKg',
    vaccineStatus: 'vaccineStatus',
    lastCheckupDate: 'lastCheckupDate',
    customMetrics: 'customMetrics'
  };

  export type LivestockScalarFieldEnum = (typeof LivestockScalarFieldEnum)[keyof typeof LivestockScalarFieldEnum]


  export const CropSprayScalarFieldEnum: {
    id: 'id',
    cropId: 'cropId',
    sprayedAt: 'sprayedAt',
    pesticide: 'pesticide',
    createdAt: 'createdAt'
  };

  export type CropSprayScalarFieldEnum = (typeof CropSprayScalarFieldEnum)[keyof typeof CropSprayScalarFieldEnum]


  export const CropHarvestScalarFieldEnum: {
    id: 'id',
    cropId: 'cropId',
    harvestedAt: 'harvestedAt',
    amountTon: 'amountTon',
    yieldTonPerHa: 'yieldTonPerHa',
    createdAt: 'createdAt'
  };

  export type CropHarvestScalarFieldEnum = (typeof CropHarvestScalarFieldEnum)[keyof typeof CropHarvestScalarFieldEnum]


  export const MilkLogScalarFieldEnum: {
    id: 'id',
    livestockId: 'livestockId',
    measuredAt: 'measuredAt',
    quantityL: 'quantityL',
    fatPercent: 'fatPercent',
    createdAt: 'createdAt'
  };

  export type MilkLogScalarFieldEnum = (typeof MilkLogScalarFieldEnum)[keyof typeof MilkLogScalarFieldEnum]


  export const EggLogScalarFieldEnum: {
    id: 'id',
    livestockId: 'livestockId',
    measuredAt: 'measuredAt',
    eggCount: 'eggCount',
    avgWeightGram: 'avgWeightGram',
    createdAt: 'createdAt'
  };

  export type EggLogScalarFieldEnum = (typeof EggLogScalarFieldEnum)[keyof typeof EggLogScalarFieldEnum]


  export const HoneyLogScalarFieldEnum: {
    id: 'id',
    livestockId: 'livestockId',
    measuredAt: 'measuredAt',
    amountKg: 'amountKg',
    qualityGrade: 'qualityGrade',
    createdAt: 'createdAt'
  };

  export type HoneyLogScalarFieldEnum = (typeof HoneyLogScalarFieldEnum)[keyof typeof HoneyLogScalarFieldEnum]


  export const WoolLogScalarFieldEnum: {
    id: 'id',
    livestockId: 'livestockId',
    shearedAt: 'shearedAt',
    amountKg: 'amountKg',
    qualityGrade: 'qualityGrade',
    createdAt: 'createdAt'
  };

  export type WoolLogScalarFieldEnum = (typeof WoolLogScalarFieldEnum)[keyof typeof WoolLogScalarFieldEnum]


  export const WeightLogScalarFieldEnum: {
    id: 'id',
    livestockId: 'livestockId',
    measuredAt: 'measuredAt',
    weightKg: 'weightKg',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type WeightLogScalarFieldEnum = (typeof WeightLogScalarFieldEnum)[keyof typeof WeightLogScalarFieldEnum]


  export const LivestockMetricScalarFieldEnum: {
    id: 'id',
    livestockId: 'livestockId',
    key: 'key',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LivestockMetricScalarFieldEnum = (typeof LivestockMetricScalarFieldEnum)[keyof typeof LivestockMetricScalarFieldEnum]


  export const CropQualityLogScalarFieldEnum: {
    id: 'id',
    cropId: 'cropId',
    measuredAt: 'measuredAt',
    proteinPercent: 'proteinPercent',
    moisturePercent: 'moisturePercent',
    sugarPercent: 'sugarPercent',
    oilPercent: 'oilPercent',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type CropQualityLogScalarFieldEnum = (typeof CropQualityLogScalarFieldEnum)[keyof typeof CropQualityLogScalarFieldEnum]


  export const CropMetricScalarFieldEnum: {
    id: 'id',
    cropId: 'cropId',
    key: 'key',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CropMetricScalarFieldEnum = (typeof CropMetricScalarFieldEnum)[keyof typeof CropMetricScalarFieldEnum]


  export const SupportProgramScalarFieldEnum: {
    id: 'id',
    title: 'title',
    titleEn: 'titleEn',
    description: 'description',
    descriptionEn: 'descriptionEn',
    category: 'category',
    subcategory: 'subcategory',
    amount: 'amount',
    amountEn: 'amountEn',
    eligibility: 'eligibility',
    eligibilityEn: 'eligibilityEn',
    requiredDocs: 'requiredDocs',
    requiredDocsEn: 'requiredDocsEn',
    applicationStart: 'applicationStart',
    applicationDeadline: 'applicationDeadline',
    link: 'link',
    status: 'status',
    targetCrops: 'targetCrops',
    targetLivestock: 'targetLivestock',
    region: 'region',
    priority: 'priority',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupportProgramScalarFieldEnum = (typeof SupportProgramScalarFieldEnum)[keyof typeof SupportProgramScalarFieldEnum]


  export const WeatherAlertScalarFieldEnum: {
    id: 'id',
    alertType: 'alertType',
    description: 'description',
    startsAt: 'startsAt',
    expiresAt: 'expiresAt',
    region: 'region',
    createdAt: 'createdAt'
  };

  export type WeatherAlertScalarFieldEnum = (typeof WeatherAlertScalarFieldEnum)[keyof typeof WeatherAlertScalarFieldEnum]


  export const MarketListingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    itemType: 'itemType',
    itemRef: 'itemRef',
    price: 'price',
    currency: 'currency',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type MarketListingScalarFieldEnum = (typeof MarketListingScalarFieldEnum)[keyof typeof MarketListingScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    body: 'body',
    category: 'category',
    metadata: 'metadata',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'ItemType'
   */
  export type EnumItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemType'>
    


  /**
   * Reference to a field of type 'ItemType[]'
   */
  export type ListEnumItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    fullName?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    crops?: CropListRelationFilter
    livestock?: LivestockListRelationFilter
    listings?: MarketListingListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    crops?: CropOrderByRelationAggregateInput
    livestock?: LivestockOrderByRelationAggregateInput
    listings?: MarketListingOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    fullName?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    crops?: CropListRelationFilter
    livestock?: LivestockListRelationFilter
    listings?: MarketListingListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    fullName?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CropWhereInput = {
    AND?: CropWhereInput | CropWhereInput[]
    OR?: CropWhereInput[]
    NOT?: CropWhereInput | CropWhereInput[]
    id?: StringFilter<"Crop"> | string
    userId?: StringFilter<"Crop"> | string
    cropType?: StringFilter<"Crop"> | string
    specificType?: StringNullableFilter<"Crop"> | string | null
    plantingDate?: DateTimeFilter<"Crop"> | Date | string
    harvestDate?: DateTimeNullableFilter<"Crop"> | Date | string | null
    notes?: StringNullableFilter<"Crop"> | string | null
    areaHectares?: FloatNullableFilter<"Crop"> | number | null
    pesticide?: StringNullableFilter<"Crop"> | string | null
    createdAt?: DateTimeFilter<"Crop"> | Date | string
    nextSprayDueAt?: DateTimeNullableFilter<"Crop"> | Date | string | null
    lastSprayAlertAt?: DateTimeNullableFilter<"Crop"> | Date | string | null
    proteinPercent?: FloatNullableFilter<"Crop"> | number | null
    moisturePercent?: FloatNullableFilter<"Crop"> | number | null
    sugarPercent?: FloatNullableFilter<"Crop"> | number | null
    oilPercent?: FloatNullableFilter<"Crop"> | number | null
    healthStatus?: StringNullableFilter<"Crop"> | string | null
    diseaseNotes?: StringNullableFilter<"Crop"> | string | null
    qualityScore?: IntNullableFilter<"Crop"> | number | null
    customMetrics?: JsonNullableFilter<"Crop">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    sprays?: CropSprayListRelationFilter
    harvests?: CropHarvestListRelationFilter
    qualityLogs?: CropQualityLogListRelationFilter
    metrics?: CropMetricListRelationFilter
  }

  export type CropOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    cropType?: SortOrder
    specificType?: SortOrderInput | SortOrder
    plantingDate?: SortOrder
    harvestDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    areaHectares?: SortOrderInput | SortOrder
    pesticide?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    nextSprayDueAt?: SortOrderInput | SortOrder
    lastSprayAlertAt?: SortOrderInput | SortOrder
    proteinPercent?: SortOrderInput | SortOrder
    moisturePercent?: SortOrderInput | SortOrder
    sugarPercent?: SortOrderInput | SortOrder
    oilPercent?: SortOrderInput | SortOrder
    healthStatus?: SortOrderInput | SortOrder
    diseaseNotes?: SortOrderInput | SortOrder
    qualityScore?: SortOrderInput | SortOrder
    customMetrics?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    sprays?: CropSprayOrderByRelationAggregateInput
    harvests?: CropHarvestOrderByRelationAggregateInput
    qualityLogs?: CropQualityLogOrderByRelationAggregateInput
    metrics?: CropMetricOrderByRelationAggregateInput
  }

  export type CropWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CropWhereInput | CropWhereInput[]
    OR?: CropWhereInput[]
    NOT?: CropWhereInput | CropWhereInput[]
    userId?: StringFilter<"Crop"> | string
    cropType?: StringFilter<"Crop"> | string
    specificType?: StringNullableFilter<"Crop"> | string | null
    plantingDate?: DateTimeFilter<"Crop"> | Date | string
    harvestDate?: DateTimeNullableFilter<"Crop"> | Date | string | null
    notes?: StringNullableFilter<"Crop"> | string | null
    areaHectares?: FloatNullableFilter<"Crop"> | number | null
    pesticide?: StringNullableFilter<"Crop"> | string | null
    createdAt?: DateTimeFilter<"Crop"> | Date | string
    nextSprayDueAt?: DateTimeNullableFilter<"Crop"> | Date | string | null
    lastSprayAlertAt?: DateTimeNullableFilter<"Crop"> | Date | string | null
    proteinPercent?: FloatNullableFilter<"Crop"> | number | null
    moisturePercent?: FloatNullableFilter<"Crop"> | number | null
    sugarPercent?: FloatNullableFilter<"Crop"> | number | null
    oilPercent?: FloatNullableFilter<"Crop"> | number | null
    healthStatus?: StringNullableFilter<"Crop"> | string | null
    diseaseNotes?: StringNullableFilter<"Crop"> | string | null
    qualityScore?: IntNullableFilter<"Crop"> | number | null
    customMetrics?: JsonNullableFilter<"Crop">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    sprays?: CropSprayListRelationFilter
    harvests?: CropHarvestListRelationFilter
    qualityLogs?: CropQualityLogListRelationFilter
    metrics?: CropMetricListRelationFilter
  }, "id">

  export type CropOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    cropType?: SortOrder
    specificType?: SortOrderInput | SortOrder
    plantingDate?: SortOrder
    harvestDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    areaHectares?: SortOrderInput | SortOrder
    pesticide?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    nextSprayDueAt?: SortOrderInput | SortOrder
    lastSprayAlertAt?: SortOrderInput | SortOrder
    proteinPercent?: SortOrderInput | SortOrder
    moisturePercent?: SortOrderInput | SortOrder
    sugarPercent?: SortOrderInput | SortOrder
    oilPercent?: SortOrderInput | SortOrder
    healthStatus?: SortOrderInput | SortOrder
    diseaseNotes?: SortOrderInput | SortOrder
    qualityScore?: SortOrderInput | SortOrder
    customMetrics?: SortOrderInput | SortOrder
    _count?: CropCountOrderByAggregateInput
    _avg?: CropAvgOrderByAggregateInput
    _max?: CropMaxOrderByAggregateInput
    _min?: CropMinOrderByAggregateInput
    _sum?: CropSumOrderByAggregateInput
  }

  export type CropScalarWhereWithAggregatesInput = {
    AND?: CropScalarWhereWithAggregatesInput | CropScalarWhereWithAggregatesInput[]
    OR?: CropScalarWhereWithAggregatesInput[]
    NOT?: CropScalarWhereWithAggregatesInput | CropScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Crop"> | string
    userId?: StringWithAggregatesFilter<"Crop"> | string
    cropType?: StringWithAggregatesFilter<"Crop"> | string
    specificType?: StringNullableWithAggregatesFilter<"Crop"> | string | null
    plantingDate?: DateTimeWithAggregatesFilter<"Crop"> | Date | string
    harvestDate?: DateTimeNullableWithAggregatesFilter<"Crop"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Crop"> | string | null
    areaHectares?: FloatNullableWithAggregatesFilter<"Crop"> | number | null
    pesticide?: StringNullableWithAggregatesFilter<"Crop"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Crop"> | Date | string
    nextSprayDueAt?: DateTimeNullableWithAggregatesFilter<"Crop"> | Date | string | null
    lastSprayAlertAt?: DateTimeNullableWithAggregatesFilter<"Crop"> | Date | string | null
    proteinPercent?: FloatNullableWithAggregatesFilter<"Crop"> | number | null
    moisturePercent?: FloatNullableWithAggregatesFilter<"Crop"> | number | null
    sugarPercent?: FloatNullableWithAggregatesFilter<"Crop"> | number | null
    oilPercent?: FloatNullableWithAggregatesFilter<"Crop"> | number | null
    healthStatus?: StringNullableWithAggregatesFilter<"Crop"> | string | null
    diseaseNotes?: StringNullableWithAggregatesFilter<"Crop"> | string | null
    qualityScore?: IntNullableWithAggregatesFilter<"Crop"> | number | null
    customMetrics?: JsonNullableWithAggregatesFilter<"Crop">
  }

  export type LivestockWhereInput = {
    AND?: LivestockWhereInput | LivestockWhereInput[]
    OR?: LivestockWhereInput[]
    NOT?: LivestockWhereInput | LivestockWhereInput[]
    id?: StringFilter<"Livestock"> | string
    userId?: StringFilter<"Livestock"> | string
    animalType?: StringFilter<"Livestock"> | string
    specificType?: StringNullableFilter<"Livestock"> | string | null
    breed?: StringNullableFilter<"Livestock"> | string | null
    birthDate?: DateTimeNullableFilter<"Livestock"> | Date | string | null
    notes?: StringNullableFilter<"Livestock"> | string | null
    createdAt?: DateTimeFilter<"Livestock"> | Date | string
    lastMilkAlertAt?: DateTimeNullableFilter<"Livestock"> | Date | string | null
    weightKg?: FloatNullableFilter<"Livestock"> | number | null
    healthStatus?: StringNullableFilter<"Livestock"> | string | null
    dailyFeedKg?: FloatNullableFilter<"Livestock"> | number | null
    vaccineStatus?: StringNullableFilter<"Livestock"> | string | null
    lastCheckupDate?: DateTimeNullableFilter<"Livestock"> | Date | string | null
    customMetrics?: JsonNullableFilter<"Livestock">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    milkLogs?: MilkLogListRelationFilter
    eggLogs?: EggLogListRelationFilter
    honeyLogs?: HoneyLogListRelationFilter
    woolLogs?: WoolLogListRelationFilter
    weightLogs?: WeightLogListRelationFilter
    metrics?: LivestockMetricListRelationFilter
  }

  export type LivestockOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    animalType?: SortOrder
    specificType?: SortOrderInput | SortOrder
    breed?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastMilkAlertAt?: SortOrderInput | SortOrder
    weightKg?: SortOrderInput | SortOrder
    healthStatus?: SortOrderInput | SortOrder
    dailyFeedKg?: SortOrderInput | SortOrder
    vaccineStatus?: SortOrderInput | SortOrder
    lastCheckupDate?: SortOrderInput | SortOrder
    customMetrics?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    milkLogs?: MilkLogOrderByRelationAggregateInput
    eggLogs?: EggLogOrderByRelationAggregateInput
    honeyLogs?: HoneyLogOrderByRelationAggregateInput
    woolLogs?: WoolLogOrderByRelationAggregateInput
    weightLogs?: WeightLogOrderByRelationAggregateInput
    metrics?: LivestockMetricOrderByRelationAggregateInput
  }

  export type LivestockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LivestockWhereInput | LivestockWhereInput[]
    OR?: LivestockWhereInput[]
    NOT?: LivestockWhereInput | LivestockWhereInput[]
    userId?: StringFilter<"Livestock"> | string
    animalType?: StringFilter<"Livestock"> | string
    specificType?: StringNullableFilter<"Livestock"> | string | null
    breed?: StringNullableFilter<"Livestock"> | string | null
    birthDate?: DateTimeNullableFilter<"Livestock"> | Date | string | null
    notes?: StringNullableFilter<"Livestock"> | string | null
    createdAt?: DateTimeFilter<"Livestock"> | Date | string
    lastMilkAlertAt?: DateTimeNullableFilter<"Livestock"> | Date | string | null
    weightKg?: FloatNullableFilter<"Livestock"> | number | null
    healthStatus?: StringNullableFilter<"Livestock"> | string | null
    dailyFeedKg?: FloatNullableFilter<"Livestock"> | number | null
    vaccineStatus?: StringNullableFilter<"Livestock"> | string | null
    lastCheckupDate?: DateTimeNullableFilter<"Livestock"> | Date | string | null
    customMetrics?: JsonNullableFilter<"Livestock">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    milkLogs?: MilkLogListRelationFilter
    eggLogs?: EggLogListRelationFilter
    honeyLogs?: HoneyLogListRelationFilter
    woolLogs?: WoolLogListRelationFilter
    weightLogs?: WeightLogListRelationFilter
    metrics?: LivestockMetricListRelationFilter
  }, "id">

  export type LivestockOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    animalType?: SortOrder
    specificType?: SortOrderInput | SortOrder
    breed?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastMilkAlertAt?: SortOrderInput | SortOrder
    weightKg?: SortOrderInput | SortOrder
    healthStatus?: SortOrderInput | SortOrder
    dailyFeedKg?: SortOrderInput | SortOrder
    vaccineStatus?: SortOrderInput | SortOrder
    lastCheckupDate?: SortOrderInput | SortOrder
    customMetrics?: SortOrderInput | SortOrder
    _count?: LivestockCountOrderByAggregateInput
    _avg?: LivestockAvgOrderByAggregateInput
    _max?: LivestockMaxOrderByAggregateInput
    _min?: LivestockMinOrderByAggregateInput
    _sum?: LivestockSumOrderByAggregateInput
  }

  export type LivestockScalarWhereWithAggregatesInput = {
    AND?: LivestockScalarWhereWithAggregatesInput | LivestockScalarWhereWithAggregatesInput[]
    OR?: LivestockScalarWhereWithAggregatesInput[]
    NOT?: LivestockScalarWhereWithAggregatesInput | LivestockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Livestock"> | string
    userId?: StringWithAggregatesFilter<"Livestock"> | string
    animalType?: StringWithAggregatesFilter<"Livestock"> | string
    specificType?: StringNullableWithAggregatesFilter<"Livestock"> | string | null
    breed?: StringNullableWithAggregatesFilter<"Livestock"> | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"Livestock"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Livestock"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Livestock"> | Date | string
    lastMilkAlertAt?: DateTimeNullableWithAggregatesFilter<"Livestock"> | Date | string | null
    weightKg?: FloatNullableWithAggregatesFilter<"Livestock"> | number | null
    healthStatus?: StringNullableWithAggregatesFilter<"Livestock"> | string | null
    dailyFeedKg?: FloatNullableWithAggregatesFilter<"Livestock"> | number | null
    vaccineStatus?: StringNullableWithAggregatesFilter<"Livestock"> | string | null
    lastCheckupDate?: DateTimeNullableWithAggregatesFilter<"Livestock"> | Date | string | null
    customMetrics?: JsonNullableWithAggregatesFilter<"Livestock">
  }

  export type CropSprayWhereInput = {
    AND?: CropSprayWhereInput | CropSprayWhereInput[]
    OR?: CropSprayWhereInput[]
    NOT?: CropSprayWhereInput | CropSprayWhereInput[]
    id?: StringFilter<"CropSpray"> | string
    cropId?: StringFilter<"CropSpray"> | string
    sprayedAt?: DateTimeFilter<"CropSpray"> | Date | string
    pesticide?: StringNullableFilter<"CropSpray"> | string | null
    createdAt?: DateTimeFilter<"CropSpray"> | Date | string
    crop?: XOR<CropScalarRelationFilter, CropWhereInput>
  }

  export type CropSprayOrderByWithRelationInput = {
    id?: SortOrder
    cropId?: SortOrder
    sprayedAt?: SortOrder
    pesticide?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    crop?: CropOrderByWithRelationInput
  }

  export type CropSprayWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CropSprayWhereInput | CropSprayWhereInput[]
    OR?: CropSprayWhereInput[]
    NOT?: CropSprayWhereInput | CropSprayWhereInput[]
    cropId?: StringFilter<"CropSpray"> | string
    sprayedAt?: DateTimeFilter<"CropSpray"> | Date | string
    pesticide?: StringNullableFilter<"CropSpray"> | string | null
    createdAt?: DateTimeFilter<"CropSpray"> | Date | string
    crop?: XOR<CropScalarRelationFilter, CropWhereInput>
  }, "id">

  export type CropSprayOrderByWithAggregationInput = {
    id?: SortOrder
    cropId?: SortOrder
    sprayedAt?: SortOrder
    pesticide?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CropSprayCountOrderByAggregateInput
    _max?: CropSprayMaxOrderByAggregateInput
    _min?: CropSprayMinOrderByAggregateInput
  }

  export type CropSprayScalarWhereWithAggregatesInput = {
    AND?: CropSprayScalarWhereWithAggregatesInput | CropSprayScalarWhereWithAggregatesInput[]
    OR?: CropSprayScalarWhereWithAggregatesInput[]
    NOT?: CropSprayScalarWhereWithAggregatesInput | CropSprayScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CropSpray"> | string
    cropId?: StringWithAggregatesFilter<"CropSpray"> | string
    sprayedAt?: DateTimeWithAggregatesFilter<"CropSpray"> | Date | string
    pesticide?: StringNullableWithAggregatesFilter<"CropSpray"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CropSpray"> | Date | string
  }

  export type CropHarvestWhereInput = {
    AND?: CropHarvestWhereInput | CropHarvestWhereInput[]
    OR?: CropHarvestWhereInput[]
    NOT?: CropHarvestWhereInput | CropHarvestWhereInput[]
    id?: StringFilter<"CropHarvest"> | string
    cropId?: StringFilter<"CropHarvest"> | string
    harvestedAt?: DateTimeFilter<"CropHarvest"> | Date | string
    amountTon?: FloatFilter<"CropHarvest"> | number
    yieldTonPerHa?: FloatNullableFilter<"CropHarvest"> | number | null
    createdAt?: DateTimeFilter<"CropHarvest"> | Date | string
    crop?: XOR<CropScalarRelationFilter, CropWhereInput>
  }

  export type CropHarvestOrderByWithRelationInput = {
    id?: SortOrder
    cropId?: SortOrder
    harvestedAt?: SortOrder
    amountTon?: SortOrder
    yieldTonPerHa?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    crop?: CropOrderByWithRelationInput
  }

  export type CropHarvestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CropHarvestWhereInput | CropHarvestWhereInput[]
    OR?: CropHarvestWhereInput[]
    NOT?: CropHarvestWhereInput | CropHarvestWhereInput[]
    cropId?: StringFilter<"CropHarvest"> | string
    harvestedAt?: DateTimeFilter<"CropHarvest"> | Date | string
    amountTon?: FloatFilter<"CropHarvest"> | number
    yieldTonPerHa?: FloatNullableFilter<"CropHarvest"> | number | null
    createdAt?: DateTimeFilter<"CropHarvest"> | Date | string
    crop?: XOR<CropScalarRelationFilter, CropWhereInput>
  }, "id">

  export type CropHarvestOrderByWithAggregationInput = {
    id?: SortOrder
    cropId?: SortOrder
    harvestedAt?: SortOrder
    amountTon?: SortOrder
    yieldTonPerHa?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CropHarvestCountOrderByAggregateInput
    _avg?: CropHarvestAvgOrderByAggregateInput
    _max?: CropHarvestMaxOrderByAggregateInput
    _min?: CropHarvestMinOrderByAggregateInput
    _sum?: CropHarvestSumOrderByAggregateInput
  }

  export type CropHarvestScalarWhereWithAggregatesInput = {
    AND?: CropHarvestScalarWhereWithAggregatesInput | CropHarvestScalarWhereWithAggregatesInput[]
    OR?: CropHarvestScalarWhereWithAggregatesInput[]
    NOT?: CropHarvestScalarWhereWithAggregatesInput | CropHarvestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CropHarvest"> | string
    cropId?: StringWithAggregatesFilter<"CropHarvest"> | string
    harvestedAt?: DateTimeWithAggregatesFilter<"CropHarvest"> | Date | string
    amountTon?: FloatWithAggregatesFilter<"CropHarvest"> | number
    yieldTonPerHa?: FloatNullableWithAggregatesFilter<"CropHarvest"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"CropHarvest"> | Date | string
  }

  export type MilkLogWhereInput = {
    AND?: MilkLogWhereInput | MilkLogWhereInput[]
    OR?: MilkLogWhereInput[]
    NOT?: MilkLogWhereInput | MilkLogWhereInput[]
    id?: StringFilter<"MilkLog"> | string
    livestockId?: StringFilter<"MilkLog"> | string
    measuredAt?: DateTimeFilter<"MilkLog"> | Date | string
    quantityL?: FloatFilter<"MilkLog"> | number
    fatPercent?: FloatNullableFilter<"MilkLog"> | number | null
    createdAt?: DateTimeFilter<"MilkLog"> | Date | string
    livestock?: XOR<LivestockScalarRelationFilter, LivestockWhereInput>
  }

  export type MilkLogOrderByWithRelationInput = {
    id?: SortOrder
    livestockId?: SortOrder
    measuredAt?: SortOrder
    quantityL?: SortOrder
    fatPercent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    livestock?: LivestockOrderByWithRelationInput
  }

  export type MilkLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MilkLogWhereInput | MilkLogWhereInput[]
    OR?: MilkLogWhereInput[]
    NOT?: MilkLogWhereInput | MilkLogWhereInput[]
    livestockId?: StringFilter<"MilkLog"> | string
    measuredAt?: DateTimeFilter<"MilkLog"> | Date | string
    quantityL?: FloatFilter<"MilkLog"> | number
    fatPercent?: FloatNullableFilter<"MilkLog"> | number | null
    createdAt?: DateTimeFilter<"MilkLog"> | Date | string
    livestock?: XOR<LivestockScalarRelationFilter, LivestockWhereInput>
  }, "id">

  export type MilkLogOrderByWithAggregationInput = {
    id?: SortOrder
    livestockId?: SortOrder
    measuredAt?: SortOrder
    quantityL?: SortOrder
    fatPercent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MilkLogCountOrderByAggregateInput
    _avg?: MilkLogAvgOrderByAggregateInput
    _max?: MilkLogMaxOrderByAggregateInput
    _min?: MilkLogMinOrderByAggregateInput
    _sum?: MilkLogSumOrderByAggregateInput
  }

  export type MilkLogScalarWhereWithAggregatesInput = {
    AND?: MilkLogScalarWhereWithAggregatesInput | MilkLogScalarWhereWithAggregatesInput[]
    OR?: MilkLogScalarWhereWithAggregatesInput[]
    NOT?: MilkLogScalarWhereWithAggregatesInput | MilkLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MilkLog"> | string
    livestockId?: StringWithAggregatesFilter<"MilkLog"> | string
    measuredAt?: DateTimeWithAggregatesFilter<"MilkLog"> | Date | string
    quantityL?: FloatWithAggregatesFilter<"MilkLog"> | number
    fatPercent?: FloatNullableWithAggregatesFilter<"MilkLog"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"MilkLog"> | Date | string
  }

  export type EggLogWhereInput = {
    AND?: EggLogWhereInput | EggLogWhereInput[]
    OR?: EggLogWhereInput[]
    NOT?: EggLogWhereInput | EggLogWhereInput[]
    id?: StringFilter<"EggLog"> | string
    livestockId?: StringFilter<"EggLog"> | string
    measuredAt?: DateTimeFilter<"EggLog"> | Date | string
    eggCount?: IntFilter<"EggLog"> | number
    avgWeightGram?: FloatNullableFilter<"EggLog"> | number | null
    createdAt?: DateTimeFilter<"EggLog"> | Date | string
    livestock?: XOR<LivestockScalarRelationFilter, LivestockWhereInput>
  }

  export type EggLogOrderByWithRelationInput = {
    id?: SortOrder
    livestockId?: SortOrder
    measuredAt?: SortOrder
    eggCount?: SortOrder
    avgWeightGram?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    livestock?: LivestockOrderByWithRelationInput
  }

  export type EggLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EggLogWhereInput | EggLogWhereInput[]
    OR?: EggLogWhereInput[]
    NOT?: EggLogWhereInput | EggLogWhereInput[]
    livestockId?: StringFilter<"EggLog"> | string
    measuredAt?: DateTimeFilter<"EggLog"> | Date | string
    eggCount?: IntFilter<"EggLog"> | number
    avgWeightGram?: FloatNullableFilter<"EggLog"> | number | null
    createdAt?: DateTimeFilter<"EggLog"> | Date | string
    livestock?: XOR<LivestockScalarRelationFilter, LivestockWhereInput>
  }, "id">

  export type EggLogOrderByWithAggregationInput = {
    id?: SortOrder
    livestockId?: SortOrder
    measuredAt?: SortOrder
    eggCount?: SortOrder
    avgWeightGram?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EggLogCountOrderByAggregateInput
    _avg?: EggLogAvgOrderByAggregateInput
    _max?: EggLogMaxOrderByAggregateInput
    _min?: EggLogMinOrderByAggregateInput
    _sum?: EggLogSumOrderByAggregateInput
  }

  export type EggLogScalarWhereWithAggregatesInput = {
    AND?: EggLogScalarWhereWithAggregatesInput | EggLogScalarWhereWithAggregatesInput[]
    OR?: EggLogScalarWhereWithAggregatesInput[]
    NOT?: EggLogScalarWhereWithAggregatesInput | EggLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EggLog"> | string
    livestockId?: StringWithAggregatesFilter<"EggLog"> | string
    measuredAt?: DateTimeWithAggregatesFilter<"EggLog"> | Date | string
    eggCount?: IntWithAggregatesFilter<"EggLog"> | number
    avgWeightGram?: FloatNullableWithAggregatesFilter<"EggLog"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"EggLog"> | Date | string
  }

  export type HoneyLogWhereInput = {
    AND?: HoneyLogWhereInput | HoneyLogWhereInput[]
    OR?: HoneyLogWhereInput[]
    NOT?: HoneyLogWhereInput | HoneyLogWhereInput[]
    id?: StringFilter<"HoneyLog"> | string
    livestockId?: StringFilter<"HoneyLog"> | string
    measuredAt?: DateTimeFilter<"HoneyLog"> | Date | string
    amountKg?: FloatFilter<"HoneyLog"> | number
    qualityGrade?: StringNullableFilter<"HoneyLog"> | string | null
    createdAt?: DateTimeFilter<"HoneyLog"> | Date | string
    livestock?: XOR<LivestockScalarRelationFilter, LivestockWhereInput>
  }

  export type HoneyLogOrderByWithRelationInput = {
    id?: SortOrder
    livestockId?: SortOrder
    measuredAt?: SortOrder
    amountKg?: SortOrder
    qualityGrade?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    livestock?: LivestockOrderByWithRelationInput
  }

  export type HoneyLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HoneyLogWhereInput | HoneyLogWhereInput[]
    OR?: HoneyLogWhereInput[]
    NOT?: HoneyLogWhereInput | HoneyLogWhereInput[]
    livestockId?: StringFilter<"HoneyLog"> | string
    measuredAt?: DateTimeFilter<"HoneyLog"> | Date | string
    amountKg?: FloatFilter<"HoneyLog"> | number
    qualityGrade?: StringNullableFilter<"HoneyLog"> | string | null
    createdAt?: DateTimeFilter<"HoneyLog"> | Date | string
    livestock?: XOR<LivestockScalarRelationFilter, LivestockWhereInput>
  }, "id">

  export type HoneyLogOrderByWithAggregationInput = {
    id?: SortOrder
    livestockId?: SortOrder
    measuredAt?: SortOrder
    amountKg?: SortOrder
    qualityGrade?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: HoneyLogCountOrderByAggregateInput
    _avg?: HoneyLogAvgOrderByAggregateInput
    _max?: HoneyLogMaxOrderByAggregateInput
    _min?: HoneyLogMinOrderByAggregateInput
    _sum?: HoneyLogSumOrderByAggregateInput
  }

  export type HoneyLogScalarWhereWithAggregatesInput = {
    AND?: HoneyLogScalarWhereWithAggregatesInput | HoneyLogScalarWhereWithAggregatesInput[]
    OR?: HoneyLogScalarWhereWithAggregatesInput[]
    NOT?: HoneyLogScalarWhereWithAggregatesInput | HoneyLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HoneyLog"> | string
    livestockId?: StringWithAggregatesFilter<"HoneyLog"> | string
    measuredAt?: DateTimeWithAggregatesFilter<"HoneyLog"> | Date | string
    amountKg?: FloatWithAggregatesFilter<"HoneyLog"> | number
    qualityGrade?: StringNullableWithAggregatesFilter<"HoneyLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"HoneyLog"> | Date | string
  }

  export type WoolLogWhereInput = {
    AND?: WoolLogWhereInput | WoolLogWhereInput[]
    OR?: WoolLogWhereInput[]
    NOT?: WoolLogWhereInput | WoolLogWhereInput[]
    id?: StringFilter<"WoolLog"> | string
    livestockId?: StringFilter<"WoolLog"> | string
    shearedAt?: DateTimeFilter<"WoolLog"> | Date | string
    amountKg?: FloatFilter<"WoolLog"> | number
    qualityGrade?: StringNullableFilter<"WoolLog"> | string | null
    createdAt?: DateTimeFilter<"WoolLog"> | Date | string
    livestock?: XOR<LivestockScalarRelationFilter, LivestockWhereInput>
  }

  export type WoolLogOrderByWithRelationInput = {
    id?: SortOrder
    livestockId?: SortOrder
    shearedAt?: SortOrder
    amountKg?: SortOrder
    qualityGrade?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    livestock?: LivestockOrderByWithRelationInput
  }

  export type WoolLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WoolLogWhereInput | WoolLogWhereInput[]
    OR?: WoolLogWhereInput[]
    NOT?: WoolLogWhereInput | WoolLogWhereInput[]
    livestockId?: StringFilter<"WoolLog"> | string
    shearedAt?: DateTimeFilter<"WoolLog"> | Date | string
    amountKg?: FloatFilter<"WoolLog"> | number
    qualityGrade?: StringNullableFilter<"WoolLog"> | string | null
    createdAt?: DateTimeFilter<"WoolLog"> | Date | string
    livestock?: XOR<LivestockScalarRelationFilter, LivestockWhereInput>
  }, "id">

  export type WoolLogOrderByWithAggregationInput = {
    id?: SortOrder
    livestockId?: SortOrder
    shearedAt?: SortOrder
    amountKg?: SortOrder
    qualityGrade?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WoolLogCountOrderByAggregateInput
    _avg?: WoolLogAvgOrderByAggregateInput
    _max?: WoolLogMaxOrderByAggregateInput
    _min?: WoolLogMinOrderByAggregateInput
    _sum?: WoolLogSumOrderByAggregateInput
  }

  export type WoolLogScalarWhereWithAggregatesInput = {
    AND?: WoolLogScalarWhereWithAggregatesInput | WoolLogScalarWhereWithAggregatesInput[]
    OR?: WoolLogScalarWhereWithAggregatesInput[]
    NOT?: WoolLogScalarWhereWithAggregatesInput | WoolLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WoolLog"> | string
    livestockId?: StringWithAggregatesFilter<"WoolLog"> | string
    shearedAt?: DateTimeWithAggregatesFilter<"WoolLog"> | Date | string
    amountKg?: FloatWithAggregatesFilter<"WoolLog"> | number
    qualityGrade?: StringNullableWithAggregatesFilter<"WoolLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WoolLog"> | Date | string
  }

  export type WeightLogWhereInput = {
    AND?: WeightLogWhereInput | WeightLogWhereInput[]
    OR?: WeightLogWhereInput[]
    NOT?: WeightLogWhereInput | WeightLogWhereInput[]
    id?: StringFilter<"WeightLog"> | string
    livestockId?: StringFilter<"WeightLog"> | string
    measuredAt?: DateTimeFilter<"WeightLog"> | Date | string
    weightKg?: FloatFilter<"WeightLog"> | number
    notes?: StringNullableFilter<"WeightLog"> | string | null
    createdAt?: DateTimeFilter<"WeightLog"> | Date | string
    livestock?: XOR<LivestockScalarRelationFilter, LivestockWhereInput>
  }

  export type WeightLogOrderByWithRelationInput = {
    id?: SortOrder
    livestockId?: SortOrder
    measuredAt?: SortOrder
    weightKg?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    livestock?: LivestockOrderByWithRelationInput
  }

  export type WeightLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WeightLogWhereInput | WeightLogWhereInput[]
    OR?: WeightLogWhereInput[]
    NOT?: WeightLogWhereInput | WeightLogWhereInput[]
    livestockId?: StringFilter<"WeightLog"> | string
    measuredAt?: DateTimeFilter<"WeightLog"> | Date | string
    weightKg?: FloatFilter<"WeightLog"> | number
    notes?: StringNullableFilter<"WeightLog"> | string | null
    createdAt?: DateTimeFilter<"WeightLog"> | Date | string
    livestock?: XOR<LivestockScalarRelationFilter, LivestockWhereInput>
  }, "id">

  export type WeightLogOrderByWithAggregationInput = {
    id?: SortOrder
    livestockId?: SortOrder
    measuredAt?: SortOrder
    weightKg?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WeightLogCountOrderByAggregateInput
    _avg?: WeightLogAvgOrderByAggregateInput
    _max?: WeightLogMaxOrderByAggregateInput
    _min?: WeightLogMinOrderByAggregateInput
    _sum?: WeightLogSumOrderByAggregateInput
  }

  export type WeightLogScalarWhereWithAggregatesInput = {
    AND?: WeightLogScalarWhereWithAggregatesInput | WeightLogScalarWhereWithAggregatesInput[]
    OR?: WeightLogScalarWhereWithAggregatesInput[]
    NOT?: WeightLogScalarWhereWithAggregatesInput | WeightLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WeightLog"> | string
    livestockId?: StringWithAggregatesFilter<"WeightLog"> | string
    measuredAt?: DateTimeWithAggregatesFilter<"WeightLog"> | Date | string
    weightKg?: FloatWithAggregatesFilter<"WeightLog"> | number
    notes?: StringNullableWithAggregatesFilter<"WeightLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WeightLog"> | Date | string
  }

  export type LivestockMetricWhereInput = {
    AND?: LivestockMetricWhereInput | LivestockMetricWhereInput[]
    OR?: LivestockMetricWhereInput[]
    NOT?: LivestockMetricWhereInput | LivestockMetricWhereInput[]
    id?: StringFilter<"LivestockMetric"> | string
    livestockId?: StringFilter<"LivestockMetric"> | string
    key?: StringFilter<"LivestockMetric"> | string
    value?: JsonNullableFilter<"LivestockMetric">
    createdAt?: DateTimeFilter<"LivestockMetric"> | Date | string
    updatedAt?: DateTimeFilter<"LivestockMetric"> | Date | string
    livestock?: XOR<LivestockScalarRelationFilter, LivestockWhereInput>
  }

  export type LivestockMetricOrderByWithRelationInput = {
    id?: SortOrder
    livestockId?: SortOrder
    key?: SortOrder
    value?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    livestock?: LivestockOrderByWithRelationInput
  }

  export type LivestockMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LivestockMetricWhereInput | LivestockMetricWhereInput[]
    OR?: LivestockMetricWhereInput[]
    NOT?: LivestockMetricWhereInput | LivestockMetricWhereInput[]
    livestockId?: StringFilter<"LivestockMetric"> | string
    key?: StringFilter<"LivestockMetric"> | string
    value?: JsonNullableFilter<"LivestockMetric">
    createdAt?: DateTimeFilter<"LivestockMetric"> | Date | string
    updatedAt?: DateTimeFilter<"LivestockMetric"> | Date | string
    livestock?: XOR<LivestockScalarRelationFilter, LivestockWhereInput>
  }, "id">

  export type LivestockMetricOrderByWithAggregationInput = {
    id?: SortOrder
    livestockId?: SortOrder
    key?: SortOrder
    value?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LivestockMetricCountOrderByAggregateInput
    _max?: LivestockMetricMaxOrderByAggregateInput
    _min?: LivestockMetricMinOrderByAggregateInput
  }

  export type LivestockMetricScalarWhereWithAggregatesInput = {
    AND?: LivestockMetricScalarWhereWithAggregatesInput | LivestockMetricScalarWhereWithAggregatesInput[]
    OR?: LivestockMetricScalarWhereWithAggregatesInput[]
    NOT?: LivestockMetricScalarWhereWithAggregatesInput | LivestockMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LivestockMetric"> | string
    livestockId?: StringWithAggregatesFilter<"LivestockMetric"> | string
    key?: StringWithAggregatesFilter<"LivestockMetric"> | string
    value?: JsonNullableWithAggregatesFilter<"LivestockMetric">
    createdAt?: DateTimeWithAggregatesFilter<"LivestockMetric"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LivestockMetric"> | Date | string
  }

  export type CropQualityLogWhereInput = {
    AND?: CropQualityLogWhereInput | CropQualityLogWhereInput[]
    OR?: CropQualityLogWhereInput[]
    NOT?: CropQualityLogWhereInput | CropQualityLogWhereInput[]
    id?: StringFilter<"CropQualityLog"> | string
    cropId?: StringFilter<"CropQualityLog"> | string
    measuredAt?: DateTimeFilter<"CropQualityLog"> | Date | string
    proteinPercent?: FloatNullableFilter<"CropQualityLog"> | number | null
    moisturePercent?: FloatNullableFilter<"CropQualityLog"> | number | null
    sugarPercent?: FloatNullableFilter<"CropQualityLog"> | number | null
    oilPercent?: FloatNullableFilter<"CropQualityLog"> | number | null
    notes?: StringNullableFilter<"CropQualityLog"> | string | null
    createdAt?: DateTimeFilter<"CropQualityLog"> | Date | string
    crop?: XOR<CropScalarRelationFilter, CropWhereInput>
  }

  export type CropQualityLogOrderByWithRelationInput = {
    id?: SortOrder
    cropId?: SortOrder
    measuredAt?: SortOrder
    proteinPercent?: SortOrderInput | SortOrder
    moisturePercent?: SortOrderInput | SortOrder
    sugarPercent?: SortOrderInput | SortOrder
    oilPercent?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    crop?: CropOrderByWithRelationInput
  }

  export type CropQualityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CropQualityLogWhereInput | CropQualityLogWhereInput[]
    OR?: CropQualityLogWhereInput[]
    NOT?: CropQualityLogWhereInput | CropQualityLogWhereInput[]
    cropId?: StringFilter<"CropQualityLog"> | string
    measuredAt?: DateTimeFilter<"CropQualityLog"> | Date | string
    proteinPercent?: FloatNullableFilter<"CropQualityLog"> | number | null
    moisturePercent?: FloatNullableFilter<"CropQualityLog"> | number | null
    sugarPercent?: FloatNullableFilter<"CropQualityLog"> | number | null
    oilPercent?: FloatNullableFilter<"CropQualityLog"> | number | null
    notes?: StringNullableFilter<"CropQualityLog"> | string | null
    createdAt?: DateTimeFilter<"CropQualityLog"> | Date | string
    crop?: XOR<CropScalarRelationFilter, CropWhereInput>
  }, "id">

  export type CropQualityLogOrderByWithAggregationInput = {
    id?: SortOrder
    cropId?: SortOrder
    measuredAt?: SortOrder
    proteinPercent?: SortOrderInput | SortOrder
    moisturePercent?: SortOrderInput | SortOrder
    sugarPercent?: SortOrderInput | SortOrder
    oilPercent?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CropQualityLogCountOrderByAggregateInput
    _avg?: CropQualityLogAvgOrderByAggregateInput
    _max?: CropQualityLogMaxOrderByAggregateInput
    _min?: CropQualityLogMinOrderByAggregateInput
    _sum?: CropQualityLogSumOrderByAggregateInput
  }

  export type CropQualityLogScalarWhereWithAggregatesInput = {
    AND?: CropQualityLogScalarWhereWithAggregatesInput | CropQualityLogScalarWhereWithAggregatesInput[]
    OR?: CropQualityLogScalarWhereWithAggregatesInput[]
    NOT?: CropQualityLogScalarWhereWithAggregatesInput | CropQualityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CropQualityLog"> | string
    cropId?: StringWithAggregatesFilter<"CropQualityLog"> | string
    measuredAt?: DateTimeWithAggregatesFilter<"CropQualityLog"> | Date | string
    proteinPercent?: FloatNullableWithAggregatesFilter<"CropQualityLog"> | number | null
    moisturePercent?: FloatNullableWithAggregatesFilter<"CropQualityLog"> | number | null
    sugarPercent?: FloatNullableWithAggregatesFilter<"CropQualityLog"> | number | null
    oilPercent?: FloatNullableWithAggregatesFilter<"CropQualityLog"> | number | null
    notes?: StringNullableWithAggregatesFilter<"CropQualityLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CropQualityLog"> | Date | string
  }

  export type CropMetricWhereInput = {
    AND?: CropMetricWhereInput | CropMetricWhereInput[]
    OR?: CropMetricWhereInput[]
    NOT?: CropMetricWhereInput | CropMetricWhereInput[]
    id?: StringFilter<"CropMetric"> | string
    cropId?: StringFilter<"CropMetric"> | string
    key?: StringFilter<"CropMetric"> | string
    value?: JsonNullableFilter<"CropMetric">
    createdAt?: DateTimeFilter<"CropMetric"> | Date | string
    updatedAt?: DateTimeFilter<"CropMetric"> | Date | string
    crop?: XOR<CropScalarRelationFilter, CropWhereInput>
  }

  export type CropMetricOrderByWithRelationInput = {
    id?: SortOrder
    cropId?: SortOrder
    key?: SortOrder
    value?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    crop?: CropOrderByWithRelationInput
  }

  export type CropMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CropMetricWhereInput | CropMetricWhereInput[]
    OR?: CropMetricWhereInput[]
    NOT?: CropMetricWhereInput | CropMetricWhereInput[]
    cropId?: StringFilter<"CropMetric"> | string
    key?: StringFilter<"CropMetric"> | string
    value?: JsonNullableFilter<"CropMetric">
    createdAt?: DateTimeFilter<"CropMetric"> | Date | string
    updatedAt?: DateTimeFilter<"CropMetric"> | Date | string
    crop?: XOR<CropScalarRelationFilter, CropWhereInput>
  }, "id">

  export type CropMetricOrderByWithAggregationInput = {
    id?: SortOrder
    cropId?: SortOrder
    key?: SortOrder
    value?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CropMetricCountOrderByAggregateInput
    _max?: CropMetricMaxOrderByAggregateInput
    _min?: CropMetricMinOrderByAggregateInput
  }

  export type CropMetricScalarWhereWithAggregatesInput = {
    AND?: CropMetricScalarWhereWithAggregatesInput | CropMetricScalarWhereWithAggregatesInput[]
    OR?: CropMetricScalarWhereWithAggregatesInput[]
    NOT?: CropMetricScalarWhereWithAggregatesInput | CropMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CropMetric"> | string
    cropId?: StringWithAggregatesFilter<"CropMetric"> | string
    key?: StringWithAggregatesFilter<"CropMetric"> | string
    value?: JsonNullableWithAggregatesFilter<"CropMetric">
    createdAt?: DateTimeWithAggregatesFilter<"CropMetric"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CropMetric"> | Date | string
  }

  export type SupportProgramWhereInput = {
    AND?: SupportProgramWhereInput | SupportProgramWhereInput[]
    OR?: SupportProgramWhereInput[]
    NOT?: SupportProgramWhereInput | SupportProgramWhereInput[]
    id?: StringFilter<"SupportProgram"> | string
    title?: StringFilter<"SupportProgram"> | string
    titleEn?: StringNullableFilter<"SupportProgram"> | string | null
    description?: StringNullableFilter<"SupportProgram"> | string | null
    descriptionEn?: StringNullableFilter<"SupportProgram"> | string | null
    category?: StringFilter<"SupportProgram"> | string
    subcategory?: StringNullableFilter<"SupportProgram"> | string | null
    amount?: StringNullableFilter<"SupportProgram"> | string | null
    amountEn?: StringNullableFilter<"SupportProgram"> | string | null
    eligibility?: StringNullableFilter<"SupportProgram"> | string | null
    eligibilityEn?: StringNullableFilter<"SupportProgram"> | string | null
    requiredDocs?: StringNullableFilter<"SupportProgram"> | string | null
    requiredDocsEn?: StringNullableFilter<"SupportProgram"> | string | null
    applicationStart?: DateTimeNullableFilter<"SupportProgram"> | Date | string | null
    applicationDeadline?: DateTimeNullableFilter<"SupportProgram"> | Date | string | null
    link?: StringNullableFilter<"SupportProgram"> | string | null
    status?: StringFilter<"SupportProgram"> | string
    targetCrops?: StringNullableFilter<"SupportProgram"> | string | null
    targetLivestock?: StringNullableFilter<"SupportProgram"> | string | null
    region?: StringNullableFilter<"SupportProgram"> | string | null
    priority?: IntFilter<"SupportProgram"> | number
    createdAt?: DateTimeFilter<"SupportProgram"> | Date | string
    updatedAt?: DateTimeFilter<"SupportProgram"> | Date | string
  }

  export type SupportProgramOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    descriptionEn?: SortOrderInput | SortOrder
    category?: SortOrder
    subcategory?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    amountEn?: SortOrderInput | SortOrder
    eligibility?: SortOrderInput | SortOrder
    eligibilityEn?: SortOrderInput | SortOrder
    requiredDocs?: SortOrderInput | SortOrder
    requiredDocsEn?: SortOrderInput | SortOrder
    applicationStart?: SortOrderInput | SortOrder
    applicationDeadline?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    status?: SortOrder
    targetCrops?: SortOrderInput | SortOrder
    targetLivestock?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupportProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupportProgramWhereInput | SupportProgramWhereInput[]
    OR?: SupportProgramWhereInput[]
    NOT?: SupportProgramWhereInput | SupportProgramWhereInput[]
    title?: StringFilter<"SupportProgram"> | string
    titleEn?: StringNullableFilter<"SupportProgram"> | string | null
    description?: StringNullableFilter<"SupportProgram"> | string | null
    descriptionEn?: StringNullableFilter<"SupportProgram"> | string | null
    category?: StringFilter<"SupportProgram"> | string
    subcategory?: StringNullableFilter<"SupportProgram"> | string | null
    amount?: StringNullableFilter<"SupportProgram"> | string | null
    amountEn?: StringNullableFilter<"SupportProgram"> | string | null
    eligibility?: StringNullableFilter<"SupportProgram"> | string | null
    eligibilityEn?: StringNullableFilter<"SupportProgram"> | string | null
    requiredDocs?: StringNullableFilter<"SupportProgram"> | string | null
    requiredDocsEn?: StringNullableFilter<"SupportProgram"> | string | null
    applicationStart?: DateTimeNullableFilter<"SupportProgram"> | Date | string | null
    applicationDeadline?: DateTimeNullableFilter<"SupportProgram"> | Date | string | null
    link?: StringNullableFilter<"SupportProgram"> | string | null
    status?: StringFilter<"SupportProgram"> | string
    targetCrops?: StringNullableFilter<"SupportProgram"> | string | null
    targetLivestock?: StringNullableFilter<"SupportProgram"> | string | null
    region?: StringNullableFilter<"SupportProgram"> | string | null
    priority?: IntFilter<"SupportProgram"> | number
    createdAt?: DateTimeFilter<"SupportProgram"> | Date | string
    updatedAt?: DateTimeFilter<"SupportProgram"> | Date | string
  }, "id">

  export type SupportProgramOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    descriptionEn?: SortOrderInput | SortOrder
    category?: SortOrder
    subcategory?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    amountEn?: SortOrderInput | SortOrder
    eligibility?: SortOrderInput | SortOrder
    eligibilityEn?: SortOrderInput | SortOrder
    requiredDocs?: SortOrderInput | SortOrder
    requiredDocsEn?: SortOrderInput | SortOrder
    applicationStart?: SortOrderInput | SortOrder
    applicationDeadline?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    status?: SortOrder
    targetCrops?: SortOrderInput | SortOrder
    targetLivestock?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupportProgramCountOrderByAggregateInput
    _avg?: SupportProgramAvgOrderByAggregateInput
    _max?: SupportProgramMaxOrderByAggregateInput
    _min?: SupportProgramMinOrderByAggregateInput
    _sum?: SupportProgramSumOrderByAggregateInput
  }

  export type SupportProgramScalarWhereWithAggregatesInput = {
    AND?: SupportProgramScalarWhereWithAggregatesInput | SupportProgramScalarWhereWithAggregatesInput[]
    OR?: SupportProgramScalarWhereWithAggregatesInput[]
    NOT?: SupportProgramScalarWhereWithAggregatesInput | SupportProgramScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SupportProgram"> | string
    title?: StringWithAggregatesFilter<"SupportProgram"> | string
    titleEn?: StringNullableWithAggregatesFilter<"SupportProgram"> | string | null
    description?: StringNullableWithAggregatesFilter<"SupportProgram"> | string | null
    descriptionEn?: StringNullableWithAggregatesFilter<"SupportProgram"> | string | null
    category?: StringWithAggregatesFilter<"SupportProgram"> | string
    subcategory?: StringNullableWithAggregatesFilter<"SupportProgram"> | string | null
    amount?: StringNullableWithAggregatesFilter<"SupportProgram"> | string | null
    amountEn?: StringNullableWithAggregatesFilter<"SupportProgram"> | string | null
    eligibility?: StringNullableWithAggregatesFilter<"SupportProgram"> | string | null
    eligibilityEn?: StringNullableWithAggregatesFilter<"SupportProgram"> | string | null
    requiredDocs?: StringNullableWithAggregatesFilter<"SupportProgram"> | string | null
    requiredDocsEn?: StringNullableWithAggregatesFilter<"SupportProgram"> | string | null
    applicationStart?: DateTimeNullableWithAggregatesFilter<"SupportProgram"> | Date | string | null
    applicationDeadline?: DateTimeNullableWithAggregatesFilter<"SupportProgram"> | Date | string | null
    link?: StringNullableWithAggregatesFilter<"SupportProgram"> | string | null
    status?: StringWithAggregatesFilter<"SupportProgram"> | string
    targetCrops?: StringNullableWithAggregatesFilter<"SupportProgram"> | string | null
    targetLivestock?: StringNullableWithAggregatesFilter<"SupportProgram"> | string | null
    region?: StringNullableWithAggregatesFilter<"SupportProgram"> | string | null
    priority?: IntWithAggregatesFilter<"SupportProgram"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SupportProgram"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupportProgram"> | Date | string
  }

  export type WeatherAlertWhereInput = {
    AND?: WeatherAlertWhereInput | WeatherAlertWhereInput[]
    OR?: WeatherAlertWhereInput[]
    NOT?: WeatherAlertWhereInput | WeatherAlertWhereInput[]
    id?: StringFilter<"WeatherAlert"> | string
    alertType?: StringFilter<"WeatherAlert"> | string
    description?: StringNullableFilter<"WeatherAlert"> | string | null
    startsAt?: DateTimeNullableFilter<"WeatherAlert"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"WeatherAlert"> | Date | string | null
    region?: StringNullableFilter<"WeatherAlert"> | string | null
    createdAt?: DateTimeFilter<"WeatherAlert"> | Date | string
  }

  export type WeatherAlertOrderByWithRelationInput = {
    id?: SortOrder
    alertType?: SortOrder
    description?: SortOrderInput | SortOrder
    startsAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type WeatherAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WeatherAlertWhereInput | WeatherAlertWhereInput[]
    OR?: WeatherAlertWhereInput[]
    NOT?: WeatherAlertWhereInput | WeatherAlertWhereInput[]
    alertType?: StringFilter<"WeatherAlert"> | string
    description?: StringNullableFilter<"WeatherAlert"> | string | null
    startsAt?: DateTimeNullableFilter<"WeatherAlert"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"WeatherAlert"> | Date | string | null
    region?: StringNullableFilter<"WeatherAlert"> | string | null
    createdAt?: DateTimeFilter<"WeatherAlert"> | Date | string
  }, "id">

  export type WeatherAlertOrderByWithAggregationInput = {
    id?: SortOrder
    alertType?: SortOrder
    description?: SortOrderInput | SortOrder
    startsAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WeatherAlertCountOrderByAggregateInput
    _max?: WeatherAlertMaxOrderByAggregateInput
    _min?: WeatherAlertMinOrderByAggregateInput
  }

  export type WeatherAlertScalarWhereWithAggregatesInput = {
    AND?: WeatherAlertScalarWhereWithAggregatesInput | WeatherAlertScalarWhereWithAggregatesInput[]
    OR?: WeatherAlertScalarWhereWithAggregatesInput[]
    NOT?: WeatherAlertScalarWhereWithAggregatesInput | WeatherAlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WeatherAlert"> | string
    alertType?: StringWithAggregatesFilter<"WeatherAlert"> | string
    description?: StringNullableWithAggregatesFilter<"WeatherAlert"> | string | null
    startsAt?: DateTimeNullableWithAggregatesFilter<"WeatherAlert"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"WeatherAlert"> | Date | string | null
    region?: StringNullableWithAggregatesFilter<"WeatherAlert"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WeatherAlert"> | Date | string
  }

  export type MarketListingWhereInput = {
    AND?: MarketListingWhereInput | MarketListingWhereInput[]
    OR?: MarketListingWhereInput[]
    NOT?: MarketListingWhereInput | MarketListingWhereInput[]
    id?: StringFilter<"MarketListing"> | string
    userId?: StringFilter<"MarketListing"> | string
    itemType?: EnumItemTypeFilter<"MarketListing"> | $Enums.ItemType
    itemRef?: StringFilter<"MarketListing"> | string
    price?: DecimalNullableFilter<"MarketListing"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"MarketListing"> | string
    isActive?: BoolFilter<"MarketListing"> | boolean
    createdAt?: DateTimeFilter<"MarketListing"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MarketListingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    itemType?: SortOrder
    itemRef?: SortOrder
    price?: SortOrderInput | SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MarketListingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarketListingWhereInput | MarketListingWhereInput[]
    OR?: MarketListingWhereInput[]
    NOT?: MarketListingWhereInput | MarketListingWhereInput[]
    userId?: StringFilter<"MarketListing"> | string
    itemType?: EnumItemTypeFilter<"MarketListing"> | $Enums.ItemType
    itemRef?: StringFilter<"MarketListing"> | string
    price?: DecimalNullableFilter<"MarketListing"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"MarketListing"> | string
    isActive?: BoolFilter<"MarketListing"> | boolean
    createdAt?: DateTimeFilter<"MarketListing"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MarketListingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    itemType?: SortOrder
    itemRef?: SortOrder
    price?: SortOrderInput | SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: MarketListingCountOrderByAggregateInput
    _avg?: MarketListingAvgOrderByAggregateInput
    _max?: MarketListingMaxOrderByAggregateInput
    _min?: MarketListingMinOrderByAggregateInput
    _sum?: MarketListingSumOrderByAggregateInput
  }

  export type MarketListingScalarWhereWithAggregatesInput = {
    AND?: MarketListingScalarWhereWithAggregatesInput | MarketListingScalarWhereWithAggregatesInput[]
    OR?: MarketListingScalarWhereWithAggregatesInput[]
    NOT?: MarketListingScalarWhereWithAggregatesInput | MarketListingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketListing"> | string
    userId?: StringWithAggregatesFilter<"MarketListing"> | string
    itemType?: EnumItemTypeWithAggregatesFilter<"MarketListing"> | $Enums.ItemType
    itemRef?: StringWithAggregatesFilter<"MarketListing"> | string
    price?: DecimalNullableWithAggregatesFilter<"MarketListing"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringWithAggregatesFilter<"MarketListing"> | string
    isActive?: BoolWithAggregatesFilter<"MarketListing"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MarketListing"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    category?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    category?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    category?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    category?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    body?: StringWithAggregatesFilter<"Notification"> | string
    category?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    fullName?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    crops?: CropCreateNestedManyWithoutUserInput
    livestock?: LivestockCreateNestedManyWithoutUserInput
    listings?: MarketListingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    fullName?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    crops?: CropUncheckedCreateNestedManyWithoutUserInput
    livestock?: LivestockUncheckedCreateNestedManyWithoutUserInput
    listings?: MarketListingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crops?: CropUpdateManyWithoutUserNestedInput
    livestock?: LivestockUpdateManyWithoutUserNestedInput
    listings?: MarketListingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crops?: CropUncheckedUpdateManyWithoutUserNestedInput
    livestock?: LivestockUncheckedUpdateManyWithoutUserNestedInput
    listings?: MarketListingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    fullName?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropCreateInput = {
    id?: string
    cropType: string
    specificType?: string | null
    plantingDate: Date | string
    harvestDate?: Date | string | null
    notes?: string | null
    areaHectares?: number | null
    pesticide?: string | null
    createdAt?: Date | string
    nextSprayDueAt?: Date | string | null
    lastSprayAlertAt?: Date | string | null
    proteinPercent?: number | null
    moisturePercent?: number | null
    sugarPercent?: number | null
    oilPercent?: number | null
    healthStatus?: string | null
    diseaseNotes?: string | null
    qualityScore?: number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutCropsInput
    sprays?: CropSprayCreateNestedManyWithoutCropInput
    harvests?: CropHarvestCreateNestedManyWithoutCropInput
    qualityLogs?: CropQualityLogCreateNestedManyWithoutCropInput
    metrics?: CropMetricCreateNestedManyWithoutCropInput
  }

  export type CropUncheckedCreateInput = {
    id?: string
    userId: string
    cropType: string
    specificType?: string | null
    plantingDate: Date | string
    harvestDate?: Date | string | null
    notes?: string | null
    areaHectares?: number | null
    pesticide?: string | null
    createdAt?: Date | string
    nextSprayDueAt?: Date | string | null
    lastSprayAlertAt?: Date | string | null
    proteinPercent?: number | null
    moisturePercent?: number | null
    sugarPercent?: number | null
    oilPercent?: number | null
    healthStatus?: string | null
    diseaseNotes?: string | null
    qualityScore?: number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    sprays?: CropSprayUncheckedCreateNestedManyWithoutCropInput
    harvests?: CropHarvestUncheckedCreateNestedManyWithoutCropInput
    qualityLogs?: CropQualityLogUncheckedCreateNestedManyWithoutCropInput
    metrics?: CropMetricUncheckedCreateNestedManyWithoutCropInput
  }

  export type CropUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    areaHectares?: NullableFloatFieldUpdateOperationsInput | number | null
    pesticide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextSprayDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSprayAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proteinPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    moisturePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    sugarPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    oilPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diseaseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutCropsNestedInput
    sprays?: CropSprayUpdateManyWithoutCropNestedInput
    harvests?: CropHarvestUpdateManyWithoutCropNestedInput
    qualityLogs?: CropQualityLogUpdateManyWithoutCropNestedInput
    metrics?: CropMetricUpdateManyWithoutCropNestedInput
  }

  export type CropUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cropType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    areaHectares?: NullableFloatFieldUpdateOperationsInput | number | null
    pesticide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextSprayDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSprayAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proteinPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    moisturePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    sugarPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    oilPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diseaseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    sprays?: CropSprayUncheckedUpdateManyWithoutCropNestedInput
    harvests?: CropHarvestUncheckedUpdateManyWithoutCropNestedInput
    qualityLogs?: CropQualityLogUncheckedUpdateManyWithoutCropNestedInput
    metrics?: CropMetricUncheckedUpdateManyWithoutCropNestedInput
  }

  export type CropCreateManyInput = {
    id?: string
    userId: string
    cropType: string
    specificType?: string | null
    plantingDate: Date | string
    harvestDate?: Date | string | null
    notes?: string | null
    areaHectares?: number | null
    pesticide?: string | null
    createdAt?: Date | string
    nextSprayDueAt?: Date | string | null
    lastSprayAlertAt?: Date | string | null
    proteinPercent?: number | null
    moisturePercent?: number | null
    sugarPercent?: number | null
    oilPercent?: number | null
    healthStatus?: string | null
    diseaseNotes?: string | null
    qualityScore?: number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CropUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    areaHectares?: NullableFloatFieldUpdateOperationsInput | number | null
    pesticide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextSprayDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSprayAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proteinPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    moisturePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    sugarPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    oilPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diseaseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CropUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cropType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    areaHectares?: NullableFloatFieldUpdateOperationsInput | number | null
    pesticide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextSprayDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSprayAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proteinPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    moisturePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    sugarPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    oilPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diseaseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LivestockCreateInput = {
    id?: string
    animalType: string
    specificType?: string | null
    breed?: string | null
    birthDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    lastMilkAlertAt?: Date | string | null
    weightKg?: number | null
    healthStatus?: string | null
    dailyFeedKg?: number | null
    vaccineStatus?: string | null
    lastCheckupDate?: Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutLivestockInput
    milkLogs?: MilkLogCreateNestedManyWithoutLivestockInput
    eggLogs?: EggLogCreateNestedManyWithoutLivestockInput
    honeyLogs?: HoneyLogCreateNestedManyWithoutLivestockInput
    woolLogs?: WoolLogCreateNestedManyWithoutLivestockInput
    weightLogs?: WeightLogCreateNestedManyWithoutLivestockInput
    metrics?: LivestockMetricCreateNestedManyWithoutLivestockInput
  }

  export type LivestockUncheckedCreateInput = {
    id?: string
    userId: string
    animalType: string
    specificType?: string | null
    breed?: string | null
    birthDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    lastMilkAlertAt?: Date | string | null
    weightKg?: number | null
    healthStatus?: string | null
    dailyFeedKg?: number | null
    vaccineStatus?: string | null
    lastCheckupDate?: Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    milkLogs?: MilkLogUncheckedCreateNestedManyWithoutLivestockInput
    eggLogs?: EggLogUncheckedCreateNestedManyWithoutLivestockInput
    honeyLogs?: HoneyLogUncheckedCreateNestedManyWithoutLivestockInput
    woolLogs?: WoolLogUncheckedCreateNestedManyWithoutLivestockInput
    weightLogs?: WeightLogUncheckedCreateNestedManyWithoutLivestockInput
    metrics?: LivestockMetricUncheckedCreateNestedManyWithoutLivestockInput
  }

  export type LivestockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    animalType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMilkAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dailyFeedKg?: NullableFloatFieldUpdateOperationsInput | number | null
    vaccineStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lastCheckupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutLivestockNestedInput
    milkLogs?: MilkLogUpdateManyWithoutLivestockNestedInput
    eggLogs?: EggLogUpdateManyWithoutLivestockNestedInput
    honeyLogs?: HoneyLogUpdateManyWithoutLivestockNestedInput
    woolLogs?: WoolLogUpdateManyWithoutLivestockNestedInput
    weightLogs?: WeightLogUpdateManyWithoutLivestockNestedInput
    metrics?: LivestockMetricUpdateManyWithoutLivestockNestedInput
  }

  export type LivestockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    animalType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMilkAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dailyFeedKg?: NullableFloatFieldUpdateOperationsInput | number | null
    vaccineStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lastCheckupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    milkLogs?: MilkLogUncheckedUpdateManyWithoutLivestockNestedInput
    eggLogs?: EggLogUncheckedUpdateManyWithoutLivestockNestedInput
    honeyLogs?: HoneyLogUncheckedUpdateManyWithoutLivestockNestedInput
    woolLogs?: WoolLogUncheckedUpdateManyWithoutLivestockNestedInput
    weightLogs?: WeightLogUncheckedUpdateManyWithoutLivestockNestedInput
    metrics?: LivestockMetricUncheckedUpdateManyWithoutLivestockNestedInput
  }

  export type LivestockCreateManyInput = {
    id?: string
    userId: string
    animalType: string
    specificType?: string | null
    breed?: string | null
    birthDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    lastMilkAlertAt?: Date | string | null
    weightKg?: number | null
    healthStatus?: string | null
    dailyFeedKg?: number | null
    vaccineStatus?: string | null
    lastCheckupDate?: Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LivestockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    animalType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMilkAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dailyFeedKg?: NullableFloatFieldUpdateOperationsInput | number | null
    vaccineStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lastCheckupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LivestockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    animalType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMilkAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dailyFeedKg?: NullableFloatFieldUpdateOperationsInput | number | null
    vaccineStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lastCheckupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CropSprayCreateInput = {
    id?: string
    sprayedAt?: Date | string
    pesticide?: string | null
    createdAt?: Date | string
    crop: CropCreateNestedOneWithoutSpraysInput
  }

  export type CropSprayUncheckedCreateInput = {
    id?: string
    cropId: string
    sprayedAt?: Date | string
    pesticide?: string | null
    createdAt?: Date | string
  }

  export type CropSprayUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sprayedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pesticide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crop?: CropUpdateOneRequiredWithoutSpraysNestedInput
  }

  export type CropSprayUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    sprayedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pesticide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropSprayCreateManyInput = {
    id?: string
    cropId: string
    sprayedAt?: Date | string
    pesticide?: string | null
    createdAt?: Date | string
  }

  export type CropSprayUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sprayedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pesticide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropSprayUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    sprayedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pesticide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropHarvestCreateInput = {
    id?: string
    harvestedAt?: Date | string
    amountTon: number
    yieldTonPerHa?: number | null
    createdAt?: Date | string
    crop: CropCreateNestedOneWithoutHarvestsInput
  }

  export type CropHarvestUncheckedCreateInput = {
    id?: string
    cropId: string
    harvestedAt?: Date | string
    amountTon: number
    yieldTonPerHa?: number | null
    createdAt?: Date | string
  }

  export type CropHarvestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    harvestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountTon?: FloatFieldUpdateOperationsInput | number
    yieldTonPerHa?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crop?: CropUpdateOneRequiredWithoutHarvestsNestedInput
  }

  export type CropHarvestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    harvestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountTon?: FloatFieldUpdateOperationsInput | number
    yieldTonPerHa?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropHarvestCreateManyInput = {
    id?: string
    cropId: string
    harvestedAt?: Date | string
    amountTon: number
    yieldTonPerHa?: number | null
    createdAt?: Date | string
  }

  export type CropHarvestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    harvestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountTon?: FloatFieldUpdateOperationsInput | number
    yieldTonPerHa?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropHarvestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    harvestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountTon?: FloatFieldUpdateOperationsInput | number
    yieldTonPerHa?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilkLogCreateInput = {
    id?: string
    measuredAt?: Date | string
    quantityL: number
    fatPercent?: number | null
    createdAt?: Date | string
    livestock: LivestockCreateNestedOneWithoutMilkLogsInput
  }

  export type MilkLogUncheckedCreateInput = {
    id?: string
    livestockId: string
    measuredAt?: Date | string
    quantityL: number
    fatPercent?: number | null
    createdAt?: Date | string
  }

  export type MilkLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantityL?: FloatFieldUpdateOperationsInput | number
    fatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    livestock?: LivestockUpdateOneRequiredWithoutMilkLogsNestedInput
  }

  export type MilkLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    livestockId?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantityL?: FloatFieldUpdateOperationsInput | number
    fatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilkLogCreateManyInput = {
    id?: string
    livestockId: string
    measuredAt?: Date | string
    quantityL: number
    fatPercent?: number | null
    createdAt?: Date | string
  }

  export type MilkLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantityL?: FloatFieldUpdateOperationsInput | number
    fatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilkLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    livestockId?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantityL?: FloatFieldUpdateOperationsInput | number
    fatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EggLogCreateInput = {
    id?: string
    measuredAt?: Date | string
    eggCount: number
    avgWeightGram?: number | null
    createdAt?: Date | string
    livestock: LivestockCreateNestedOneWithoutEggLogsInput
  }

  export type EggLogUncheckedCreateInput = {
    id?: string
    livestockId: string
    measuredAt?: Date | string
    eggCount: number
    avgWeightGram?: number | null
    createdAt?: Date | string
  }

  export type EggLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eggCount?: IntFieldUpdateOperationsInput | number
    avgWeightGram?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    livestock?: LivestockUpdateOneRequiredWithoutEggLogsNestedInput
  }

  export type EggLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    livestockId?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eggCount?: IntFieldUpdateOperationsInput | number
    avgWeightGram?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EggLogCreateManyInput = {
    id?: string
    livestockId: string
    measuredAt?: Date | string
    eggCount: number
    avgWeightGram?: number | null
    createdAt?: Date | string
  }

  export type EggLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eggCount?: IntFieldUpdateOperationsInput | number
    avgWeightGram?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EggLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    livestockId?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eggCount?: IntFieldUpdateOperationsInput | number
    avgWeightGram?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoneyLogCreateInput = {
    id?: string
    measuredAt?: Date | string
    amountKg: number
    qualityGrade?: string | null
    createdAt?: Date | string
    livestock: LivestockCreateNestedOneWithoutHoneyLogsInput
  }

  export type HoneyLogUncheckedCreateInput = {
    id?: string
    livestockId: string
    measuredAt?: Date | string
    amountKg: number
    qualityGrade?: string | null
    createdAt?: Date | string
  }

  export type HoneyLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountKg?: FloatFieldUpdateOperationsInput | number
    qualityGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    livestock?: LivestockUpdateOneRequiredWithoutHoneyLogsNestedInput
  }

  export type HoneyLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    livestockId?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountKg?: FloatFieldUpdateOperationsInput | number
    qualityGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoneyLogCreateManyInput = {
    id?: string
    livestockId: string
    measuredAt?: Date | string
    amountKg: number
    qualityGrade?: string | null
    createdAt?: Date | string
  }

  export type HoneyLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountKg?: FloatFieldUpdateOperationsInput | number
    qualityGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoneyLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    livestockId?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountKg?: FloatFieldUpdateOperationsInput | number
    qualityGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WoolLogCreateInput = {
    id?: string
    shearedAt?: Date | string
    amountKg: number
    qualityGrade?: string | null
    createdAt?: Date | string
    livestock: LivestockCreateNestedOneWithoutWoolLogsInput
  }

  export type WoolLogUncheckedCreateInput = {
    id?: string
    livestockId: string
    shearedAt?: Date | string
    amountKg: number
    qualityGrade?: string | null
    createdAt?: Date | string
  }

  export type WoolLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shearedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountKg?: FloatFieldUpdateOperationsInput | number
    qualityGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    livestock?: LivestockUpdateOneRequiredWithoutWoolLogsNestedInput
  }

  export type WoolLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    livestockId?: StringFieldUpdateOperationsInput | string
    shearedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountKg?: FloatFieldUpdateOperationsInput | number
    qualityGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WoolLogCreateManyInput = {
    id?: string
    livestockId: string
    shearedAt?: Date | string
    amountKg: number
    qualityGrade?: string | null
    createdAt?: Date | string
  }

  export type WoolLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shearedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountKg?: FloatFieldUpdateOperationsInput | number
    qualityGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WoolLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    livestockId?: StringFieldUpdateOperationsInput | string
    shearedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountKg?: FloatFieldUpdateOperationsInput | number
    qualityGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeightLogCreateInput = {
    id?: string
    measuredAt?: Date | string
    weightKg: number
    notes?: string | null
    createdAt?: Date | string
    livestock: LivestockCreateNestedOneWithoutWeightLogsInput
  }

  export type WeightLogUncheckedCreateInput = {
    id?: string
    livestockId: string
    measuredAt?: Date | string
    weightKg: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type WeightLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weightKg?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    livestock?: LivestockUpdateOneRequiredWithoutWeightLogsNestedInput
  }

  export type WeightLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    livestockId?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weightKg?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeightLogCreateManyInput = {
    id?: string
    livestockId: string
    measuredAt?: Date | string
    weightKg: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type WeightLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weightKg?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeightLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    livestockId?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weightKg?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LivestockMetricCreateInput = {
    id?: string
    key: string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    livestock: LivestockCreateNestedOneWithoutMetricsInput
  }

  export type LivestockMetricUncheckedCreateInput = {
    id?: string
    livestockId: string
    key: string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LivestockMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    livestock?: LivestockUpdateOneRequiredWithoutMetricsNestedInput
  }

  export type LivestockMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    livestockId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LivestockMetricCreateManyInput = {
    id?: string
    livestockId: string
    key: string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LivestockMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LivestockMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    livestockId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropQualityLogCreateInput = {
    id?: string
    measuredAt?: Date | string
    proteinPercent?: number | null
    moisturePercent?: number | null
    sugarPercent?: number | null
    oilPercent?: number | null
    notes?: string | null
    createdAt?: Date | string
    crop: CropCreateNestedOneWithoutQualityLogsInput
  }

  export type CropQualityLogUncheckedCreateInput = {
    id?: string
    cropId: string
    measuredAt?: Date | string
    proteinPercent?: number | null
    moisturePercent?: number | null
    sugarPercent?: number | null
    oilPercent?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type CropQualityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proteinPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    moisturePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    sugarPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    oilPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crop?: CropUpdateOneRequiredWithoutQualityLogsNestedInput
  }

  export type CropQualityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proteinPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    moisturePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    sugarPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    oilPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropQualityLogCreateManyInput = {
    id?: string
    cropId: string
    measuredAt?: Date | string
    proteinPercent?: number | null
    moisturePercent?: number | null
    sugarPercent?: number | null
    oilPercent?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type CropQualityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proteinPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    moisturePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    sugarPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    oilPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropQualityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proteinPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    moisturePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    sugarPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    oilPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropMetricCreateInput = {
    id?: string
    key: string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    crop: CropCreateNestedOneWithoutMetricsInput
  }

  export type CropMetricUncheckedCreateInput = {
    id?: string
    cropId: string
    key: string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CropMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crop?: CropUpdateOneRequiredWithoutMetricsNestedInput
  }

  export type CropMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropMetricCreateManyInput = {
    id?: string
    cropId: string
    key: string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CropMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportProgramCreateInput = {
    id?: string
    title: string
    titleEn?: string | null
    description?: string | null
    descriptionEn?: string | null
    category: string
    subcategory?: string | null
    amount?: string | null
    amountEn?: string | null
    eligibility?: string | null
    eligibilityEn?: string | null
    requiredDocs?: string | null
    requiredDocsEn?: string | null
    applicationStart?: Date | string | null
    applicationDeadline?: Date | string | null
    link?: string | null
    status?: string
    targetCrops?: string | null
    targetLivestock?: string | null
    region?: string | null
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportProgramUncheckedCreateInput = {
    id?: string
    title: string
    titleEn?: string | null
    description?: string | null
    descriptionEn?: string | null
    category: string
    subcategory?: string | null
    amount?: string | null
    amountEn?: string | null
    eligibility?: string | null
    eligibilityEn?: string | null
    requiredDocs?: string | null
    requiredDocsEn?: string | null
    applicationStart?: Date | string | null
    applicationDeadline?: Date | string | null
    link?: string | null
    status?: string
    targetCrops?: string | null
    targetLivestock?: string | null
    region?: string | null
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportProgramUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    amountEn?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    eligibilityEn?: NullableStringFieldUpdateOperationsInput | string | null
    requiredDocs?: NullableStringFieldUpdateOperationsInput | string | null
    requiredDocsEn?: NullableStringFieldUpdateOperationsInput | string | null
    applicationStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    targetCrops?: NullableStringFieldUpdateOperationsInput | string | null
    targetLivestock?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportProgramUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    amountEn?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    eligibilityEn?: NullableStringFieldUpdateOperationsInput | string | null
    requiredDocs?: NullableStringFieldUpdateOperationsInput | string | null
    requiredDocsEn?: NullableStringFieldUpdateOperationsInput | string | null
    applicationStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    targetCrops?: NullableStringFieldUpdateOperationsInput | string | null
    targetLivestock?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportProgramCreateManyInput = {
    id?: string
    title: string
    titleEn?: string | null
    description?: string | null
    descriptionEn?: string | null
    category: string
    subcategory?: string | null
    amount?: string | null
    amountEn?: string | null
    eligibility?: string | null
    eligibilityEn?: string | null
    requiredDocs?: string | null
    requiredDocsEn?: string | null
    applicationStart?: Date | string | null
    applicationDeadline?: Date | string | null
    link?: string | null
    status?: string
    targetCrops?: string | null
    targetLivestock?: string | null
    region?: string | null
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportProgramUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    amountEn?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    eligibilityEn?: NullableStringFieldUpdateOperationsInput | string | null
    requiredDocs?: NullableStringFieldUpdateOperationsInput | string | null
    requiredDocsEn?: NullableStringFieldUpdateOperationsInput | string | null
    applicationStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    targetCrops?: NullableStringFieldUpdateOperationsInput | string | null
    targetLivestock?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportProgramUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    amountEn?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    eligibilityEn?: NullableStringFieldUpdateOperationsInput | string | null
    requiredDocs?: NullableStringFieldUpdateOperationsInput | string | null
    requiredDocsEn?: NullableStringFieldUpdateOperationsInput | string | null
    applicationStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    targetCrops?: NullableStringFieldUpdateOperationsInput | string | null
    targetLivestock?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherAlertCreateInput = {
    id?: string
    alertType: string
    description?: string | null
    startsAt?: Date | string | null
    expiresAt?: Date | string | null
    region?: string | null
    createdAt?: Date | string
  }

  export type WeatherAlertUncheckedCreateInput = {
    id?: string
    alertType: string
    description?: string | null
    startsAt?: Date | string | null
    expiresAt?: Date | string | null
    region?: string | null
    createdAt?: Date | string
  }

  export type WeatherAlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherAlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherAlertCreateManyInput = {
    id?: string
    alertType: string
    description?: string | null
    startsAt?: Date | string | null
    expiresAt?: Date | string | null
    region?: string | null
    createdAt?: Date | string
  }

  export type WeatherAlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherAlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketListingCreateInput = {
    id?: string
    itemType: $Enums.ItemType
    itemRef: string
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isActive?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutListingsInput
  }

  export type MarketListingUncheckedCreateInput = {
    id?: string
    userId: string
    itemType: $Enums.ItemType
    itemRef: string
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type MarketListingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRef?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutListingsNestedInput
  }

  export type MarketListingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRef?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketListingCreateManyInput = {
    id?: string
    userId: string
    itemType: $Enums.ItemType
    itemRef: string
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type MarketListingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRef?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketListingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRef?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    body: string
    category?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    body: string
    category?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    title: string
    body: string
    category?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CropListRelationFilter = {
    every?: CropWhereInput
    some?: CropWhereInput
    none?: CropWhereInput
  }

  export type LivestockListRelationFilter = {
    every?: LivestockWhereInput
    some?: LivestockWhereInput
    none?: LivestockWhereInput
  }

  export type MarketListingListRelationFilter = {
    every?: MarketListingWhereInput
    some?: MarketListingWhereInput
    none?: MarketListingWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CropOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LivestockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarketListingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CropSprayListRelationFilter = {
    every?: CropSprayWhereInput
    some?: CropSprayWhereInput
    none?: CropSprayWhereInput
  }

  export type CropHarvestListRelationFilter = {
    every?: CropHarvestWhereInput
    some?: CropHarvestWhereInput
    none?: CropHarvestWhereInput
  }

  export type CropQualityLogListRelationFilter = {
    every?: CropQualityLogWhereInput
    some?: CropQualityLogWhereInput
    none?: CropQualityLogWhereInput
  }

  export type CropMetricListRelationFilter = {
    every?: CropMetricWhereInput
    some?: CropMetricWhereInput
    none?: CropMetricWhereInput
  }

  export type CropSprayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CropHarvestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CropQualityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CropMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CropCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cropType?: SortOrder
    specificType?: SortOrder
    plantingDate?: SortOrder
    harvestDate?: SortOrder
    notes?: SortOrder
    areaHectares?: SortOrder
    pesticide?: SortOrder
    createdAt?: SortOrder
    nextSprayDueAt?: SortOrder
    lastSprayAlertAt?: SortOrder
    proteinPercent?: SortOrder
    moisturePercent?: SortOrder
    sugarPercent?: SortOrder
    oilPercent?: SortOrder
    healthStatus?: SortOrder
    diseaseNotes?: SortOrder
    qualityScore?: SortOrder
    customMetrics?: SortOrder
  }

  export type CropAvgOrderByAggregateInput = {
    areaHectares?: SortOrder
    proteinPercent?: SortOrder
    moisturePercent?: SortOrder
    sugarPercent?: SortOrder
    oilPercent?: SortOrder
    qualityScore?: SortOrder
  }

  export type CropMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cropType?: SortOrder
    specificType?: SortOrder
    plantingDate?: SortOrder
    harvestDate?: SortOrder
    notes?: SortOrder
    areaHectares?: SortOrder
    pesticide?: SortOrder
    createdAt?: SortOrder
    nextSprayDueAt?: SortOrder
    lastSprayAlertAt?: SortOrder
    proteinPercent?: SortOrder
    moisturePercent?: SortOrder
    sugarPercent?: SortOrder
    oilPercent?: SortOrder
    healthStatus?: SortOrder
    diseaseNotes?: SortOrder
    qualityScore?: SortOrder
  }

  export type CropMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cropType?: SortOrder
    specificType?: SortOrder
    plantingDate?: SortOrder
    harvestDate?: SortOrder
    notes?: SortOrder
    areaHectares?: SortOrder
    pesticide?: SortOrder
    createdAt?: SortOrder
    nextSprayDueAt?: SortOrder
    lastSprayAlertAt?: SortOrder
    proteinPercent?: SortOrder
    moisturePercent?: SortOrder
    sugarPercent?: SortOrder
    oilPercent?: SortOrder
    healthStatus?: SortOrder
    diseaseNotes?: SortOrder
    qualityScore?: SortOrder
  }

  export type CropSumOrderByAggregateInput = {
    areaHectares?: SortOrder
    proteinPercent?: SortOrder
    moisturePercent?: SortOrder
    sugarPercent?: SortOrder
    oilPercent?: SortOrder
    qualityScore?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type MilkLogListRelationFilter = {
    every?: MilkLogWhereInput
    some?: MilkLogWhereInput
    none?: MilkLogWhereInput
  }

  export type EggLogListRelationFilter = {
    every?: EggLogWhereInput
    some?: EggLogWhereInput
    none?: EggLogWhereInput
  }

  export type HoneyLogListRelationFilter = {
    every?: HoneyLogWhereInput
    some?: HoneyLogWhereInput
    none?: HoneyLogWhereInput
  }

  export type WoolLogListRelationFilter = {
    every?: WoolLogWhereInput
    some?: WoolLogWhereInput
    none?: WoolLogWhereInput
  }

  export type WeightLogListRelationFilter = {
    every?: WeightLogWhereInput
    some?: WeightLogWhereInput
    none?: WeightLogWhereInput
  }

  export type LivestockMetricListRelationFilter = {
    every?: LivestockMetricWhereInput
    some?: LivestockMetricWhereInput
    none?: LivestockMetricWhereInput
  }

  export type MilkLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EggLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HoneyLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WoolLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeightLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LivestockMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LivestockCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    animalType?: SortOrder
    specificType?: SortOrder
    breed?: SortOrder
    birthDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    lastMilkAlertAt?: SortOrder
    weightKg?: SortOrder
    healthStatus?: SortOrder
    dailyFeedKg?: SortOrder
    vaccineStatus?: SortOrder
    lastCheckupDate?: SortOrder
    customMetrics?: SortOrder
  }

  export type LivestockAvgOrderByAggregateInput = {
    weightKg?: SortOrder
    dailyFeedKg?: SortOrder
  }

  export type LivestockMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    animalType?: SortOrder
    specificType?: SortOrder
    breed?: SortOrder
    birthDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    lastMilkAlertAt?: SortOrder
    weightKg?: SortOrder
    healthStatus?: SortOrder
    dailyFeedKg?: SortOrder
    vaccineStatus?: SortOrder
    lastCheckupDate?: SortOrder
  }

  export type LivestockMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    animalType?: SortOrder
    specificType?: SortOrder
    breed?: SortOrder
    birthDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    lastMilkAlertAt?: SortOrder
    weightKg?: SortOrder
    healthStatus?: SortOrder
    dailyFeedKg?: SortOrder
    vaccineStatus?: SortOrder
    lastCheckupDate?: SortOrder
  }

  export type LivestockSumOrderByAggregateInput = {
    weightKg?: SortOrder
    dailyFeedKg?: SortOrder
  }

  export type CropScalarRelationFilter = {
    is?: CropWhereInput
    isNot?: CropWhereInput
  }

  export type CropSprayCountOrderByAggregateInput = {
    id?: SortOrder
    cropId?: SortOrder
    sprayedAt?: SortOrder
    pesticide?: SortOrder
    createdAt?: SortOrder
  }

  export type CropSprayMaxOrderByAggregateInput = {
    id?: SortOrder
    cropId?: SortOrder
    sprayedAt?: SortOrder
    pesticide?: SortOrder
    createdAt?: SortOrder
  }

  export type CropSprayMinOrderByAggregateInput = {
    id?: SortOrder
    cropId?: SortOrder
    sprayedAt?: SortOrder
    pesticide?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type CropHarvestCountOrderByAggregateInput = {
    id?: SortOrder
    cropId?: SortOrder
    harvestedAt?: SortOrder
    amountTon?: SortOrder
    yieldTonPerHa?: SortOrder
    createdAt?: SortOrder
  }

  export type CropHarvestAvgOrderByAggregateInput = {
    amountTon?: SortOrder
    yieldTonPerHa?: SortOrder
  }

  export type CropHarvestMaxOrderByAggregateInput = {
    id?: SortOrder
    cropId?: SortOrder
    harvestedAt?: SortOrder
    amountTon?: SortOrder
    yieldTonPerHa?: SortOrder
    createdAt?: SortOrder
  }

  export type CropHarvestMinOrderByAggregateInput = {
    id?: SortOrder
    cropId?: SortOrder
    harvestedAt?: SortOrder
    amountTon?: SortOrder
    yieldTonPerHa?: SortOrder
    createdAt?: SortOrder
  }

  export type CropHarvestSumOrderByAggregateInput = {
    amountTon?: SortOrder
    yieldTonPerHa?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type LivestockScalarRelationFilter = {
    is?: LivestockWhereInput
    isNot?: LivestockWhereInput
  }

  export type MilkLogCountOrderByAggregateInput = {
    id?: SortOrder
    livestockId?: SortOrder
    measuredAt?: SortOrder
    quantityL?: SortOrder
    fatPercent?: SortOrder
    createdAt?: SortOrder
  }

  export type MilkLogAvgOrderByAggregateInput = {
    quantityL?: SortOrder
    fatPercent?: SortOrder
  }

  export type MilkLogMaxOrderByAggregateInput = {
    id?: SortOrder
    livestockId?: SortOrder
    measuredAt?: SortOrder
    quantityL?: SortOrder
    fatPercent?: SortOrder
    createdAt?: SortOrder
  }

  export type MilkLogMinOrderByAggregateInput = {
    id?: SortOrder
    livestockId?: SortOrder
    measuredAt?: SortOrder
    quantityL?: SortOrder
    fatPercent?: SortOrder
    createdAt?: SortOrder
  }

  export type MilkLogSumOrderByAggregateInput = {
    quantityL?: SortOrder
    fatPercent?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EggLogCountOrderByAggregateInput = {
    id?: SortOrder
    livestockId?: SortOrder
    measuredAt?: SortOrder
    eggCount?: SortOrder
    avgWeightGram?: SortOrder
    createdAt?: SortOrder
  }

  export type EggLogAvgOrderByAggregateInput = {
    eggCount?: SortOrder
    avgWeightGram?: SortOrder
  }

  export type EggLogMaxOrderByAggregateInput = {
    id?: SortOrder
    livestockId?: SortOrder
    measuredAt?: SortOrder
    eggCount?: SortOrder
    avgWeightGram?: SortOrder
    createdAt?: SortOrder
  }

  export type EggLogMinOrderByAggregateInput = {
    id?: SortOrder
    livestockId?: SortOrder
    measuredAt?: SortOrder
    eggCount?: SortOrder
    avgWeightGram?: SortOrder
    createdAt?: SortOrder
  }

  export type EggLogSumOrderByAggregateInput = {
    eggCount?: SortOrder
    avgWeightGram?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type HoneyLogCountOrderByAggregateInput = {
    id?: SortOrder
    livestockId?: SortOrder
    measuredAt?: SortOrder
    amountKg?: SortOrder
    qualityGrade?: SortOrder
    createdAt?: SortOrder
  }

  export type HoneyLogAvgOrderByAggregateInput = {
    amountKg?: SortOrder
  }

  export type HoneyLogMaxOrderByAggregateInput = {
    id?: SortOrder
    livestockId?: SortOrder
    measuredAt?: SortOrder
    amountKg?: SortOrder
    qualityGrade?: SortOrder
    createdAt?: SortOrder
  }

  export type HoneyLogMinOrderByAggregateInput = {
    id?: SortOrder
    livestockId?: SortOrder
    measuredAt?: SortOrder
    amountKg?: SortOrder
    qualityGrade?: SortOrder
    createdAt?: SortOrder
  }

  export type HoneyLogSumOrderByAggregateInput = {
    amountKg?: SortOrder
  }

  export type WoolLogCountOrderByAggregateInput = {
    id?: SortOrder
    livestockId?: SortOrder
    shearedAt?: SortOrder
    amountKg?: SortOrder
    qualityGrade?: SortOrder
    createdAt?: SortOrder
  }

  export type WoolLogAvgOrderByAggregateInput = {
    amountKg?: SortOrder
  }

  export type WoolLogMaxOrderByAggregateInput = {
    id?: SortOrder
    livestockId?: SortOrder
    shearedAt?: SortOrder
    amountKg?: SortOrder
    qualityGrade?: SortOrder
    createdAt?: SortOrder
  }

  export type WoolLogMinOrderByAggregateInput = {
    id?: SortOrder
    livestockId?: SortOrder
    shearedAt?: SortOrder
    amountKg?: SortOrder
    qualityGrade?: SortOrder
    createdAt?: SortOrder
  }

  export type WoolLogSumOrderByAggregateInput = {
    amountKg?: SortOrder
  }

  export type WeightLogCountOrderByAggregateInput = {
    id?: SortOrder
    livestockId?: SortOrder
    measuredAt?: SortOrder
    weightKg?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type WeightLogAvgOrderByAggregateInput = {
    weightKg?: SortOrder
  }

  export type WeightLogMaxOrderByAggregateInput = {
    id?: SortOrder
    livestockId?: SortOrder
    measuredAt?: SortOrder
    weightKg?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type WeightLogMinOrderByAggregateInput = {
    id?: SortOrder
    livestockId?: SortOrder
    measuredAt?: SortOrder
    weightKg?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type WeightLogSumOrderByAggregateInput = {
    weightKg?: SortOrder
  }

  export type LivestockMetricCountOrderByAggregateInput = {
    id?: SortOrder
    livestockId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LivestockMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    livestockId?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LivestockMetricMinOrderByAggregateInput = {
    id?: SortOrder
    livestockId?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CropQualityLogCountOrderByAggregateInput = {
    id?: SortOrder
    cropId?: SortOrder
    measuredAt?: SortOrder
    proteinPercent?: SortOrder
    moisturePercent?: SortOrder
    sugarPercent?: SortOrder
    oilPercent?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type CropQualityLogAvgOrderByAggregateInput = {
    proteinPercent?: SortOrder
    moisturePercent?: SortOrder
    sugarPercent?: SortOrder
    oilPercent?: SortOrder
  }

  export type CropQualityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    cropId?: SortOrder
    measuredAt?: SortOrder
    proteinPercent?: SortOrder
    moisturePercent?: SortOrder
    sugarPercent?: SortOrder
    oilPercent?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type CropQualityLogMinOrderByAggregateInput = {
    id?: SortOrder
    cropId?: SortOrder
    measuredAt?: SortOrder
    proteinPercent?: SortOrder
    moisturePercent?: SortOrder
    sugarPercent?: SortOrder
    oilPercent?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type CropQualityLogSumOrderByAggregateInput = {
    proteinPercent?: SortOrder
    moisturePercent?: SortOrder
    sugarPercent?: SortOrder
    oilPercent?: SortOrder
  }

  export type CropMetricCountOrderByAggregateInput = {
    id?: SortOrder
    cropId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CropMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    cropId?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CropMetricMinOrderByAggregateInput = {
    id?: SortOrder
    cropId?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupportProgramCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrder
    description?: SortOrder
    descriptionEn?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    amount?: SortOrder
    amountEn?: SortOrder
    eligibility?: SortOrder
    eligibilityEn?: SortOrder
    requiredDocs?: SortOrder
    requiredDocsEn?: SortOrder
    applicationStart?: SortOrder
    applicationDeadline?: SortOrder
    link?: SortOrder
    status?: SortOrder
    targetCrops?: SortOrder
    targetLivestock?: SortOrder
    region?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupportProgramAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type SupportProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrder
    description?: SortOrder
    descriptionEn?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    amount?: SortOrder
    amountEn?: SortOrder
    eligibility?: SortOrder
    eligibilityEn?: SortOrder
    requiredDocs?: SortOrder
    requiredDocsEn?: SortOrder
    applicationStart?: SortOrder
    applicationDeadline?: SortOrder
    link?: SortOrder
    status?: SortOrder
    targetCrops?: SortOrder
    targetLivestock?: SortOrder
    region?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupportProgramMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrder
    description?: SortOrder
    descriptionEn?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    amount?: SortOrder
    amountEn?: SortOrder
    eligibility?: SortOrder
    eligibilityEn?: SortOrder
    requiredDocs?: SortOrder
    requiredDocsEn?: SortOrder
    applicationStart?: SortOrder
    applicationDeadline?: SortOrder
    link?: SortOrder
    status?: SortOrder
    targetCrops?: SortOrder
    targetLivestock?: SortOrder
    region?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupportProgramSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type WeatherAlertCountOrderByAggregateInput = {
    id?: SortOrder
    alertType?: SortOrder
    description?: SortOrder
    startsAt?: SortOrder
    expiresAt?: SortOrder
    region?: SortOrder
    createdAt?: SortOrder
  }

  export type WeatherAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    alertType?: SortOrder
    description?: SortOrder
    startsAt?: SortOrder
    expiresAt?: SortOrder
    region?: SortOrder
    createdAt?: SortOrder
  }

  export type WeatherAlertMinOrderByAggregateInput = {
    id?: SortOrder
    alertType?: SortOrder
    description?: SortOrder
    startsAt?: SortOrder
    expiresAt?: SortOrder
    region?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeFilter<$PrismaModel> | $Enums.ItemType
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type MarketListingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemType?: SortOrder
    itemRef?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type MarketListingAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type MarketListingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemType?: SortOrder
    itemRef?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type MarketListingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemType?: SortOrder
    itemRef?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type MarketListingSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.ItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemTypeFilter<$PrismaModel>
    _max?: NestedEnumItemTypeFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    category?: SortOrder
    metadata?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    category?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    category?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type CropCreateNestedManyWithoutUserInput = {
    create?: XOR<CropCreateWithoutUserInput, CropUncheckedCreateWithoutUserInput> | CropCreateWithoutUserInput[] | CropUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CropCreateOrConnectWithoutUserInput | CropCreateOrConnectWithoutUserInput[]
    createMany?: CropCreateManyUserInputEnvelope
    connect?: CropWhereUniqueInput | CropWhereUniqueInput[]
  }

  export type LivestockCreateNestedManyWithoutUserInput = {
    create?: XOR<LivestockCreateWithoutUserInput, LivestockUncheckedCreateWithoutUserInput> | LivestockCreateWithoutUserInput[] | LivestockUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LivestockCreateOrConnectWithoutUserInput | LivestockCreateOrConnectWithoutUserInput[]
    createMany?: LivestockCreateManyUserInputEnvelope
    connect?: LivestockWhereUniqueInput | LivestockWhereUniqueInput[]
  }

  export type MarketListingCreateNestedManyWithoutUserInput = {
    create?: XOR<MarketListingCreateWithoutUserInput, MarketListingUncheckedCreateWithoutUserInput> | MarketListingCreateWithoutUserInput[] | MarketListingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MarketListingCreateOrConnectWithoutUserInput | MarketListingCreateOrConnectWithoutUserInput[]
    createMany?: MarketListingCreateManyUserInputEnvelope
    connect?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CropUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CropCreateWithoutUserInput, CropUncheckedCreateWithoutUserInput> | CropCreateWithoutUserInput[] | CropUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CropCreateOrConnectWithoutUserInput | CropCreateOrConnectWithoutUserInput[]
    createMany?: CropCreateManyUserInputEnvelope
    connect?: CropWhereUniqueInput | CropWhereUniqueInput[]
  }

  export type LivestockUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LivestockCreateWithoutUserInput, LivestockUncheckedCreateWithoutUserInput> | LivestockCreateWithoutUserInput[] | LivestockUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LivestockCreateOrConnectWithoutUserInput | LivestockCreateOrConnectWithoutUserInput[]
    createMany?: LivestockCreateManyUserInputEnvelope
    connect?: LivestockWhereUniqueInput | LivestockWhereUniqueInput[]
  }

  export type MarketListingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MarketListingCreateWithoutUserInput, MarketListingUncheckedCreateWithoutUserInput> | MarketListingCreateWithoutUserInput[] | MarketListingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MarketListingCreateOrConnectWithoutUserInput | MarketListingCreateOrConnectWithoutUserInput[]
    createMany?: MarketListingCreateManyUserInputEnvelope
    connect?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CropUpdateManyWithoutUserNestedInput = {
    create?: XOR<CropCreateWithoutUserInput, CropUncheckedCreateWithoutUserInput> | CropCreateWithoutUserInput[] | CropUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CropCreateOrConnectWithoutUserInput | CropCreateOrConnectWithoutUserInput[]
    upsert?: CropUpsertWithWhereUniqueWithoutUserInput | CropUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CropCreateManyUserInputEnvelope
    set?: CropWhereUniqueInput | CropWhereUniqueInput[]
    disconnect?: CropWhereUniqueInput | CropWhereUniqueInput[]
    delete?: CropWhereUniqueInput | CropWhereUniqueInput[]
    connect?: CropWhereUniqueInput | CropWhereUniqueInput[]
    update?: CropUpdateWithWhereUniqueWithoutUserInput | CropUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CropUpdateManyWithWhereWithoutUserInput | CropUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CropScalarWhereInput | CropScalarWhereInput[]
  }

  export type LivestockUpdateManyWithoutUserNestedInput = {
    create?: XOR<LivestockCreateWithoutUserInput, LivestockUncheckedCreateWithoutUserInput> | LivestockCreateWithoutUserInput[] | LivestockUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LivestockCreateOrConnectWithoutUserInput | LivestockCreateOrConnectWithoutUserInput[]
    upsert?: LivestockUpsertWithWhereUniqueWithoutUserInput | LivestockUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LivestockCreateManyUserInputEnvelope
    set?: LivestockWhereUniqueInput | LivestockWhereUniqueInput[]
    disconnect?: LivestockWhereUniqueInput | LivestockWhereUniqueInput[]
    delete?: LivestockWhereUniqueInput | LivestockWhereUniqueInput[]
    connect?: LivestockWhereUniqueInput | LivestockWhereUniqueInput[]
    update?: LivestockUpdateWithWhereUniqueWithoutUserInput | LivestockUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LivestockUpdateManyWithWhereWithoutUserInput | LivestockUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LivestockScalarWhereInput | LivestockScalarWhereInput[]
  }

  export type MarketListingUpdateManyWithoutUserNestedInput = {
    create?: XOR<MarketListingCreateWithoutUserInput, MarketListingUncheckedCreateWithoutUserInput> | MarketListingCreateWithoutUserInput[] | MarketListingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MarketListingCreateOrConnectWithoutUserInput | MarketListingCreateOrConnectWithoutUserInput[]
    upsert?: MarketListingUpsertWithWhereUniqueWithoutUserInput | MarketListingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MarketListingCreateManyUserInputEnvelope
    set?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
    disconnect?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
    delete?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
    connect?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
    update?: MarketListingUpdateWithWhereUniqueWithoutUserInput | MarketListingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MarketListingUpdateManyWithWhereWithoutUserInput | MarketListingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MarketListingScalarWhereInput | MarketListingScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CropUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CropCreateWithoutUserInput, CropUncheckedCreateWithoutUserInput> | CropCreateWithoutUserInput[] | CropUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CropCreateOrConnectWithoutUserInput | CropCreateOrConnectWithoutUserInput[]
    upsert?: CropUpsertWithWhereUniqueWithoutUserInput | CropUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CropCreateManyUserInputEnvelope
    set?: CropWhereUniqueInput | CropWhereUniqueInput[]
    disconnect?: CropWhereUniqueInput | CropWhereUniqueInput[]
    delete?: CropWhereUniqueInput | CropWhereUniqueInput[]
    connect?: CropWhereUniqueInput | CropWhereUniqueInput[]
    update?: CropUpdateWithWhereUniqueWithoutUserInput | CropUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CropUpdateManyWithWhereWithoutUserInput | CropUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CropScalarWhereInput | CropScalarWhereInput[]
  }

  export type LivestockUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LivestockCreateWithoutUserInput, LivestockUncheckedCreateWithoutUserInput> | LivestockCreateWithoutUserInput[] | LivestockUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LivestockCreateOrConnectWithoutUserInput | LivestockCreateOrConnectWithoutUserInput[]
    upsert?: LivestockUpsertWithWhereUniqueWithoutUserInput | LivestockUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LivestockCreateManyUserInputEnvelope
    set?: LivestockWhereUniqueInput | LivestockWhereUniqueInput[]
    disconnect?: LivestockWhereUniqueInput | LivestockWhereUniqueInput[]
    delete?: LivestockWhereUniqueInput | LivestockWhereUniqueInput[]
    connect?: LivestockWhereUniqueInput | LivestockWhereUniqueInput[]
    update?: LivestockUpdateWithWhereUniqueWithoutUserInput | LivestockUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LivestockUpdateManyWithWhereWithoutUserInput | LivestockUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LivestockScalarWhereInput | LivestockScalarWhereInput[]
  }

  export type MarketListingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MarketListingCreateWithoutUserInput, MarketListingUncheckedCreateWithoutUserInput> | MarketListingCreateWithoutUserInput[] | MarketListingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MarketListingCreateOrConnectWithoutUserInput | MarketListingCreateOrConnectWithoutUserInput[]
    upsert?: MarketListingUpsertWithWhereUniqueWithoutUserInput | MarketListingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MarketListingCreateManyUserInputEnvelope
    set?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
    disconnect?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
    delete?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
    connect?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
    update?: MarketListingUpdateWithWhereUniqueWithoutUserInput | MarketListingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MarketListingUpdateManyWithWhereWithoutUserInput | MarketListingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MarketListingScalarWhereInput | MarketListingScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCropsInput = {
    create?: XOR<UserCreateWithoutCropsInput, UserUncheckedCreateWithoutCropsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCropsInput
    connect?: UserWhereUniqueInput
  }

  export type CropSprayCreateNestedManyWithoutCropInput = {
    create?: XOR<CropSprayCreateWithoutCropInput, CropSprayUncheckedCreateWithoutCropInput> | CropSprayCreateWithoutCropInput[] | CropSprayUncheckedCreateWithoutCropInput[]
    connectOrCreate?: CropSprayCreateOrConnectWithoutCropInput | CropSprayCreateOrConnectWithoutCropInput[]
    createMany?: CropSprayCreateManyCropInputEnvelope
    connect?: CropSprayWhereUniqueInput | CropSprayWhereUniqueInput[]
  }

  export type CropHarvestCreateNestedManyWithoutCropInput = {
    create?: XOR<CropHarvestCreateWithoutCropInput, CropHarvestUncheckedCreateWithoutCropInput> | CropHarvestCreateWithoutCropInput[] | CropHarvestUncheckedCreateWithoutCropInput[]
    connectOrCreate?: CropHarvestCreateOrConnectWithoutCropInput | CropHarvestCreateOrConnectWithoutCropInput[]
    createMany?: CropHarvestCreateManyCropInputEnvelope
    connect?: CropHarvestWhereUniqueInput | CropHarvestWhereUniqueInput[]
  }

  export type CropQualityLogCreateNestedManyWithoutCropInput = {
    create?: XOR<CropQualityLogCreateWithoutCropInput, CropQualityLogUncheckedCreateWithoutCropInput> | CropQualityLogCreateWithoutCropInput[] | CropQualityLogUncheckedCreateWithoutCropInput[]
    connectOrCreate?: CropQualityLogCreateOrConnectWithoutCropInput | CropQualityLogCreateOrConnectWithoutCropInput[]
    createMany?: CropQualityLogCreateManyCropInputEnvelope
    connect?: CropQualityLogWhereUniqueInput | CropQualityLogWhereUniqueInput[]
  }

  export type CropMetricCreateNestedManyWithoutCropInput = {
    create?: XOR<CropMetricCreateWithoutCropInput, CropMetricUncheckedCreateWithoutCropInput> | CropMetricCreateWithoutCropInput[] | CropMetricUncheckedCreateWithoutCropInput[]
    connectOrCreate?: CropMetricCreateOrConnectWithoutCropInput | CropMetricCreateOrConnectWithoutCropInput[]
    createMany?: CropMetricCreateManyCropInputEnvelope
    connect?: CropMetricWhereUniqueInput | CropMetricWhereUniqueInput[]
  }

  export type CropSprayUncheckedCreateNestedManyWithoutCropInput = {
    create?: XOR<CropSprayCreateWithoutCropInput, CropSprayUncheckedCreateWithoutCropInput> | CropSprayCreateWithoutCropInput[] | CropSprayUncheckedCreateWithoutCropInput[]
    connectOrCreate?: CropSprayCreateOrConnectWithoutCropInput | CropSprayCreateOrConnectWithoutCropInput[]
    createMany?: CropSprayCreateManyCropInputEnvelope
    connect?: CropSprayWhereUniqueInput | CropSprayWhereUniqueInput[]
  }

  export type CropHarvestUncheckedCreateNestedManyWithoutCropInput = {
    create?: XOR<CropHarvestCreateWithoutCropInput, CropHarvestUncheckedCreateWithoutCropInput> | CropHarvestCreateWithoutCropInput[] | CropHarvestUncheckedCreateWithoutCropInput[]
    connectOrCreate?: CropHarvestCreateOrConnectWithoutCropInput | CropHarvestCreateOrConnectWithoutCropInput[]
    createMany?: CropHarvestCreateManyCropInputEnvelope
    connect?: CropHarvestWhereUniqueInput | CropHarvestWhereUniqueInput[]
  }

  export type CropQualityLogUncheckedCreateNestedManyWithoutCropInput = {
    create?: XOR<CropQualityLogCreateWithoutCropInput, CropQualityLogUncheckedCreateWithoutCropInput> | CropQualityLogCreateWithoutCropInput[] | CropQualityLogUncheckedCreateWithoutCropInput[]
    connectOrCreate?: CropQualityLogCreateOrConnectWithoutCropInput | CropQualityLogCreateOrConnectWithoutCropInput[]
    createMany?: CropQualityLogCreateManyCropInputEnvelope
    connect?: CropQualityLogWhereUniqueInput | CropQualityLogWhereUniqueInput[]
  }

  export type CropMetricUncheckedCreateNestedManyWithoutCropInput = {
    create?: XOR<CropMetricCreateWithoutCropInput, CropMetricUncheckedCreateWithoutCropInput> | CropMetricCreateWithoutCropInput[] | CropMetricUncheckedCreateWithoutCropInput[]
    connectOrCreate?: CropMetricCreateOrConnectWithoutCropInput | CropMetricCreateOrConnectWithoutCropInput[]
    createMany?: CropMetricCreateManyCropInputEnvelope
    connect?: CropMetricWhereUniqueInput | CropMetricWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutCropsNestedInput = {
    create?: XOR<UserCreateWithoutCropsInput, UserUncheckedCreateWithoutCropsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCropsInput
    upsert?: UserUpsertWithoutCropsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCropsInput, UserUpdateWithoutCropsInput>, UserUncheckedUpdateWithoutCropsInput>
  }

  export type CropSprayUpdateManyWithoutCropNestedInput = {
    create?: XOR<CropSprayCreateWithoutCropInput, CropSprayUncheckedCreateWithoutCropInput> | CropSprayCreateWithoutCropInput[] | CropSprayUncheckedCreateWithoutCropInput[]
    connectOrCreate?: CropSprayCreateOrConnectWithoutCropInput | CropSprayCreateOrConnectWithoutCropInput[]
    upsert?: CropSprayUpsertWithWhereUniqueWithoutCropInput | CropSprayUpsertWithWhereUniqueWithoutCropInput[]
    createMany?: CropSprayCreateManyCropInputEnvelope
    set?: CropSprayWhereUniqueInput | CropSprayWhereUniqueInput[]
    disconnect?: CropSprayWhereUniqueInput | CropSprayWhereUniqueInput[]
    delete?: CropSprayWhereUniqueInput | CropSprayWhereUniqueInput[]
    connect?: CropSprayWhereUniqueInput | CropSprayWhereUniqueInput[]
    update?: CropSprayUpdateWithWhereUniqueWithoutCropInput | CropSprayUpdateWithWhereUniqueWithoutCropInput[]
    updateMany?: CropSprayUpdateManyWithWhereWithoutCropInput | CropSprayUpdateManyWithWhereWithoutCropInput[]
    deleteMany?: CropSprayScalarWhereInput | CropSprayScalarWhereInput[]
  }

  export type CropHarvestUpdateManyWithoutCropNestedInput = {
    create?: XOR<CropHarvestCreateWithoutCropInput, CropHarvestUncheckedCreateWithoutCropInput> | CropHarvestCreateWithoutCropInput[] | CropHarvestUncheckedCreateWithoutCropInput[]
    connectOrCreate?: CropHarvestCreateOrConnectWithoutCropInput | CropHarvestCreateOrConnectWithoutCropInput[]
    upsert?: CropHarvestUpsertWithWhereUniqueWithoutCropInput | CropHarvestUpsertWithWhereUniqueWithoutCropInput[]
    createMany?: CropHarvestCreateManyCropInputEnvelope
    set?: CropHarvestWhereUniqueInput | CropHarvestWhereUniqueInput[]
    disconnect?: CropHarvestWhereUniqueInput | CropHarvestWhereUniqueInput[]
    delete?: CropHarvestWhereUniqueInput | CropHarvestWhereUniqueInput[]
    connect?: CropHarvestWhereUniqueInput | CropHarvestWhereUniqueInput[]
    update?: CropHarvestUpdateWithWhereUniqueWithoutCropInput | CropHarvestUpdateWithWhereUniqueWithoutCropInput[]
    updateMany?: CropHarvestUpdateManyWithWhereWithoutCropInput | CropHarvestUpdateManyWithWhereWithoutCropInput[]
    deleteMany?: CropHarvestScalarWhereInput | CropHarvestScalarWhereInput[]
  }

  export type CropQualityLogUpdateManyWithoutCropNestedInput = {
    create?: XOR<CropQualityLogCreateWithoutCropInput, CropQualityLogUncheckedCreateWithoutCropInput> | CropQualityLogCreateWithoutCropInput[] | CropQualityLogUncheckedCreateWithoutCropInput[]
    connectOrCreate?: CropQualityLogCreateOrConnectWithoutCropInput | CropQualityLogCreateOrConnectWithoutCropInput[]
    upsert?: CropQualityLogUpsertWithWhereUniqueWithoutCropInput | CropQualityLogUpsertWithWhereUniqueWithoutCropInput[]
    createMany?: CropQualityLogCreateManyCropInputEnvelope
    set?: CropQualityLogWhereUniqueInput | CropQualityLogWhereUniqueInput[]
    disconnect?: CropQualityLogWhereUniqueInput | CropQualityLogWhereUniqueInput[]
    delete?: CropQualityLogWhereUniqueInput | CropQualityLogWhereUniqueInput[]
    connect?: CropQualityLogWhereUniqueInput | CropQualityLogWhereUniqueInput[]
    update?: CropQualityLogUpdateWithWhereUniqueWithoutCropInput | CropQualityLogUpdateWithWhereUniqueWithoutCropInput[]
    updateMany?: CropQualityLogUpdateManyWithWhereWithoutCropInput | CropQualityLogUpdateManyWithWhereWithoutCropInput[]
    deleteMany?: CropQualityLogScalarWhereInput | CropQualityLogScalarWhereInput[]
  }

  export type CropMetricUpdateManyWithoutCropNestedInput = {
    create?: XOR<CropMetricCreateWithoutCropInput, CropMetricUncheckedCreateWithoutCropInput> | CropMetricCreateWithoutCropInput[] | CropMetricUncheckedCreateWithoutCropInput[]
    connectOrCreate?: CropMetricCreateOrConnectWithoutCropInput | CropMetricCreateOrConnectWithoutCropInput[]
    upsert?: CropMetricUpsertWithWhereUniqueWithoutCropInput | CropMetricUpsertWithWhereUniqueWithoutCropInput[]
    createMany?: CropMetricCreateManyCropInputEnvelope
    set?: CropMetricWhereUniqueInput | CropMetricWhereUniqueInput[]
    disconnect?: CropMetricWhereUniqueInput | CropMetricWhereUniqueInput[]
    delete?: CropMetricWhereUniqueInput | CropMetricWhereUniqueInput[]
    connect?: CropMetricWhereUniqueInput | CropMetricWhereUniqueInput[]
    update?: CropMetricUpdateWithWhereUniqueWithoutCropInput | CropMetricUpdateWithWhereUniqueWithoutCropInput[]
    updateMany?: CropMetricUpdateManyWithWhereWithoutCropInput | CropMetricUpdateManyWithWhereWithoutCropInput[]
    deleteMany?: CropMetricScalarWhereInput | CropMetricScalarWhereInput[]
  }

  export type CropSprayUncheckedUpdateManyWithoutCropNestedInput = {
    create?: XOR<CropSprayCreateWithoutCropInput, CropSprayUncheckedCreateWithoutCropInput> | CropSprayCreateWithoutCropInput[] | CropSprayUncheckedCreateWithoutCropInput[]
    connectOrCreate?: CropSprayCreateOrConnectWithoutCropInput | CropSprayCreateOrConnectWithoutCropInput[]
    upsert?: CropSprayUpsertWithWhereUniqueWithoutCropInput | CropSprayUpsertWithWhereUniqueWithoutCropInput[]
    createMany?: CropSprayCreateManyCropInputEnvelope
    set?: CropSprayWhereUniqueInput | CropSprayWhereUniqueInput[]
    disconnect?: CropSprayWhereUniqueInput | CropSprayWhereUniqueInput[]
    delete?: CropSprayWhereUniqueInput | CropSprayWhereUniqueInput[]
    connect?: CropSprayWhereUniqueInput | CropSprayWhereUniqueInput[]
    update?: CropSprayUpdateWithWhereUniqueWithoutCropInput | CropSprayUpdateWithWhereUniqueWithoutCropInput[]
    updateMany?: CropSprayUpdateManyWithWhereWithoutCropInput | CropSprayUpdateManyWithWhereWithoutCropInput[]
    deleteMany?: CropSprayScalarWhereInput | CropSprayScalarWhereInput[]
  }

  export type CropHarvestUncheckedUpdateManyWithoutCropNestedInput = {
    create?: XOR<CropHarvestCreateWithoutCropInput, CropHarvestUncheckedCreateWithoutCropInput> | CropHarvestCreateWithoutCropInput[] | CropHarvestUncheckedCreateWithoutCropInput[]
    connectOrCreate?: CropHarvestCreateOrConnectWithoutCropInput | CropHarvestCreateOrConnectWithoutCropInput[]
    upsert?: CropHarvestUpsertWithWhereUniqueWithoutCropInput | CropHarvestUpsertWithWhereUniqueWithoutCropInput[]
    createMany?: CropHarvestCreateManyCropInputEnvelope
    set?: CropHarvestWhereUniqueInput | CropHarvestWhereUniqueInput[]
    disconnect?: CropHarvestWhereUniqueInput | CropHarvestWhereUniqueInput[]
    delete?: CropHarvestWhereUniqueInput | CropHarvestWhereUniqueInput[]
    connect?: CropHarvestWhereUniqueInput | CropHarvestWhereUniqueInput[]
    update?: CropHarvestUpdateWithWhereUniqueWithoutCropInput | CropHarvestUpdateWithWhereUniqueWithoutCropInput[]
    updateMany?: CropHarvestUpdateManyWithWhereWithoutCropInput | CropHarvestUpdateManyWithWhereWithoutCropInput[]
    deleteMany?: CropHarvestScalarWhereInput | CropHarvestScalarWhereInput[]
  }

  export type CropQualityLogUncheckedUpdateManyWithoutCropNestedInput = {
    create?: XOR<CropQualityLogCreateWithoutCropInput, CropQualityLogUncheckedCreateWithoutCropInput> | CropQualityLogCreateWithoutCropInput[] | CropQualityLogUncheckedCreateWithoutCropInput[]
    connectOrCreate?: CropQualityLogCreateOrConnectWithoutCropInput | CropQualityLogCreateOrConnectWithoutCropInput[]
    upsert?: CropQualityLogUpsertWithWhereUniqueWithoutCropInput | CropQualityLogUpsertWithWhereUniqueWithoutCropInput[]
    createMany?: CropQualityLogCreateManyCropInputEnvelope
    set?: CropQualityLogWhereUniqueInput | CropQualityLogWhereUniqueInput[]
    disconnect?: CropQualityLogWhereUniqueInput | CropQualityLogWhereUniqueInput[]
    delete?: CropQualityLogWhereUniqueInput | CropQualityLogWhereUniqueInput[]
    connect?: CropQualityLogWhereUniqueInput | CropQualityLogWhereUniqueInput[]
    update?: CropQualityLogUpdateWithWhereUniqueWithoutCropInput | CropQualityLogUpdateWithWhereUniqueWithoutCropInput[]
    updateMany?: CropQualityLogUpdateManyWithWhereWithoutCropInput | CropQualityLogUpdateManyWithWhereWithoutCropInput[]
    deleteMany?: CropQualityLogScalarWhereInput | CropQualityLogScalarWhereInput[]
  }

  export type CropMetricUncheckedUpdateManyWithoutCropNestedInput = {
    create?: XOR<CropMetricCreateWithoutCropInput, CropMetricUncheckedCreateWithoutCropInput> | CropMetricCreateWithoutCropInput[] | CropMetricUncheckedCreateWithoutCropInput[]
    connectOrCreate?: CropMetricCreateOrConnectWithoutCropInput | CropMetricCreateOrConnectWithoutCropInput[]
    upsert?: CropMetricUpsertWithWhereUniqueWithoutCropInput | CropMetricUpsertWithWhereUniqueWithoutCropInput[]
    createMany?: CropMetricCreateManyCropInputEnvelope
    set?: CropMetricWhereUniqueInput | CropMetricWhereUniqueInput[]
    disconnect?: CropMetricWhereUniqueInput | CropMetricWhereUniqueInput[]
    delete?: CropMetricWhereUniqueInput | CropMetricWhereUniqueInput[]
    connect?: CropMetricWhereUniqueInput | CropMetricWhereUniqueInput[]
    update?: CropMetricUpdateWithWhereUniqueWithoutCropInput | CropMetricUpdateWithWhereUniqueWithoutCropInput[]
    updateMany?: CropMetricUpdateManyWithWhereWithoutCropInput | CropMetricUpdateManyWithWhereWithoutCropInput[]
    deleteMany?: CropMetricScalarWhereInput | CropMetricScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLivestockInput = {
    create?: XOR<UserCreateWithoutLivestockInput, UserUncheckedCreateWithoutLivestockInput>
    connectOrCreate?: UserCreateOrConnectWithoutLivestockInput
    connect?: UserWhereUniqueInput
  }

  export type MilkLogCreateNestedManyWithoutLivestockInput = {
    create?: XOR<MilkLogCreateWithoutLivestockInput, MilkLogUncheckedCreateWithoutLivestockInput> | MilkLogCreateWithoutLivestockInput[] | MilkLogUncheckedCreateWithoutLivestockInput[]
    connectOrCreate?: MilkLogCreateOrConnectWithoutLivestockInput | MilkLogCreateOrConnectWithoutLivestockInput[]
    createMany?: MilkLogCreateManyLivestockInputEnvelope
    connect?: MilkLogWhereUniqueInput | MilkLogWhereUniqueInput[]
  }

  export type EggLogCreateNestedManyWithoutLivestockInput = {
    create?: XOR<EggLogCreateWithoutLivestockInput, EggLogUncheckedCreateWithoutLivestockInput> | EggLogCreateWithoutLivestockInput[] | EggLogUncheckedCreateWithoutLivestockInput[]
    connectOrCreate?: EggLogCreateOrConnectWithoutLivestockInput | EggLogCreateOrConnectWithoutLivestockInput[]
    createMany?: EggLogCreateManyLivestockInputEnvelope
    connect?: EggLogWhereUniqueInput | EggLogWhereUniqueInput[]
  }

  export type HoneyLogCreateNestedManyWithoutLivestockInput = {
    create?: XOR<HoneyLogCreateWithoutLivestockInput, HoneyLogUncheckedCreateWithoutLivestockInput> | HoneyLogCreateWithoutLivestockInput[] | HoneyLogUncheckedCreateWithoutLivestockInput[]
    connectOrCreate?: HoneyLogCreateOrConnectWithoutLivestockInput | HoneyLogCreateOrConnectWithoutLivestockInput[]
    createMany?: HoneyLogCreateManyLivestockInputEnvelope
    connect?: HoneyLogWhereUniqueInput | HoneyLogWhereUniqueInput[]
  }

  export type WoolLogCreateNestedManyWithoutLivestockInput = {
    create?: XOR<WoolLogCreateWithoutLivestockInput, WoolLogUncheckedCreateWithoutLivestockInput> | WoolLogCreateWithoutLivestockInput[] | WoolLogUncheckedCreateWithoutLivestockInput[]
    connectOrCreate?: WoolLogCreateOrConnectWithoutLivestockInput | WoolLogCreateOrConnectWithoutLivestockInput[]
    createMany?: WoolLogCreateManyLivestockInputEnvelope
    connect?: WoolLogWhereUniqueInput | WoolLogWhereUniqueInput[]
  }

  export type WeightLogCreateNestedManyWithoutLivestockInput = {
    create?: XOR<WeightLogCreateWithoutLivestockInput, WeightLogUncheckedCreateWithoutLivestockInput> | WeightLogCreateWithoutLivestockInput[] | WeightLogUncheckedCreateWithoutLivestockInput[]
    connectOrCreate?: WeightLogCreateOrConnectWithoutLivestockInput | WeightLogCreateOrConnectWithoutLivestockInput[]
    createMany?: WeightLogCreateManyLivestockInputEnvelope
    connect?: WeightLogWhereUniqueInput | WeightLogWhereUniqueInput[]
  }

  export type LivestockMetricCreateNestedManyWithoutLivestockInput = {
    create?: XOR<LivestockMetricCreateWithoutLivestockInput, LivestockMetricUncheckedCreateWithoutLivestockInput> | LivestockMetricCreateWithoutLivestockInput[] | LivestockMetricUncheckedCreateWithoutLivestockInput[]
    connectOrCreate?: LivestockMetricCreateOrConnectWithoutLivestockInput | LivestockMetricCreateOrConnectWithoutLivestockInput[]
    createMany?: LivestockMetricCreateManyLivestockInputEnvelope
    connect?: LivestockMetricWhereUniqueInput | LivestockMetricWhereUniqueInput[]
  }

  export type MilkLogUncheckedCreateNestedManyWithoutLivestockInput = {
    create?: XOR<MilkLogCreateWithoutLivestockInput, MilkLogUncheckedCreateWithoutLivestockInput> | MilkLogCreateWithoutLivestockInput[] | MilkLogUncheckedCreateWithoutLivestockInput[]
    connectOrCreate?: MilkLogCreateOrConnectWithoutLivestockInput | MilkLogCreateOrConnectWithoutLivestockInput[]
    createMany?: MilkLogCreateManyLivestockInputEnvelope
    connect?: MilkLogWhereUniqueInput | MilkLogWhereUniqueInput[]
  }

  export type EggLogUncheckedCreateNestedManyWithoutLivestockInput = {
    create?: XOR<EggLogCreateWithoutLivestockInput, EggLogUncheckedCreateWithoutLivestockInput> | EggLogCreateWithoutLivestockInput[] | EggLogUncheckedCreateWithoutLivestockInput[]
    connectOrCreate?: EggLogCreateOrConnectWithoutLivestockInput | EggLogCreateOrConnectWithoutLivestockInput[]
    createMany?: EggLogCreateManyLivestockInputEnvelope
    connect?: EggLogWhereUniqueInput | EggLogWhereUniqueInput[]
  }

  export type HoneyLogUncheckedCreateNestedManyWithoutLivestockInput = {
    create?: XOR<HoneyLogCreateWithoutLivestockInput, HoneyLogUncheckedCreateWithoutLivestockInput> | HoneyLogCreateWithoutLivestockInput[] | HoneyLogUncheckedCreateWithoutLivestockInput[]
    connectOrCreate?: HoneyLogCreateOrConnectWithoutLivestockInput | HoneyLogCreateOrConnectWithoutLivestockInput[]
    createMany?: HoneyLogCreateManyLivestockInputEnvelope
    connect?: HoneyLogWhereUniqueInput | HoneyLogWhereUniqueInput[]
  }

  export type WoolLogUncheckedCreateNestedManyWithoutLivestockInput = {
    create?: XOR<WoolLogCreateWithoutLivestockInput, WoolLogUncheckedCreateWithoutLivestockInput> | WoolLogCreateWithoutLivestockInput[] | WoolLogUncheckedCreateWithoutLivestockInput[]
    connectOrCreate?: WoolLogCreateOrConnectWithoutLivestockInput | WoolLogCreateOrConnectWithoutLivestockInput[]
    createMany?: WoolLogCreateManyLivestockInputEnvelope
    connect?: WoolLogWhereUniqueInput | WoolLogWhereUniqueInput[]
  }

  export type WeightLogUncheckedCreateNestedManyWithoutLivestockInput = {
    create?: XOR<WeightLogCreateWithoutLivestockInput, WeightLogUncheckedCreateWithoutLivestockInput> | WeightLogCreateWithoutLivestockInput[] | WeightLogUncheckedCreateWithoutLivestockInput[]
    connectOrCreate?: WeightLogCreateOrConnectWithoutLivestockInput | WeightLogCreateOrConnectWithoutLivestockInput[]
    createMany?: WeightLogCreateManyLivestockInputEnvelope
    connect?: WeightLogWhereUniqueInput | WeightLogWhereUniqueInput[]
  }

  export type LivestockMetricUncheckedCreateNestedManyWithoutLivestockInput = {
    create?: XOR<LivestockMetricCreateWithoutLivestockInput, LivestockMetricUncheckedCreateWithoutLivestockInput> | LivestockMetricCreateWithoutLivestockInput[] | LivestockMetricUncheckedCreateWithoutLivestockInput[]
    connectOrCreate?: LivestockMetricCreateOrConnectWithoutLivestockInput | LivestockMetricCreateOrConnectWithoutLivestockInput[]
    createMany?: LivestockMetricCreateManyLivestockInputEnvelope
    connect?: LivestockMetricWhereUniqueInput | LivestockMetricWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutLivestockNestedInput = {
    create?: XOR<UserCreateWithoutLivestockInput, UserUncheckedCreateWithoutLivestockInput>
    connectOrCreate?: UserCreateOrConnectWithoutLivestockInput
    upsert?: UserUpsertWithoutLivestockInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLivestockInput, UserUpdateWithoutLivestockInput>, UserUncheckedUpdateWithoutLivestockInput>
  }

  export type MilkLogUpdateManyWithoutLivestockNestedInput = {
    create?: XOR<MilkLogCreateWithoutLivestockInput, MilkLogUncheckedCreateWithoutLivestockInput> | MilkLogCreateWithoutLivestockInput[] | MilkLogUncheckedCreateWithoutLivestockInput[]
    connectOrCreate?: MilkLogCreateOrConnectWithoutLivestockInput | MilkLogCreateOrConnectWithoutLivestockInput[]
    upsert?: MilkLogUpsertWithWhereUniqueWithoutLivestockInput | MilkLogUpsertWithWhereUniqueWithoutLivestockInput[]
    createMany?: MilkLogCreateManyLivestockInputEnvelope
    set?: MilkLogWhereUniqueInput | MilkLogWhereUniqueInput[]
    disconnect?: MilkLogWhereUniqueInput | MilkLogWhereUniqueInput[]
    delete?: MilkLogWhereUniqueInput | MilkLogWhereUniqueInput[]
    connect?: MilkLogWhereUniqueInput | MilkLogWhereUniqueInput[]
    update?: MilkLogUpdateWithWhereUniqueWithoutLivestockInput | MilkLogUpdateWithWhereUniqueWithoutLivestockInput[]
    updateMany?: MilkLogUpdateManyWithWhereWithoutLivestockInput | MilkLogUpdateManyWithWhereWithoutLivestockInput[]
    deleteMany?: MilkLogScalarWhereInput | MilkLogScalarWhereInput[]
  }

  export type EggLogUpdateManyWithoutLivestockNestedInput = {
    create?: XOR<EggLogCreateWithoutLivestockInput, EggLogUncheckedCreateWithoutLivestockInput> | EggLogCreateWithoutLivestockInput[] | EggLogUncheckedCreateWithoutLivestockInput[]
    connectOrCreate?: EggLogCreateOrConnectWithoutLivestockInput | EggLogCreateOrConnectWithoutLivestockInput[]
    upsert?: EggLogUpsertWithWhereUniqueWithoutLivestockInput | EggLogUpsertWithWhereUniqueWithoutLivestockInput[]
    createMany?: EggLogCreateManyLivestockInputEnvelope
    set?: EggLogWhereUniqueInput | EggLogWhereUniqueInput[]
    disconnect?: EggLogWhereUniqueInput | EggLogWhereUniqueInput[]
    delete?: EggLogWhereUniqueInput | EggLogWhereUniqueInput[]
    connect?: EggLogWhereUniqueInput | EggLogWhereUniqueInput[]
    update?: EggLogUpdateWithWhereUniqueWithoutLivestockInput | EggLogUpdateWithWhereUniqueWithoutLivestockInput[]
    updateMany?: EggLogUpdateManyWithWhereWithoutLivestockInput | EggLogUpdateManyWithWhereWithoutLivestockInput[]
    deleteMany?: EggLogScalarWhereInput | EggLogScalarWhereInput[]
  }

  export type HoneyLogUpdateManyWithoutLivestockNestedInput = {
    create?: XOR<HoneyLogCreateWithoutLivestockInput, HoneyLogUncheckedCreateWithoutLivestockInput> | HoneyLogCreateWithoutLivestockInput[] | HoneyLogUncheckedCreateWithoutLivestockInput[]
    connectOrCreate?: HoneyLogCreateOrConnectWithoutLivestockInput | HoneyLogCreateOrConnectWithoutLivestockInput[]
    upsert?: HoneyLogUpsertWithWhereUniqueWithoutLivestockInput | HoneyLogUpsertWithWhereUniqueWithoutLivestockInput[]
    createMany?: HoneyLogCreateManyLivestockInputEnvelope
    set?: HoneyLogWhereUniqueInput | HoneyLogWhereUniqueInput[]
    disconnect?: HoneyLogWhereUniqueInput | HoneyLogWhereUniqueInput[]
    delete?: HoneyLogWhereUniqueInput | HoneyLogWhereUniqueInput[]
    connect?: HoneyLogWhereUniqueInput | HoneyLogWhereUniqueInput[]
    update?: HoneyLogUpdateWithWhereUniqueWithoutLivestockInput | HoneyLogUpdateWithWhereUniqueWithoutLivestockInput[]
    updateMany?: HoneyLogUpdateManyWithWhereWithoutLivestockInput | HoneyLogUpdateManyWithWhereWithoutLivestockInput[]
    deleteMany?: HoneyLogScalarWhereInput | HoneyLogScalarWhereInput[]
  }

  export type WoolLogUpdateManyWithoutLivestockNestedInput = {
    create?: XOR<WoolLogCreateWithoutLivestockInput, WoolLogUncheckedCreateWithoutLivestockInput> | WoolLogCreateWithoutLivestockInput[] | WoolLogUncheckedCreateWithoutLivestockInput[]
    connectOrCreate?: WoolLogCreateOrConnectWithoutLivestockInput | WoolLogCreateOrConnectWithoutLivestockInput[]
    upsert?: WoolLogUpsertWithWhereUniqueWithoutLivestockInput | WoolLogUpsertWithWhereUniqueWithoutLivestockInput[]
    createMany?: WoolLogCreateManyLivestockInputEnvelope
    set?: WoolLogWhereUniqueInput | WoolLogWhereUniqueInput[]
    disconnect?: WoolLogWhereUniqueInput | WoolLogWhereUniqueInput[]
    delete?: WoolLogWhereUniqueInput | WoolLogWhereUniqueInput[]
    connect?: WoolLogWhereUniqueInput | WoolLogWhereUniqueInput[]
    update?: WoolLogUpdateWithWhereUniqueWithoutLivestockInput | WoolLogUpdateWithWhereUniqueWithoutLivestockInput[]
    updateMany?: WoolLogUpdateManyWithWhereWithoutLivestockInput | WoolLogUpdateManyWithWhereWithoutLivestockInput[]
    deleteMany?: WoolLogScalarWhereInput | WoolLogScalarWhereInput[]
  }

  export type WeightLogUpdateManyWithoutLivestockNestedInput = {
    create?: XOR<WeightLogCreateWithoutLivestockInput, WeightLogUncheckedCreateWithoutLivestockInput> | WeightLogCreateWithoutLivestockInput[] | WeightLogUncheckedCreateWithoutLivestockInput[]
    connectOrCreate?: WeightLogCreateOrConnectWithoutLivestockInput | WeightLogCreateOrConnectWithoutLivestockInput[]
    upsert?: WeightLogUpsertWithWhereUniqueWithoutLivestockInput | WeightLogUpsertWithWhereUniqueWithoutLivestockInput[]
    createMany?: WeightLogCreateManyLivestockInputEnvelope
    set?: WeightLogWhereUniqueInput | WeightLogWhereUniqueInput[]
    disconnect?: WeightLogWhereUniqueInput | WeightLogWhereUniqueInput[]
    delete?: WeightLogWhereUniqueInput | WeightLogWhereUniqueInput[]
    connect?: WeightLogWhereUniqueInput | WeightLogWhereUniqueInput[]
    update?: WeightLogUpdateWithWhereUniqueWithoutLivestockInput | WeightLogUpdateWithWhereUniqueWithoutLivestockInput[]
    updateMany?: WeightLogUpdateManyWithWhereWithoutLivestockInput | WeightLogUpdateManyWithWhereWithoutLivestockInput[]
    deleteMany?: WeightLogScalarWhereInput | WeightLogScalarWhereInput[]
  }

  export type LivestockMetricUpdateManyWithoutLivestockNestedInput = {
    create?: XOR<LivestockMetricCreateWithoutLivestockInput, LivestockMetricUncheckedCreateWithoutLivestockInput> | LivestockMetricCreateWithoutLivestockInput[] | LivestockMetricUncheckedCreateWithoutLivestockInput[]
    connectOrCreate?: LivestockMetricCreateOrConnectWithoutLivestockInput | LivestockMetricCreateOrConnectWithoutLivestockInput[]
    upsert?: LivestockMetricUpsertWithWhereUniqueWithoutLivestockInput | LivestockMetricUpsertWithWhereUniqueWithoutLivestockInput[]
    createMany?: LivestockMetricCreateManyLivestockInputEnvelope
    set?: LivestockMetricWhereUniqueInput | LivestockMetricWhereUniqueInput[]
    disconnect?: LivestockMetricWhereUniqueInput | LivestockMetricWhereUniqueInput[]
    delete?: LivestockMetricWhereUniqueInput | LivestockMetricWhereUniqueInput[]
    connect?: LivestockMetricWhereUniqueInput | LivestockMetricWhereUniqueInput[]
    update?: LivestockMetricUpdateWithWhereUniqueWithoutLivestockInput | LivestockMetricUpdateWithWhereUniqueWithoutLivestockInput[]
    updateMany?: LivestockMetricUpdateManyWithWhereWithoutLivestockInput | LivestockMetricUpdateManyWithWhereWithoutLivestockInput[]
    deleteMany?: LivestockMetricScalarWhereInput | LivestockMetricScalarWhereInput[]
  }

  export type MilkLogUncheckedUpdateManyWithoutLivestockNestedInput = {
    create?: XOR<MilkLogCreateWithoutLivestockInput, MilkLogUncheckedCreateWithoutLivestockInput> | MilkLogCreateWithoutLivestockInput[] | MilkLogUncheckedCreateWithoutLivestockInput[]
    connectOrCreate?: MilkLogCreateOrConnectWithoutLivestockInput | MilkLogCreateOrConnectWithoutLivestockInput[]
    upsert?: MilkLogUpsertWithWhereUniqueWithoutLivestockInput | MilkLogUpsertWithWhereUniqueWithoutLivestockInput[]
    createMany?: MilkLogCreateManyLivestockInputEnvelope
    set?: MilkLogWhereUniqueInput | MilkLogWhereUniqueInput[]
    disconnect?: MilkLogWhereUniqueInput | MilkLogWhereUniqueInput[]
    delete?: MilkLogWhereUniqueInput | MilkLogWhereUniqueInput[]
    connect?: MilkLogWhereUniqueInput | MilkLogWhereUniqueInput[]
    update?: MilkLogUpdateWithWhereUniqueWithoutLivestockInput | MilkLogUpdateWithWhereUniqueWithoutLivestockInput[]
    updateMany?: MilkLogUpdateManyWithWhereWithoutLivestockInput | MilkLogUpdateManyWithWhereWithoutLivestockInput[]
    deleteMany?: MilkLogScalarWhereInput | MilkLogScalarWhereInput[]
  }

  export type EggLogUncheckedUpdateManyWithoutLivestockNestedInput = {
    create?: XOR<EggLogCreateWithoutLivestockInput, EggLogUncheckedCreateWithoutLivestockInput> | EggLogCreateWithoutLivestockInput[] | EggLogUncheckedCreateWithoutLivestockInput[]
    connectOrCreate?: EggLogCreateOrConnectWithoutLivestockInput | EggLogCreateOrConnectWithoutLivestockInput[]
    upsert?: EggLogUpsertWithWhereUniqueWithoutLivestockInput | EggLogUpsertWithWhereUniqueWithoutLivestockInput[]
    createMany?: EggLogCreateManyLivestockInputEnvelope
    set?: EggLogWhereUniqueInput | EggLogWhereUniqueInput[]
    disconnect?: EggLogWhereUniqueInput | EggLogWhereUniqueInput[]
    delete?: EggLogWhereUniqueInput | EggLogWhereUniqueInput[]
    connect?: EggLogWhereUniqueInput | EggLogWhereUniqueInput[]
    update?: EggLogUpdateWithWhereUniqueWithoutLivestockInput | EggLogUpdateWithWhereUniqueWithoutLivestockInput[]
    updateMany?: EggLogUpdateManyWithWhereWithoutLivestockInput | EggLogUpdateManyWithWhereWithoutLivestockInput[]
    deleteMany?: EggLogScalarWhereInput | EggLogScalarWhereInput[]
  }

  export type HoneyLogUncheckedUpdateManyWithoutLivestockNestedInput = {
    create?: XOR<HoneyLogCreateWithoutLivestockInput, HoneyLogUncheckedCreateWithoutLivestockInput> | HoneyLogCreateWithoutLivestockInput[] | HoneyLogUncheckedCreateWithoutLivestockInput[]
    connectOrCreate?: HoneyLogCreateOrConnectWithoutLivestockInput | HoneyLogCreateOrConnectWithoutLivestockInput[]
    upsert?: HoneyLogUpsertWithWhereUniqueWithoutLivestockInput | HoneyLogUpsertWithWhereUniqueWithoutLivestockInput[]
    createMany?: HoneyLogCreateManyLivestockInputEnvelope
    set?: HoneyLogWhereUniqueInput | HoneyLogWhereUniqueInput[]
    disconnect?: HoneyLogWhereUniqueInput | HoneyLogWhereUniqueInput[]
    delete?: HoneyLogWhereUniqueInput | HoneyLogWhereUniqueInput[]
    connect?: HoneyLogWhereUniqueInput | HoneyLogWhereUniqueInput[]
    update?: HoneyLogUpdateWithWhereUniqueWithoutLivestockInput | HoneyLogUpdateWithWhereUniqueWithoutLivestockInput[]
    updateMany?: HoneyLogUpdateManyWithWhereWithoutLivestockInput | HoneyLogUpdateManyWithWhereWithoutLivestockInput[]
    deleteMany?: HoneyLogScalarWhereInput | HoneyLogScalarWhereInput[]
  }

  export type WoolLogUncheckedUpdateManyWithoutLivestockNestedInput = {
    create?: XOR<WoolLogCreateWithoutLivestockInput, WoolLogUncheckedCreateWithoutLivestockInput> | WoolLogCreateWithoutLivestockInput[] | WoolLogUncheckedCreateWithoutLivestockInput[]
    connectOrCreate?: WoolLogCreateOrConnectWithoutLivestockInput | WoolLogCreateOrConnectWithoutLivestockInput[]
    upsert?: WoolLogUpsertWithWhereUniqueWithoutLivestockInput | WoolLogUpsertWithWhereUniqueWithoutLivestockInput[]
    createMany?: WoolLogCreateManyLivestockInputEnvelope
    set?: WoolLogWhereUniqueInput | WoolLogWhereUniqueInput[]
    disconnect?: WoolLogWhereUniqueInput | WoolLogWhereUniqueInput[]
    delete?: WoolLogWhereUniqueInput | WoolLogWhereUniqueInput[]
    connect?: WoolLogWhereUniqueInput | WoolLogWhereUniqueInput[]
    update?: WoolLogUpdateWithWhereUniqueWithoutLivestockInput | WoolLogUpdateWithWhereUniqueWithoutLivestockInput[]
    updateMany?: WoolLogUpdateManyWithWhereWithoutLivestockInput | WoolLogUpdateManyWithWhereWithoutLivestockInput[]
    deleteMany?: WoolLogScalarWhereInput | WoolLogScalarWhereInput[]
  }

  export type WeightLogUncheckedUpdateManyWithoutLivestockNestedInput = {
    create?: XOR<WeightLogCreateWithoutLivestockInput, WeightLogUncheckedCreateWithoutLivestockInput> | WeightLogCreateWithoutLivestockInput[] | WeightLogUncheckedCreateWithoutLivestockInput[]
    connectOrCreate?: WeightLogCreateOrConnectWithoutLivestockInput | WeightLogCreateOrConnectWithoutLivestockInput[]
    upsert?: WeightLogUpsertWithWhereUniqueWithoutLivestockInput | WeightLogUpsertWithWhereUniqueWithoutLivestockInput[]
    createMany?: WeightLogCreateManyLivestockInputEnvelope
    set?: WeightLogWhereUniqueInput | WeightLogWhereUniqueInput[]
    disconnect?: WeightLogWhereUniqueInput | WeightLogWhereUniqueInput[]
    delete?: WeightLogWhereUniqueInput | WeightLogWhereUniqueInput[]
    connect?: WeightLogWhereUniqueInput | WeightLogWhereUniqueInput[]
    update?: WeightLogUpdateWithWhereUniqueWithoutLivestockInput | WeightLogUpdateWithWhereUniqueWithoutLivestockInput[]
    updateMany?: WeightLogUpdateManyWithWhereWithoutLivestockInput | WeightLogUpdateManyWithWhereWithoutLivestockInput[]
    deleteMany?: WeightLogScalarWhereInput | WeightLogScalarWhereInput[]
  }

  export type LivestockMetricUncheckedUpdateManyWithoutLivestockNestedInput = {
    create?: XOR<LivestockMetricCreateWithoutLivestockInput, LivestockMetricUncheckedCreateWithoutLivestockInput> | LivestockMetricCreateWithoutLivestockInput[] | LivestockMetricUncheckedCreateWithoutLivestockInput[]
    connectOrCreate?: LivestockMetricCreateOrConnectWithoutLivestockInput | LivestockMetricCreateOrConnectWithoutLivestockInput[]
    upsert?: LivestockMetricUpsertWithWhereUniqueWithoutLivestockInput | LivestockMetricUpsertWithWhereUniqueWithoutLivestockInput[]
    createMany?: LivestockMetricCreateManyLivestockInputEnvelope
    set?: LivestockMetricWhereUniqueInput | LivestockMetricWhereUniqueInput[]
    disconnect?: LivestockMetricWhereUniqueInput | LivestockMetricWhereUniqueInput[]
    delete?: LivestockMetricWhereUniqueInput | LivestockMetricWhereUniqueInput[]
    connect?: LivestockMetricWhereUniqueInput | LivestockMetricWhereUniqueInput[]
    update?: LivestockMetricUpdateWithWhereUniqueWithoutLivestockInput | LivestockMetricUpdateWithWhereUniqueWithoutLivestockInput[]
    updateMany?: LivestockMetricUpdateManyWithWhereWithoutLivestockInput | LivestockMetricUpdateManyWithWhereWithoutLivestockInput[]
    deleteMany?: LivestockMetricScalarWhereInput | LivestockMetricScalarWhereInput[]
  }

  export type CropCreateNestedOneWithoutSpraysInput = {
    create?: XOR<CropCreateWithoutSpraysInput, CropUncheckedCreateWithoutSpraysInput>
    connectOrCreate?: CropCreateOrConnectWithoutSpraysInput
    connect?: CropWhereUniqueInput
  }

  export type CropUpdateOneRequiredWithoutSpraysNestedInput = {
    create?: XOR<CropCreateWithoutSpraysInput, CropUncheckedCreateWithoutSpraysInput>
    connectOrCreate?: CropCreateOrConnectWithoutSpraysInput
    upsert?: CropUpsertWithoutSpraysInput
    connect?: CropWhereUniqueInput
    update?: XOR<XOR<CropUpdateToOneWithWhereWithoutSpraysInput, CropUpdateWithoutSpraysInput>, CropUncheckedUpdateWithoutSpraysInput>
  }

  export type CropCreateNestedOneWithoutHarvestsInput = {
    create?: XOR<CropCreateWithoutHarvestsInput, CropUncheckedCreateWithoutHarvestsInput>
    connectOrCreate?: CropCreateOrConnectWithoutHarvestsInput
    connect?: CropWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CropUpdateOneRequiredWithoutHarvestsNestedInput = {
    create?: XOR<CropCreateWithoutHarvestsInput, CropUncheckedCreateWithoutHarvestsInput>
    connectOrCreate?: CropCreateOrConnectWithoutHarvestsInput
    upsert?: CropUpsertWithoutHarvestsInput
    connect?: CropWhereUniqueInput
    update?: XOR<XOR<CropUpdateToOneWithWhereWithoutHarvestsInput, CropUpdateWithoutHarvestsInput>, CropUncheckedUpdateWithoutHarvestsInput>
  }

  export type LivestockCreateNestedOneWithoutMilkLogsInput = {
    create?: XOR<LivestockCreateWithoutMilkLogsInput, LivestockUncheckedCreateWithoutMilkLogsInput>
    connectOrCreate?: LivestockCreateOrConnectWithoutMilkLogsInput
    connect?: LivestockWhereUniqueInput
  }

  export type LivestockUpdateOneRequiredWithoutMilkLogsNestedInput = {
    create?: XOR<LivestockCreateWithoutMilkLogsInput, LivestockUncheckedCreateWithoutMilkLogsInput>
    connectOrCreate?: LivestockCreateOrConnectWithoutMilkLogsInput
    upsert?: LivestockUpsertWithoutMilkLogsInput
    connect?: LivestockWhereUniqueInput
    update?: XOR<XOR<LivestockUpdateToOneWithWhereWithoutMilkLogsInput, LivestockUpdateWithoutMilkLogsInput>, LivestockUncheckedUpdateWithoutMilkLogsInput>
  }

  export type LivestockCreateNestedOneWithoutEggLogsInput = {
    create?: XOR<LivestockCreateWithoutEggLogsInput, LivestockUncheckedCreateWithoutEggLogsInput>
    connectOrCreate?: LivestockCreateOrConnectWithoutEggLogsInput
    connect?: LivestockWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LivestockUpdateOneRequiredWithoutEggLogsNestedInput = {
    create?: XOR<LivestockCreateWithoutEggLogsInput, LivestockUncheckedCreateWithoutEggLogsInput>
    connectOrCreate?: LivestockCreateOrConnectWithoutEggLogsInput
    upsert?: LivestockUpsertWithoutEggLogsInput
    connect?: LivestockWhereUniqueInput
    update?: XOR<XOR<LivestockUpdateToOneWithWhereWithoutEggLogsInput, LivestockUpdateWithoutEggLogsInput>, LivestockUncheckedUpdateWithoutEggLogsInput>
  }

  export type LivestockCreateNestedOneWithoutHoneyLogsInput = {
    create?: XOR<LivestockCreateWithoutHoneyLogsInput, LivestockUncheckedCreateWithoutHoneyLogsInput>
    connectOrCreate?: LivestockCreateOrConnectWithoutHoneyLogsInput
    connect?: LivestockWhereUniqueInput
  }

  export type LivestockUpdateOneRequiredWithoutHoneyLogsNestedInput = {
    create?: XOR<LivestockCreateWithoutHoneyLogsInput, LivestockUncheckedCreateWithoutHoneyLogsInput>
    connectOrCreate?: LivestockCreateOrConnectWithoutHoneyLogsInput
    upsert?: LivestockUpsertWithoutHoneyLogsInput
    connect?: LivestockWhereUniqueInput
    update?: XOR<XOR<LivestockUpdateToOneWithWhereWithoutHoneyLogsInput, LivestockUpdateWithoutHoneyLogsInput>, LivestockUncheckedUpdateWithoutHoneyLogsInput>
  }

  export type LivestockCreateNestedOneWithoutWoolLogsInput = {
    create?: XOR<LivestockCreateWithoutWoolLogsInput, LivestockUncheckedCreateWithoutWoolLogsInput>
    connectOrCreate?: LivestockCreateOrConnectWithoutWoolLogsInput
    connect?: LivestockWhereUniqueInput
  }

  export type LivestockUpdateOneRequiredWithoutWoolLogsNestedInput = {
    create?: XOR<LivestockCreateWithoutWoolLogsInput, LivestockUncheckedCreateWithoutWoolLogsInput>
    connectOrCreate?: LivestockCreateOrConnectWithoutWoolLogsInput
    upsert?: LivestockUpsertWithoutWoolLogsInput
    connect?: LivestockWhereUniqueInput
    update?: XOR<XOR<LivestockUpdateToOneWithWhereWithoutWoolLogsInput, LivestockUpdateWithoutWoolLogsInput>, LivestockUncheckedUpdateWithoutWoolLogsInput>
  }

  export type LivestockCreateNestedOneWithoutWeightLogsInput = {
    create?: XOR<LivestockCreateWithoutWeightLogsInput, LivestockUncheckedCreateWithoutWeightLogsInput>
    connectOrCreate?: LivestockCreateOrConnectWithoutWeightLogsInput
    connect?: LivestockWhereUniqueInput
  }

  export type LivestockUpdateOneRequiredWithoutWeightLogsNestedInput = {
    create?: XOR<LivestockCreateWithoutWeightLogsInput, LivestockUncheckedCreateWithoutWeightLogsInput>
    connectOrCreate?: LivestockCreateOrConnectWithoutWeightLogsInput
    upsert?: LivestockUpsertWithoutWeightLogsInput
    connect?: LivestockWhereUniqueInput
    update?: XOR<XOR<LivestockUpdateToOneWithWhereWithoutWeightLogsInput, LivestockUpdateWithoutWeightLogsInput>, LivestockUncheckedUpdateWithoutWeightLogsInput>
  }

  export type LivestockCreateNestedOneWithoutMetricsInput = {
    create?: XOR<LivestockCreateWithoutMetricsInput, LivestockUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: LivestockCreateOrConnectWithoutMetricsInput
    connect?: LivestockWhereUniqueInput
  }

  export type LivestockUpdateOneRequiredWithoutMetricsNestedInput = {
    create?: XOR<LivestockCreateWithoutMetricsInput, LivestockUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: LivestockCreateOrConnectWithoutMetricsInput
    upsert?: LivestockUpsertWithoutMetricsInput
    connect?: LivestockWhereUniqueInput
    update?: XOR<XOR<LivestockUpdateToOneWithWhereWithoutMetricsInput, LivestockUpdateWithoutMetricsInput>, LivestockUncheckedUpdateWithoutMetricsInput>
  }

  export type CropCreateNestedOneWithoutQualityLogsInput = {
    create?: XOR<CropCreateWithoutQualityLogsInput, CropUncheckedCreateWithoutQualityLogsInput>
    connectOrCreate?: CropCreateOrConnectWithoutQualityLogsInput
    connect?: CropWhereUniqueInput
  }

  export type CropUpdateOneRequiredWithoutQualityLogsNestedInput = {
    create?: XOR<CropCreateWithoutQualityLogsInput, CropUncheckedCreateWithoutQualityLogsInput>
    connectOrCreate?: CropCreateOrConnectWithoutQualityLogsInput
    upsert?: CropUpsertWithoutQualityLogsInput
    connect?: CropWhereUniqueInput
    update?: XOR<XOR<CropUpdateToOneWithWhereWithoutQualityLogsInput, CropUpdateWithoutQualityLogsInput>, CropUncheckedUpdateWithoutQualityLogsInput>
  }

  export type CropCreateNestedOneWithoutMetricsInput = {
    create?: XOR<CropCreateWithoutMetricsInput, CropUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: CropCreateOrConnectWithoutMetricsInput
    connect?: CropWhereUniqueInput
  }

  export type CropUpdateOneRequiredWithoutMetricsNestedInput = {
    create?: XOR<CropCreateWithoutMetricsInput, CropUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: CropCreateOrConnectWithoutMetricsInput
    upsert?: CropUpsertWithoutMetricsInput
    connect?: CropWhereUniqueInput
    update?: XOR<XOR<CropUpdateToOneWithWhereWithoutMetricsInput, CropUpdateWithoutMetricsInput>, CropUncheckedUpdateWithoutMetricsInput>
  }

  export type UserCreateNestedOneWithoutListingsInput = {
    create?: XOR<UserCreateWithoutListingsInput, UserUncheckedCreateWithoutListingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutListingsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.ItemType
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutListingsNestedInput = {
    create?: XOR<UserCreateWithoutListingsInput, UserUncheckedCreateWithoutListingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutListingsInput
    upsert?: UserUpsertWithoutListingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutListingsInput, UserUpdateWithoutListingsInput>, UserUncheckedUpdateWithoutListingsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeFilter<$PrismaModel> | $Enums.ItemType
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.ItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemTypeFilter<$PrismaModel>
    _max?: NestedEnumItemTypeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CropCreateWithoutUserInput = {
    id?: string
    cropType: string
    specificType?: string | null
    plantingDate: Date | string
    harvestDate?: Date | string | null
    notes?: string | null
    areaHectares?: number | null
    pesticide?: string | null
    createdAt?: Date | string
    nextSprayDueAt?: Date | string | null
    lastSprayAlertAt?: Date | string | null
    proteinPercent?: number | null
    moisturePercent?: number | null
    sugarPercent?: number | null
    oilPercent?: number | null
    healthStatus?: string | null
    diseaseNotes?: string | null
    qualityScore?: number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    sprays?: CropSprayCreateNestedManyWithoutCropInput
    harvests?: CropHarvestCreateNestedManyWithoutCropInput
    qualityLogs?: CropQualityLogCreateNestedManyWithoutCropInput
    metrics?: CropMetricCreateNestedManyWithoutCropInput
  }

  export type CropUncheckedCreateWithoutUserInput = {
    id?: string
    cropType: string
    specificType?: string | null
    plantingDate: Date | string
    harvestDate?: Date | string | null
    notes?: string | null
    areaHectares?: number | null
    pesticide?: string | null
    createdAt?: Date | string
    nextSprayDueAt?: Date | string | null
    lastSprayAlertAt?: Date | string | null
    proteinPercent?: number | null
    moisturePercent?: number | null
    sugarPercent?: number | null
    oilPercent?: number | null
    healthStatus?: string | null
    diseaseNotes?: string | null
    qualityScore?: number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    sprays?: CropSprayUncheckedCreateNestedManyWithoutCropInput
    harvests?: CropHarvestUncheckedCreateNestedManyWithoutCropInput
    qualityLogs?: CropQualityLogUncheckedCreateNestedManyWithoutCropInput
    metrics?: CropMetricUncheckedCreateNestedManyWithoutCropInput
  }

  export type CropCreateOrConnectWithoutUserInput = {
    where: CropWhereUniqueInput
    create: XOR<CropCreateWithoutUserInput, CropUncheckedCreateWithoutUserInput>
  }

  export type CropCreateManyUserInputEnvelope = {
    data: CropCreateManyUserInput | CropCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LivestockCreateWithoutUserInput = {
    id?: string
    animalType: string
    specificType?: string | null
    breed?: string | null
    birthDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    lastMilkAlertAt?: Date | string | null
    weightKg?: number | null
    healthStatus?: string | null
    dailyFeedKg?: number | null
    vaccineStatus?: string | null
    lastCheckupDate?: Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    milkLogs?: MilkLogCreateNestedManyWithoutLivestockInput
    eggLogs?: EggLogCreateNestedManyWithoutLivestockInput
    honeyLogs?: HoneyLogCreateNestedManyWithoutLivestockInput
    woolLogs?: WoolLogCreateNestedManyWithoutLivestockInput
    weightLogs?: WeightLogCreateNestedManyWithoutLivestockInput
    metrics?: LivestockMetricCreateNestedManyWithoutLivestockInput
  }

  export type LivestockUncheckedCreateWithoutUserInput = {
    id?: string
    animalType: string
    specificType?: string | null
    breed?: string | null
    birthDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    lastMilkAlertAt?: Date | string | null
    weightKg?: number | null
    healthStatus?: string | null
    dailyFeedKg?: number | null
    vaccineStatus?: string | null
    lastCheckupDate?: Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    milkLogs?: MilkLogUncheckedCreateNestedManyWithoutLivestockInput
    eggLogs?: EggLogUncheckedCreateNestedManyWithoutLivestockInput
    honeyLogs?: HoneyLogUncheckedCreateNestedManyWithoutLivestockInput
    woolLogs?: WoolLogUncheckedCreateNestedManyWithoutLivestockInput
    weightLogs?: WeightLogUncheckedCreateNestedManyWithoutLivestockInput
    metrics?: LivestockMetricUncheckedCreateNestedManyWithoutLivestockInput
  }

  export type LivestockCreateOrConnectWithoutUserInput = {
    where: LivestockWhereUniqueInput
    create: XOR<LivestockCreateWithoutUserInput, LivestockUncheckedCreateWithoutUserInput>
  }

  export type LivestockCreateManyUserInputEnvelope = {
    data: LivestockCreateManyUserInput | LivestockCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MarketListingCreateWithoutUserInput = {
    id?: string
    itemType: $Enums.ItemType
    itemRef: string
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type MarketListingUncheckedCreateWithoutUserInput = {
    id?: string
    itemType: $Enums.ItemType
    itemRef: string
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type MarketListingCreateOrConnectWithoutUserInput = {
    where: MarketListingWhereUniqueInput
    create: XOR<MarketListingCreateWithoutUserInput, MarketListingUncheckedCreateWithoutUserInput>
  }

  export type MarketListingCreateManyUserInputEnvelope = {
    data: MarketListingCreateManyUserInput | MarketListingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    body: string
    category?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    body: string
    category?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CropUpsertWithWhereUniqueWithoutUserInput = {
    where: CropWhereUniqueInput
    update: XOR<CropUpdateWithoutUserInput, CropUncheckedUpdateWithoutUserInput>
    create: XOR<CropCreateWithoutUserInput, CropUncheckedCreateWithoutUserInput>
  }

  export type CropUpdateWithWhereUniqueWithoutUserInput = {
    where: CropWhereUniqueInput
    data: XOR<CropUpdateWithoutUserInput, CropUncheckedUpdateWithoutUserInput>
  }

  export type CropUpdateManyWithWhereWithoutUserInput = {
    where: CropScalarWhereInput
    data: XOR<CropUpdateManyMutationInput, CropUncheckedUpdateManyWithoutUserInput>
  }

  export type CropScalarWhereInput = {
    AND?: CropScalarWhereInput | CropScalarWhereInput[]
    OR?: CropScalarWhereInput[]
    NOT?: CropScalarWhereInput | CropScalarWhereInput[]
    id?: StringFilter<"Crop"> | string
    userId?: StringFilter<"Crop"> | string
    cropType?: StringFilter<"Crop"> | string
    specificType?: StringNullableFilter<"Crop"> | string | null
    plantingDate?: DateTimeFilter<"Crop"> | Date | string
    harvestDate?: DateTimeNullableFilter<"Crop"> | Date | string | null
    notes?: StringNullableFilter<"Crop"> | string | null
    areaHectares?: FloatNullableFilter<"Crop"> | number | null
    pesticide?: StringNullableFilter<"Crop"> | string | null
    createdAt?: DateTimeFilter<"Crop"> | Date | string
    nextSprayDueAt?: DateTimeNullableFilter<"Crop"> | Date | string | null
    lastSprayAlertAt?: DateTimeNullableFilter<"Crop"> | Date | string | null
    proteinPercent?: FloatNullableFilter<"Crop"> | number | null
    moisturePercent?: FloatNullableFilter<"Crop"> | number | null
    sugarPercent?: FloatNullableFilter<"Crop"> | number | null
    oilPercent?: FloatNullableFilter<"Crop"> | number | null
    healthStatus?: StringNullableFilter<"Crop"> | string | null
    diseaseNotes?: StringNullableFilter<"Crop"> | string | null
    qualityScore?: IntNullableFilter<"Crop"> | number | null
    customMetrics?: JsonNullableFilter<"Crop">
  }

  export type LivestockUpsertWithWhereUniqueWithoutUserInput = {
    where: LivestockWhereUniqueInput
    update: XOR<LivestockUpdateWithoutUserInput, LivestockUncheckedUpdateWithoutUserInput>
    create: XOR<LivestockCreateWithoutUserInput, LivestockUncheckedCreateWithoutUserInput>
  }

  export type LivestockUpdateWithWhereUniqueWithoutUserInput = {
    where: LivestockWhereUniqueInput
    data: XOR<LivestockUpdateWithoutUserInput, LivestockUncheckedUpdateWithoutUserInput>
  }

  export type LivestockUpdateManyWithWhereWithoutUserInput = {
    where: LivestockScalarWhereInput
    data: XOR<LivestockUpdateManyMutationInput, LivestockUncheckedUpdateManyWithoutUserInput>
  }

  export type LivestockScalarWhereInput = {
    AND?: LivestockScalarWhereInput | LivestockScalarWhereInput[]
    OR?: LivestockScalarWhereInput[]
    NOT?: LivestockScalarWhereInput | LivestockScalarWhereInput[]
    id?: StringFilter<"Livestock"> | string
    userId?: StringFilter<"Livestock"> | string
    animalType?: StringFilter<"Livestock"> | string
    specificType?: StringNullableFilter<"Livestock"> | string | null
    breed?: StringNullableFilter<"Livestock"> | string | null
    birthDate?: DateTimeNullableFilter<"Livestock"> | Date | string | null
    notes?: StringNullableFilter<"Livestock"> | string | null
    createdAt?: DateTimeFilter<"Livestock"> | Date | string
    lastMilkAlertAt?: DateTimeNullableFilter<"Livestock"> | Date | string | null
    weightKg?: FloatNullableFilter<"Livestock"> | number | null
    healthStatus?: StringNullableFilter<"Livestock"> | string | null
    dailyFeedKg?: FloatNullableFilter<"Livestock"> | number | null
    vaccineStatus?: StringNullableFilter<"Livestock"> | string | null
    lastCheckupDate?: DateTimeNullableFilter<"Livestock"> | Date | string | null
    customMetrics?: JsonNullableFilter<"Livestock">
  }

  export type MarketListingUpsertWithWhereUniqueWithoutUserInput = {
    where: MarketListingWhereUniqueInput
    update: XOR<MarketListingUpdateWithoutUserInput, MarketListingUncheckedUpdateWithoutUserInput>
    create: XOR<MarketListingCreateWithoutUserInput, MarketListingUncheckedCreateWithoutUserInput>
  }

  export type MarketListingUpdateWithWhereUniqueWithoutUserInput = {
    where: MarketListingWhereUniqueInput
    data: XOR<MarketListingUpdateWithoutUserInput, MarketListingUncheckedUpdateWithoutUserInput>
  }

  export type MarketListingUpdateManyWithWhereWithoutUserInput = {
    where: MarketListingScalarWhereInput
    data: XOR<MarketListingUpdateManyMutationInput, MarketListingUncheckedUpdateManyWithoutUserInput>
  }

  export type MarketListingScalarWhereInput = {
    AND?: MarketListingScalarWhereInput | MarketListingScalarWhereInput[]
    OR?: MarketListingScalarWhereInput[]
    NOT?: MarketListingScalarWhereInput | MarketListingScalarWhereInput[]
    id?: StringFilter<"MarketListing"> | string
    userId?: StringFilter<"MarketListing"> | string
    itemType?: EnumItemTypeFilter<"MarketListing"> | $Enums.ItemType
    itemRef?: StringFilter<"MarketListing"> | string
    price?: DecimalNullableFilter<"MarketListing"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"MarketListing"> | string
    isActive?: BoolFilter<"MarketListing"> | boolean
    createdAt?: DateTimeFilter<"MarketListing"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    category?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type UserCreateWithoutCropsInput = {
    id?: string
    email: string
    password: string
    fullName?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    livestock?: LivestockCreateNestedManyWithoutUserInput
    listings?: MarketListingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCropsInput = {
    id?: string
    email: string
    password: string
    fullName?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    livestock?: LivestockUncheckedCreateNestedManyWithoutUserInput
    listings?: MarketListingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCropsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCropsInput, UserUncheckedCreateWithoutCropsInput>
  }

  export type CropSprayCreateWithoutCropInput = {
    id?: string
    sprayedAt?: Date | string
    pesticide?: string | null
    createdAt?: Date | string
  }

  export type CropSprayUncheckedCreateWithoutCropInput = {
    id?: string
    sprayedAt?: Date | string
    pesticide?: string | null
    createdAt?: Date | string
  }

  export type CropSprayCreateOrConnectWithoutCropInput = {
    where: CropSprayWhereUniqueInput
    create: XOR<CropSprayCreateWithoutCropInput, CropSprayUncheckedCreateWithoutCropInput>
  }

  export type CropSprayCreateManyCropInputEnvelope = {
    data: CropSprayCreateManyCropInput | CropSprayCreateManyCropInput[]
    skipDuplicates?: boolean
  }

  export type CropHarvestCreateWithoutCropInput = {
    id?: string
    harvestedAt?: Date | string
    amountTon: number
    yieldTonPerHa?: number | null
    createdAt?: Date | string
  }

  export type CropHarvestUncheckedCreateWithoutCropInput = {
    id?: string
    harvestedAt?: Date | string
    amountTon: number
    yieldTonPerHa?: number | null
    createdAt?: Date | string
  }

  export type CropHarvestCreateOrConnectWithoutCropInput = {
    where: CropHarvestWhereUniqueInput
    create: XOR<CropHarvestCreateWithoutCropInput, CropHarvestUncheckedCreateWithoutCropInput>
  }

  export type CropHarvestCreateManyCropInputEnvelope = {
    data: CropHarvestCreateManyCropInput | CropHarvestCreateManyCropInput[]
    skipDuplicates?: boolean
  }

  export type CropQualityLogCreateWithoutCropInput = {
    id?: string
    measuredAt?: Date | string
    proteinPercent?: number | null
    moisturePercent?: number | null
    sugarPercent?: number | null
    oilPercent?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type CropQualityLogUncheckedCreateWithoutCropInput = {
    id?: string
    measuredAt?: Date | string
    proteinPercent?: number | null
    moisturePercent?: number | null
    sugarPercent?: number | null
    oilPercent?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type CropQualityLogCreateOrConnectWithoutCropInput = {
    where: CropQualityLogWhereUniqueInput
    create: XOR<CropQualityLogCreateWithoutCropInput, CropQualityLogUncheckedCreateWithoutCropInput>
  }

  export type CropQualityLogCreateManyCropInputEnvelope = {
    data: CropQualityLogCreateManyCropInput | CropQualityLogCreateManyCropInput[]
    skipDuplicates?: boolean
  }

  export type CropMetricCreateWithoutCropInput = {
    id?: string
    key: string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CropMetricUncheckedCreateWithoutCropInput = {
    id?: string
    key: string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CropMetricCreateOrConnectWithoutCropInput = {
    where: CropMetricWhereUniqueInput
    create: XOR<CropMetricCreateWithoutCropInput, CropMetricUncheckedCreateWithoutCropInput>
  }

  export type CropMetricCreateManyCropInputEnvelope = {
    data: CropMetricCreateManyCropInput | CropMetricCreateManyCropInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCropsInput = {
    update: XOR<UserUpdateWithoutCropsInput, UserUncheckedUpdateWithoutCropsInput>
    create: XOR<UserCreateWithoutCropsInput, UserUncheckedCreateWithoutCropsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCropsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCropsInput, UserUncheckedUpdateWithoutCropsInput>
  }

  export type UserUpdateWithoutCropsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    livestock?: LivestockUpdateManyWithoutUserNestedInput
    listings?: MarketListingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCropsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    livestock?: LivestockUncheckedUpdateManyWithoutUserNestedInput
    listings?: MarketListingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CropSprayUpsertWithWhereUniqueWithoutCropInput = {
    where: CropSprayWhereUniqueInput
    update: XOR<CropSprayUpdateWithoutCropInput, CropSprayUncheckedUpdateWithoutCropInput>
    create: XOR<CropSprayCreateWithoutCropInput, CropSprayUncheckedCreateWithoutCropInput>
  }

  export type CropSprayUpdateWithWhereUniqueWithoutCropInput = {
    where: CropSprayWhereUniqueInput
    data: XOR<CropSprayUpdateWithoutCropInput, CropSprayUncheckedUpdateWithoutCropInput>
  }

  export type CropSprayUpdateManyWithWhereWithoutCropInput = {
    where: CropSprayScalarWhereInput
    data: XOR<CropSprayUpdateManyMutationInput, CropSprayUncheckedUpdateManyWithoutCropInput>
  }

  export type CropSprayScalarWhereInput = {
    AND?: CropSprayScalarWhereInput | CropSprayScalarWhereInput[]
    OR?: CropSprayScalarWhereInput[]
    NOT?: CropSprayScalarWhereInput | CropSprayScalarWhereInput[]
    id?: StringFilter<"CropSpray"> | string
    cropId?: StringFilter<"CropSpray"> | string
    sprayedAt?: DateTimeFilter<"CropSpray"> | Date | string
    pesticide?: StringNullableFilter<"CropSpray"> | string | null
    createdAt?: DateTimeFilter<"CropSpray"> | Date | string
  }

  export type CropHarvestUpsertWithWhereUniqueWithoutCropInput = {
    where: CropHarvestWhereUniqueInput
    update: XOR<CropHarvestUpdateWithoutCropInput, CropHarvestUncheckedUpdateWithoutCropInput>
    create: XOR<CropHarvestCreateWithoutCropInput, CropHarvestUncheckedCreateWithoutCropInput>
  }

  export type CropHarvestUpdateWithWhereUniqueWithoutCropInput = {
    where: CropHarvestWhereUniqueInput
    data: XOR<CropHarvestUpdateWithoutCropInput, CropHarvestUncheckedUpdateWithoutCropInput>
  }

  export type CropHarvestUpdateManyWithWhereWithoutCropInput = {
    where: CropHarvestScalarWhereInput
    data: XOR<CropHarvestUpdateManyMutationInput, CropHarvestUncheckedUpdateManyWithoutCropInput>
  }

  export type CropHarvestScalarWhereInput = {
    AND?: CropHarvestScalarWhereInput | CropHarvestScalarWhereInput[]
    OR?: CropHarvestScalarWhereInput[]
    NOT?: CropHarvestScalarWhereInput | CropHarvestScalarWhereInput[]
    id?: StringFilter<"CropHarvest"> | string
    cropId?: StringFilter<"CropHarvest"> | string
    harvestedAt?: DateTimeFilter<"CropHarvest"> | Date | string
    amountTon?: FloatFilter<"CropHarvest"> | number
    yieldTonPerHa?: FloatNullableFilter<"CropHarvest"> | number | null
    createdAt?: DateTimeFilter<"CropHarvest"> | Date | string
  }

  export type CropQualityLogUpsertWithWhereUniqueWithoutCropInput = {
    where: CropQualityLogWhereUniqueInput
    update: XOR<CropQualityLogUpdateWithoutCropInput, CropQualityLogUncheckedUpdateWithoutCropInput>
    create: XOR<CropQualityLogCreateWithoutCropInput, CropQualityLogUncheckedCreateWithoutCropInput>
  }

  export type CropQualityLogUpdateWithWhereUniqueWithoutCropInput = {
    where: CropQualityLogWhereUniqueInput
    data: XOR<CropQualityLogUpdateWithoutCropInput, CropQualityLogUncheckedUpdateWithoutCropInput>
  }

  export type CropQualityLogUpdateManyWithWhereWithoutCropInput = {
    where: CropQualityLogScalarWhereInput
    data: XOR<CropQualityLogUpdateManyMutationInput, CropQualityLogUncheckedUpdateManyWithoutCropInput>
  }

  export type CropQualityLogScalarWhereInput = {
    AND?: CropQualityLogScalarWhereInput | CropQualityLogScalarWhereInput[]
    OR?: CropQualityLogScalarWhereInput[]
    NOT?: CropQualityLogScalarWhereInput | CropQualityLogScalarWhereInput[]
    id?: StringFilter<"CropQualityLog"> | string
    cropId?: StringFilter<"CropQualityLog"> | string
    measuredAt?: DateTimeFilter<"CropQualityLog"> | Date | string
    proteinPercent?: FloatNullableFilter<"CropQualityLog"> | number | null
    moisturePercent?: FloatNullableFilter<"CropQualityLog"> | number | null
    sugarPercent?: FloatNullableFilter<"CropQualityLog"> | number | null
    oilPercent?: FloatNullableFilter<"CropQualityLog"> | number | null
    notes?: StringNullableFilter<"CropQualityLog"> | string | null
    createdAt?: DateTimeFilter<"CropQualityLog"> | Date | string
  }

  export type CropMetricUpsertWithWhereUniqueWithoutCropInput = {
    where: CropMetricWhereUniqueInput
    update: XOR<CropMetricUpdateWithoutCropInput, CropMetricUncheckedUpdateWithoutCropInput>
    create: XOR<CropMetricCreateWithoutCropInput, CropMetricUncheckedCreateWithoutCropInput>
  }

  export type CropMetricUpdateWithWhereUniqueWithoutCropInput = {
    where: CropMetricWhereUniqueInput
    data: XOR<CropMetricUpdateWithoutCropInput, CropMetricUncheckedUpdateWithoutCropInput>
  }

  export type CropMetricUpdateManyWithWhereWithoutCropInput = {
    where: CropMetricScalarWhereInput
    data: XOR<CropMetricUpdateManyMutationInput, CropMetricUncheckedUpdateManyWithoutCropInput>
  }

  export type CropMetricScalarWhereInput = {
    AND?: CropMetricScalarWhereInput | CropMetricScalarWhereInput[]
    OR?: CropMetricScalarWhereInput[]
    NOT?: CropMetricScalarWhereInput | CropMetricScalarWhereInput[]
    id?: StringFilter<"CropMetric"> | string
    cropId?: StringFilter<"CropMetric"> | string
    key?: StringFilter<"CropMetric"> | string
    value?: JsonNullableFilter<"CropMetric">
    createdAt?: DateTimeFilter<"CropMetric"> | Date | string
    updatedAt?: DateTimeFilter<"CropMetric"> | Date | string
  }

  export type UserCreateWithoutLivestockInput = {
    id?: string
    email: string
    password: string
    fullName?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    crops?: CropCreateNestedManyWithoutUserInput
    listings?: MarketListingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLivestockInput = {
    id?: string
    email: string
    password: string
    fullName?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    crops?: CropUncheckedCreateNestedManyWithoutUserInput
    listings?: MarketListingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLivestockInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLivestockInput, UserUncheckedCreateWithoutLivestockInput>
  }

  export type MilkLogCreateWithoutLivestockInput = {
    id?: string
    measuredAt?: Date | string
    quantityL: number
    fatPercent?: number | null
    createdAt?: Date | string
  }

  export type MilkLogUncheckedCreateWithoutLivestockInput = {
    id?: string
    measuredAt?: Date | string
    quantityL: number
    fatPercent?: number | null
    createdAt?: Date | string
  }

  export type MilkLogCreateOrConnectWithoutLivestockInput = {
    where: MilkLogWhereUniqueInput
    create: XOR<MilkLogCreateWithoutLivestockInput, MilkLogUncheckedCreateWithoutLivestockInput>
  }

  export type MilkLogCreateManyLivestockInputEnvelope = {
    data: MilkLogCreateManyLivestockInput | MilkLogCreateManyLivestockInput[]
    skipDuplicates?: boolean
  }

  export type EggLogCreateWithoutLivestockInput = {
    id?: string
    measuredAt?: Date | string
    eggCount: number
    avgWeightGram?: number | null
    createdAt?: Date | string
  }

  export type EggLogUncheckedCreateWithoutLivestockInput = {
    id?: string
    measuredAt?: Date | string
    eggCount: number
    avgWeightGram?: number | null
    createdAt?: Date | string
  }

  export type EggLogCreateOrConnectWithoutLivestockInput = {
    where: EggLogWhereUniqueInput
    create: XOR<EggLogCreateWithoutLivestockInput, EggLogUncheckedCreateWithoutLivestockInput>
  }

  export type EggLogCreateManyLivestockInputEnvelope = {
    data: EggLogCreateManyLivestockInput | EggLogCreateManyLivestockInput[]
    skipDuplicates?: boolean
  }

  export type HoneyLogCreateWithoutLivestockInput = {
    id?: string
    measuredAt?: Date | string
    amountKg: number
    qualityGrade?: string | null
    createdAt?: Date | string
  }

  export type HoneyLogUncheckedCreateWithoutLivestockInput = {
    id?: string
    measuredAt?: Date | string
    amountKg: number
    qualityGrade?: string | null
    createdAt?: Date | string
  }

  export type HoneyLogCreateOrConnectWithoutLivestockInput = {
    where: HoneyLogWhereUniqueInput
    create: XOR<HoneyLogCreateWithoutLivestockInput, HoneyLogUncheckedCreateWithoutLivestockInput>
  }

  export type HoneyLogCreateManyLivestockInputEnvelope = {
    data: HoneyLogCreateManyLivestockInput | HoneyLogCreateManyLivestockInput[]
    skipDuplicates?: boolean
  }

  export type WoolLogCreateWithoutLivestockInput = {
    id?: string
    shearedAt?: Date | string
    amountKg: number
    qualityGrade?: string | null
    createdAt?: Date | string
  }

  export type WoolLogUncheckedCreateWithoutLivestockInput = {
    id?: string
    shearedAt?: Date | string
    amountKg: number
    qualityGrade?: string | null
    createdAt?: Date | string
  }

  export type WoolLogCreateOrConnectWithoutLivestockInput = {
    where: WoolLogWhereUniqueInput
    create: XOR<WoolLogCreateWithoutLivestockInput, WoolLogUncheckedCreateWithoutLivestockInput>
  }

  export type WoolLogCreateManyLivestockInputEnvelope = {
    data: WoolLogCreateManyLivestockInput | WoolLogCreateManyLivestockInput[]
    skipDuplicates?: boolean
  }

  export type WeightLogCreateWithoutLivestockInput = {
    id?: string
    measuredAt?: Date | string
    weightKg: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type WeightLogUncheckedCreateWithoutLivestockInput = {
    id?: string
    measuredAt?: Date | string
    weightKg: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type WeightLogCreateOrConnectWithoutLivestockInput = {
    where: WeightLogWhereUniqueInput
    create: XOR<WeightLogCreateWithoutLivestockInput, WeightLogUncheckedCreateWithoutLivestockInput>
  }

  export type WeightLogCreateManyLivestockInputEnvelope = {
    data: WeightLogCreateManyLivestockInput | WeightLogCreateManyLivestockInput[]
    skipDuplicates?: boolean
  }

  export type LivestockMetricCreateWithoutLivestockInput = {
    id?: string
    key: string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LivestockMetricUncheckedCreateWithoutLivestockInput = {
    id?: string
    key: string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LivestockMetricCreateOrConnectWithoutLivestockInput = {
    where: LivestockMetricWhereUniqueInput
    create: XOR<LivestockMetricCreateWithoutLivestockInput, LivestockMetricUncheckedCreateWithoutLivestockInput>
  }

  export type LivestockMetricCreateManyLivestockInputEnvelope = {
    data: LivestockMetricCreateManyLivestockInput | LivestockMetricCreateManyLivestockInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLivestockInput = {
    update: XOR<UserUpdateWithoutLivestockInput, UserUncheckedUpdateWithoutLivestockInput>
    create: XOR<UserCreateWithoutLivestockInput, UserUncheckedCreateWithoutLivestockInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLivestockInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLivestockInput, UserUncheckedUpdateWithoutLivestockInput>
  }

  export type UserUpdateWithoutLivestockInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crops?: CropUpdateManyWithoutUserNestedInput
    listings?: MarketListingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLivestockInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crops?: CropUncheckedUpdateManyWithoutUserNestedInput
    listings?: MarketListingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MilkLogUpsertWithWhereUniqueWithoutLivestockInput = {
    where: MilkLogWhereUniqueInput
    update: XOR<MilkLogUpdateWithoutLivestockInput, MilkLogUncheckedUpdateWithoutLivestockInput>
    create: XOR<MilkLogCreateWithoutLivestockInput, MilkLogUncheckedCreateWithoutLivestockInput>
  }

  export type MilkLogUpdateWithWhereUniqueWithoutLivestockInput = {
    where: MilkLogWhereUniqueInput
    data: XOR<MilkLogUpdateWithoutLivestockInput, MilkLogUncheckedUpdateWithoutLivestockInput>
  }

  export type MilkLogUpdateManyWithWhereWithoutLivestockInput = {
    where: MilkLogScalarWhereInput
    data: XOR<MilkLogUpdateManyMutationInput, MilkLogUncheckedUpdateManyWithoutLivestockInput>
  }

  export type MilkLogScalarWhereInput = {
    AND?: MilkLogScalarWhereInput | MilkLogScalarWhereInput[]
    OR?: MilkLogScalarWhereInput[]
    NOT?: MilkLogScalarWhereInput | MilkLogScalarWhereInput[]
    id?: StringFilter<"MilkLog"> | string
    livestockId?: StringFilter<"MilkLog"> | string
    measuredAt?: DateTimeFilter<"MilkLog"> | Date | string
    quantityL?: FloatFilter<"MilkLog"> | number
    fatPercent?: FloatNullableFilter<"MilkLog"> | number | null
    createdAt?: DateTimeFilter<"MilkLog"> | Date | string
  }

  export type EggLogUpsertWithWhereUniqueWithoutLivestockInput = {
    where: EggLogWhereUniqueInput
    update: XOR<EggLogUpdateWithoutLivestockInput, EggLogUncheckedUpdateWithoutLivestockInput>
    create: XOR<EggLogCreateWithoutLivestockInput, EggLogUncheckedCreateWithoutLivestockInput>
  }

  export type EggLogUpdateWithWhereUniqueWithoutLivestockInput = {
    where: EggLogWhereUniqueInput
    data: XOR<EggLogUpdateWithoutLivestockInput, EggLogUncheckedUpdateWithoutLivestockInput>
  }

  export type EggLogUpdateManyWithWhereWithoutLivestockInput = {
    where: EggLogScalarWhereInput
    data: XOR<EggLogUpdateManyMutationInput, EggLogUncheckedUpdateManyWithoutLivestockInput>
  }

  export type EggLogScalarWhereInput = {
    AND?: EggLogScalarWhereInput | EggLogScalarWhereInput[]
    OR?: EggLogScalarWhereInput[]
    NOT?: EggLogScalarWhereInput | EggLogScalarWhereInput[]
    id?: StringFilter<"EggLog"> | string
    livestockId?: StringFilter<"EggLog"> | string
    measuredAt?: DateTimeFilter<"EggLog"> | Date | string
    eggCount?: IntFilter<"EggLog"> | number
    avgWeightGram?: FloatNullableFilter<"EggLog"> | number | null
    createdAt?: DateTimeFilter<"EggLog"> | Date | string
  }

  export type HoneyLogUpsertWithWhereUniqueWithoutLivestockInput = {
    where: HoneyLogWhereUniqueInput
    update: XOR<HoneyLogUpdateWithoutLivestockInput, HoneyLogUncheckedUpdateWithoutLivestockInput>
    create: XOR<HoneyLogCreateWithoutLivestockInput, HoneyLogUncheckedCreateWithoutLivestockInput>
  }

  export type HoneyLogUpdateWithWhereUniqueWithoutLivestockInput = {
    where: HoneyLogWhereUniqueInput
    data: XOR<HoneyLogUpdateWithoutLivestockInput, HoneyLogUncheckedUpdateWithoutLivestockInput>
  }

  export type HoneyLogUpdateManyWithWhereWithoutLivestockInput = {
    where: HoneyLogScalarWhereInput
    data: XOR<HoneyLogUpdateManyMutationInput, HoneyLogUncheckedUpdateManyWithoutLivestockInput>
  }

  export type HoneyLogScalarWhereInput = {
    AND?: HoneyLogScalarWhereInput | HoneyLogScalarWhereInput[]
    OR?: HoneyLogScalarWhereInput[]
    NOT?: HoneyLogScalarWhereInput | HoneyLogScalarWhereInput[]
    id?: StringFilter<"HoneyLog"> | string
    livestockId?: StringFilter<"HoneyLog"> | string
    measuredAt?: DateTimeFilter<"HoneyLog"> | Date | string
    amountKg?: FloatFilter<"HoneyLog"> | number
    qualityGrade?: StringNullableFilter<"HoneyLog"> | string | null
    createdAt?: DateTimeFilter<"HoneyLog"> | Date | string
  }

  export type WoolLogUpsertWithWhereUniqueWithoutLivestockInput = {
    where: WoolLogWhereUniqueInput
    update: XOR<WoolLogUpdateWithoutLivestockInput, WoolLogUncheckedUpdateWithoutLivestockInput>
    create: XOR<WoolLogCreateWithoutLivestockInput, WoolLogUncheckedCreateWithoutLivestockInput>
  }

  export type WoolLogUpdateWithWhereUniqueWithoutLivestockInput = {
    where: WoolLogWhereUniqueInput
    data: XOR<WoolLogUpdateWithoutLivestockInput, WoolLogUncheckedUpdateWithoutLivestockInput>
  }

  export type WoolLogUpdateManyWithWhereWithoutLivestockInput = {
    where: WoolLogScalarWhereInput
    data: XOR<WoolLogUpdateManyMutationInput, WoolLogUncheckedUpdateManyWithoutLivestockInput>
  }

  export type WoolLogScalarWhereInput = {
    AND?: WoolLogScalarWhereInput | WoolLogScalarWhereInput[]
    OR?: WoolLogScalarWhereInput[]
    NOT?: WoolLogScalarWhereInput | WoolLogScalarWhereInput[]
    id?: StringFilter<"WoolLog"> | string
    livestockId?: StringFilter<"WoolLog"> | string
    shearedAt?: DateTimeFilter<"WoolLog"> | Date | string
    amountKg?: FloatFilter<"WoolLog"> | number
    qualityGrade?: StringNullableFilter<"WoolLog"> | string | null
    createdAt?: DateTimeFilter<"WoolLog"> | Date | string
  }

  export type WeightLogUpsertWithWhereUniqueWithoutLivestockInput = {
    where: WeightLogWhereUniqueInput
    update: XOR<WeightLogUpdateWithoutLivestockInput, WeightLogUncheckedUpdateWithoutLivestockInput>
    create: XOR<WeightLogCreateWithoutLivestockInput, WeightLogUncheckedCreateWithoutLivestockInput>
  }

  export type WeightLogUpdateWithWhereUniqueWithoutLivestockInput = {
    where: WeightLogWhereUniqueInput
    data: XOR<WeightLogUpdateWithoutLivestockInput, WeightLogUncheckedUpdateWithoutLivestockInput>
  }

  export type WeightLogUpdateManyWithWhereWithoutLivestockInput = {
    where: WeightLogScalarWhereInput
    data: XOR<WeightLogUpdateManyMutationInput, WeightLogUncheckedUpdateManyWithoutLivestockInput>
  }

  export type WeightLogScalarWhereInput = {
    AND?: WeightLogScalarWhereInput | WeightLogScalarWhereInput[]
    OR?: WeightLogScalarWhereInput[]
    NOT?: WeightLogScalarWhereInput | WeightLogScalarWhereInput[]
    id?: StringFilter<"WeightLog"> | string
    livestockId?: StringFilter<"WeightLog"> | string
    measuredAt?: DateTimeFilter<"WeightLog"> | Date | string
    weightKg?: FloatFilter<"WeightLog"> | number
    notes?: StringNullableFilter<"WeightLog"> | string | null
    createdAt?: DateTimeFilter<"WeightLog"> | Date | string
  }

  export type LivestockMetricUpsertWithWhereUniqueWithoutLivestockInput = {
    where: LivestockMetricWhereUniqueInput
    update: XOR<LivestockMetricUpdateWithoutLivestockInput, LivestockMetricUncheckedUpdateWithoutLivestockInput>
    create: XOR<LivestockMetricCreateWithoutLivestockInput, LivestockMetricUncheckedCreateWithoutLivestockInput>
  }

  export type LivestockMetricUpdateWithWhereUniqueWithoutLivestockInput = {
    where: LivestockMetricWhereUniqueInput
    data: XOR<LivestockMetricUpdateWithoutLivestockInput, LivestockMetricUncheckedUpdateWithoutLivestockInput>
  }

  export type LivestockMetricUpdateManyWithWhereWithoutLivestockInput = {
    where: LivestockMetricScalarWhereInput
    data: XOR<LivestockMetricUpdateManyMutationInput, LivestockMetricUncheckedUpdateManyWithoutLivestockInput>
  }

  export type LivestockMetricScalarWhereInput = {
    AND?: LivestockMetricScalarWhereInput | LivestockMetricScalarWhereInput[]
    OR?: LivestockMetricScalarWhereInput[]
    NOT?: LivestockMetricScalarWhereInput | LivestockMetricScalarWhereInput[]
    id?: StringFilter<"LivestockMetric"> | string
    livestockId?: StringFilter<"LivestockMetric"> | string
    key?: StringFilter<"LivestockMetric"> | string
    value?: JsonNullableFilter<"LivestockMetric">
    createdAt?: DateTimeFilter<"LivestockMetric"> | Date | string
    updatedAt?: DateTimeFilter<"LivestockMetric"> | Date | string
  }

  export type CropCreateWithoutSpraysInput = {
    id?: string
    cropType: string
    specificType?: string | null
    plantingDate: Date | string
    harvestDate?: Date | string | null
    notes?: string | null
    areaHectares?: number | null
    pesticide?: string | null
    createdAt?: Date | string
    nextSprayDueAt?: Date | string | null
    lastSprayAlertAt?: Date | string | null
    proteinPercent?: number | null
    moisturePercent?: number | null
    sugarPercent?: number | null
    oilPercent?: number | null
    healthStatus?: string | null
    diseaseNotes?: string | null
    qualityScore?: number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutCropsInput
    harvests?: CropHarvestCreateNestedManyWithoutCropInput
    qualityLogs?: CropQualityLogCreateNestedManyWithoutCropInput
    metrics?: CropMetricCreateNestedManyWithoutCropInput
  }

  export type CropUncheckedCreateWithoutSpraysInput = {
    id?: string
    userId: string
    cropType: string
    specificType?: string | null
    plantingDate: Date | string
    harvestDate?: Date | string | null
    notes?: string | null
    areaHectares?: number | null
    pesticide?: string | null
    createdAt?: Date | string
    nextSprayDueAt?: Date | string | null
    lastSprayAlertAt?: Date | string | null
    proteinPercent?: number | null
    moisturePercent?: number | null
    sugarPercent?: number | null
    oilPercent?: number | null
    healthStatus?: string | null
    diseaseNotes?: string | null
    qualityScore?: number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    harvests?: CropHarvestUncheckedCreateNestedManyWithoutCropInput
    qualityLogs?: CropQualityLogUncheckedCreateNestedManyWithoutCropInput
    metrics?: CropMetricUncheckedCreateNestedManyWithoutCropInput
  }

  export type CropCreateOrConnectWithoutSpraysInput = {
    where: CropWhereUniqueInput
    create: XOR<CropCreateWithoutSpraysInput, CropUncheckedCreateWithoutSpraysInput>
  }

  export type CropUpsertWithoutSpraysInput = {
    update: XOR<CropUpdateWithoutSpraysInput, CropUncheckedUpdateWithoutSpraysInput>
    create: XOR<CropCreateWithoutSpraysInput, CropUncheckedCreateWithoutSpraysInput>
    where?: CropWhereInput
  }

  export type CropUpdateToOneWithWhereWithoutSpraysInput = {
    where?: CropWhereInput
    data: XOR<CropUpdateWithoutSpraysInput, CropUncheckedUpdateWithoutSpraysInput>
  }

  export type CropUpdateWithoutSpraysInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    areaHectares?: NullableFloatFieldUpdateOperationsInput | number | null
    pesticide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextSprayDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSprayAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proteinPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    moisturePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    sugarPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    oilPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diseaseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutCropsNestedInput
    harvests?: CropHarvestUpdateManyWithoutCropNestedInput
    qualityLogs?: CropQualityLogUpdateManyWithoutCropNestedInput
    metrics?: CropMetricUpdateManyWithoutCropNestedInput
  }

  export type CropUncheckedUpdateWithoutSpraysInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cropType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    areaHectares?: NullableFloatFieldUpdateOperationsInput | number | null
    pesticide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextSprayDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSprayAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proteinPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    moisturePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    sugarPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    oilPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diseaseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    harvests?: CropHarvestUncheckedUpdateManyWithoutCropNestedInput
    qualityLogs?: CropQualityLogUncheckedUpdateManyWithoutCropNestedInput
    metrics?: CropMetricUncheckedUpdateManyWithoutCropNestedInput
  }

  export type CropCreateWithoutHarvestsInput = {
    id?: string
    cropType: string
    specificType?: string | null
    plantingDate: Date | string
    harvestDate?: Date | string | null
    notes?: string | null
    areaHectares?: number | null
    pesticide?: string | null
    createdAt?: Date | string
    nextSprayDueAt?: Date | string | null
    lastSprayAlertAt?: Date | string | null
    proteinPercent?: number | null
    moisturePercent?: number | null
    sugarPercent?: number | null
    oilPercent?: number | null
    healthStatus?: string | null
    diseaseNotes?: string | null
    qualityScore?: number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutCropsInput
    sprays?: CropSprayCreateNestedManyWithoutCropInput
    qualityLogs?: CropQualityLogCreateNestedManyWithoutCropInput
    metrics?: CropMetricCreateNestedManyWithoutCropInput
  }

  export type CropUncheckedCreateWithoutHarvestsInput = {
    id?: string
    userId: string
    cropType: string
    specificType?: string | null
    plantingDate: Date | string
    harvestDate?: Date | string | null
    notes?: string | null
    areaHectares?: number | null
    pesticide?: string | null
    createdAt?: Date | string
    nextSprayDueAt?: Date | string | null
    lastSprayAlertAt?: Date | string | null
    proteinPercent?: number | null
    moisturePercent?: number | null
    sugarPercent?: number | null
    oilPercent?: number | null
    healthStatus?: string | null
    diseaseNotes?: string | null
    qualityScore?: number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    sprays?: CropSprayUncheckedCreateNestedManyWithoutCropInput
    qualityLogs?: CropQualityLogUncheckedCreateNestedManyWithoutCropInput
    metrics?: CropMetricUncheckedCreateNestedManyWithoutCropInput
  }

  export type CropCreateOrConnectWithoutHarvestsInput = {
    where: CropWhereUniqueInput
    create: XOR<CropCreateWithoutHarvestsInput, CropUncheckedCreateWithoutHarvestsInput>
  }

  export type CropUpsertWithoutHarvestsInput = {
    update: XOR<CropUpdateWithoutHarvestsInput, CropUncheckedUpdateWithoutHarvestsInput>
    create: XOR<CropCreateWithoutHarvestsInput, CropUncheckedCreateWithoutHarvestsInput>
    where?: CropWhereInput
  }

  export type CropUpdateToOneWithWhereWithoutHarvestsInput = {
    where?: CropWhereInput
    data: XOR<CropUpdateWithoutHarvestsInput, CropUncheckedUpdateWithoutHarvestsInput>
  }

  export type CropUpdateWithoutHarvestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    areaHectares?: NullableFloatFieldUpdateOperationsInput | number | null
    pesticide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextSprayDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSprayAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proteinPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    moisturePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    sugarPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    oilPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diseaseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutCropsNestedInput
    sprays?: CropSprayUpdateManyWithoutCropNestedInput
    qualityLogs?: CropQualityLogUpdateManyWithoutCropNestedInput
    metrics?: CropMetricUpdateManyWithoutCropNestedInput
  }

  export type CropUncheckedUpdateWithoutHarvestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cropType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    areaHectares?: NullableFloatFieldUpdateOperationsInput | number | null
    pesticide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextSprayDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSprayAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proteinPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    moisturePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    sugarPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    oilPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diseaseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    sprays?: CropSprayUncheckedUpdateManyWithoutCropNestedInput
    qualityLogs?: CropQualityLogUncheckedUpdateManyWithoutCropNestedInput
    metrics?: CropMetricUncheckedUpdateManyWithoutCropNestedInput
  }

  export type LivestockCreateWithoutMilkLogsInput = {
    id?: string
    animalType: string
    specificType?: string | null
    breed?: string | null
    birthDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    lastMilkAlertAt?: Date | string | null
    weightKg?: number | null
    healthStatus?: string | null
    dailyFeedKg?: number | null
    vaccineStatus?: string | null
    lastCheckupDate?: Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutLivestockInput
    eggLogs?: EggLogCreateNestedManyWithoutLivestockInput
    honeyLogs?: HoneyLogCreateNestedManyWithoutLivestockInput
    woolLogs?: WoolLogCreateNestedManyWithoutLivestockInput
    weightLogs?: WeightLogCreateNestedManyWithoutLivestockInput
    metrics?: LivestockMetricCreateNestedManyWithoutLivestockInput
  }

  export type LivestockUncheckedCreateWithoutMilkLogsInput = {
    id?: string
    userId: string
    animalType: string
    specificType?: string | null
    breed?: string | null
    birthDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    lastMilkAlertAt?: Date | string | null
    weightKg?: number | null
    healthStatus?: string | null
    dailyFeedKg?: number | null
    vaccineStatus?: string | null
    lastCheckupDate?: Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    eggLogs?: EggLogUncheckedCreateNestedManyWithoutLivestockInput
    honeyLogs?: HoneyLogUncheckedCreateNestedManyWithoutLivestockInput
    woolLogs?: WoolLogUncheckedCreateNestedManyWithoutLivestockInput
    weightLogs?: WeightLogUncheckedCreateNestedManyWithoutLivestockInput
    metrics?: LivestockMetricUncheckedCreateNestedManyWithoutLivestockInput
  }

  export type LivestockCreateOrConnectWithoutMilkLogsInput = {
    where: LivestockWhereUniqueInput
    create: XOR<LivestockCreateWithoutMilkLogsInput, LivestockUncheckedCreateWithoutMilkLogsInput>
  }

  export type LivestockUpsertWithoutMilkLogsInput = {
    update: XOR<LivestockUpdateWithoutMilkLogsInput, LivestockUncheckedUpdateWithoutMilkLogsInput>
    create: XOR<LivestockCreateWithoutMilkLogsInput, LivestockUncheckedCreateWithoutMilkLogsInput>
    where?: LivestockWhereInput
  }

  export type LivestockUpdateToOneWithWhereWithoutMilkLogsInput = {
    where?: LivestockWhereInput
    data: XOR<LivestockUpdateWithoutMilkLogsInput, LivestockUncheckedUpdateWithoutMilkLogsInput>
  }

  export type LivestockUpdateWithoutMilkLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    animalType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMilkAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dailyFeedKg?: NullableFloatFieldUpdateOperationsInput | number | null
    vaccineStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lastCheckupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutLivestockNestedInput
    eggLogs?: EggLogUpdateManyWithoutLivestockNestedInput
    honeyLogs?: HoneyLogUpdateManyWithoutLivestockNestedInput
    woolLogs?: WoolLogUpdateManyWithoutLivestockNestedInput
    weightLogs?: WeightLogUpdateManyWithoutLivestockNestedInput
    metrics?: LivestockMetricUpdateManyWithoutLivestockNestedInput
  }

  export type LivestockUncheckedUpdateWithoutMilkLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    animalType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMilkAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dailyFeedKg?: NullableFloatFieldUpdateOperationsInput | number | null
    vaccineStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lastCheckupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    eggLogs?: EggLogUncheckedUpdateManyWithoutLivestockNestedInput
    honeyLogs?: HoneyLogUncheckedUpdateManyWithoutLivestockNestedInput
    woolLogs?: WoolLogUncheckedUpdateManyWithoutLivestockNestedInput
    weightLogs?: WeightLogUncheckedUpdateManyWithoutLivestockNestedInput
    metrics?: LivestockMetricUncheckedUpdateManyWithoutLivestockNestedInput
  }

  export type LivestockCreateWithoutEggLogsInput = {
    id?: string
    animalType: string
    specificType?: string | null
    breed?: string | null
    birthDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    lastMilkAlertAt?: Date | string | null
    weightKg?: number | null
    healthStatus?: string | null
    dailyFeedKg?: number | null
    vaccineStatus?: string | null
    lastCheckupDate?: Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutLivestockInput
    milkLogs?: MilkLogCreateNestedManyWithoutLivestockInput
    honeyLogs?: HoneyLogCreateNestedManyWithoutLivestockInput
    woolLogs?: WoolLogCreateNestedManyWithoutLivestockInput
    weightLogs?: WeightLogCreateNestedManyWithoutLivestockInput
    metrics?: LivestockMetricCreateNestedManyWithoutLivestockInput
  }

  export type LivestockUncheckedCreateWithoutEggLogsInput = {
    id?: string
    userId: string
    animalType: string
    specificType?: string | null
    breed?: string | null
    birthDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    lastMilkAlertAt?: Date | string | null
    weightKg?: number | null
    healthStatus?: string | null
    dailyFeedKg?: number | null
    vaccineStatus?: string | null
    lastCheckupDate?: Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    milkLogs?: MilkLogUncheckedCreateNestedManyWithoutLivestockInput
    honeyLogs?: HoneyLogUncheckedCreateNestedManyWithoutLivestockInput
    woolLogs?: WoolLogUncheckedCreateNestedManyWithoutLivestockInput
    weightLogs?: WeightLogUncheckedCreateNestedManyWithoutLivestockInput
    metrics?: LivestockMetricUncheckedCreateNestedManyWithoutLivestockInput
  }

  export type LivestockCreateOrConnectWithoutEggLogsInput = {
    where: LivestockWhereUniqueInput
    create: XOR<LivestockCreateWithoutEggLogsInput, LivestockUncheckedCreateWithoutEggLogsInput>
  }

  export type LivestockUpsertWithoutEggLogsInput = {
    update: XOR<LivestockUpdateWithoutEggLogsInput, LivestockUncheckedUpdateWithoutEggLogsInput>
    create: XOR<LivestockCreateWithoutEggLogsInput, LivestockUncheckedCreateWithoutEggLogsInput>
    where?: LivestockWhereInput
  }

  export type LivestockUpdateToOneWithWhereWithoutEggLogsInput = {
    where?: LivestockWhereInput
    data: XOR<LivestockUpdateWithoutEggLogsInput, LivestockUncheckedUpdateWithoutEggLogsInput>
  }

  export type LivestockUpdateWithoutEggLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    animalType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMilkAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dailyFeedKg?: NullableFloatFieldUpdateOperationsInput | number | null
    vaccineStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lastCheckupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutLivestockNestedInput
    milkLogs?: MilkLogUpdateManyWithoutLivestockNestedInput
    honeyLogs?: HoneyLogUpdateManyWithoutLivestockNestedInput
    woolLogs?: WoolLogUpdateManyWithoutLivestockNestedInput
    weightLogs?: WeightLogUpdateManyWithoutLivestockNestedInput
    metrics?: LivestockMetricUpdateManyWithoutLivestockNestedInput
  }

  export type LivestockUncheckedUpdateWithoutEggLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    animalType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMilkAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dailyFeedKg?: NullableFloatFieldUpdateOperationsInput | number | null
    vaccineStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lastCheckupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    milkLogs?: MilkLogUncheckedUpdateManyWithoutLivestockNestedInput
    honeyLogs?: HoneyLogUncheckedUpdateManyWithoutLivestockNestedInput
    woolLogs?: WoolLogUncheckedUpdateManyWithoutLivestockNestedInput
    weightLogs?: WeightLogUncheckedUpdateManyWithoutLivestockNestedInput
    metrics?: LivestockMetricUncheckedUpdateManyWithoutLivestockNestedInput
  }

  export type LivestockCreateWithoutHoneyLogsInput = {
    id?: string
    animalType: string
    specificType?: string | null
    breed?: string | null
    birthDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    lastMilkAlertAt?: Date | string | null
    weightKg?: number | null
    healthStatus?: string | null
    dailyFeedKg?: number | null
    vaccineStatus?: string | null
    lastCheckupDate?: Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutLivestockInput
    milkLogs?: MilkLogCreateNestedManyWithoutLivestockInput
    eggLogs?: EggLogCreateNestedManyWithoutLivestockInput
    woolLogs?: WoolLogCreateNestedManyWithoutLivestockInput
    weightLogs?: WeightLogCreateNestedManyWithoutLivestockInput
    metrics?: LivestockMetricCreateNestedManyWithoutLivestockInput
  }

  export type LivestockUncheckedCreateWithoutHoneyLogsInput = {
    id?: string
    userId: string
    animalType: string
    specificType?: string | null
    breed?: string | null
    birthDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    lastMilkAlertAt?: Date | string | null
    weightKg?: number | null
    healthStatus?: string | null
    dailyFeedKg?: number | null
    vaccineStatus?: string | null
    lastCheckupDate?: Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    milkLogs?: MilkLogUncheckedCreateNestedManyWithoutLivestockInput
    eggLogs?: EggLogUncheckedCreateNestedManyWithoutLivestockInput
    woolLogs?: WoolLogUncheckedCreateNestedManyWithoutLivestockInput
    weightLogs?: WeightLogUncheckedCreateNestedManyWithoutLivestockInput
    metrics?: LivestockMetricUncheckedCreateNestedManyWithoutLivestockInput
  }

  export type LivestockCreateOrConnectWithoutHoneyLogsInput = {
    where: LivestockWhereUniqueInput
    create: XOR<LivestockCreateWithoutHoneyLogsInput, LivestockUncheckedCreateWithoutHoneyLogsInput>
  }

  export type LivestockUpsertWithoutHoneyLogsInput = {
    update: XOR<LivestockUpdateWithoutHoneyLogsInput, LivestockUncheckedUpdateWithoutHoneyLogsInput>
    create: XOR<LivestockCreateWithoutHoneyLogsInput, LivestockUncheckedCreateWithoutHoneyLogsInput>
    where?: LivestockWhereInput
  }

  export type LivestockUpdateToOneWithWhereWithoutHoneyLogsInput = {
    where?: LivestockWhereInput
    data: XOR<LivestockUpdateWithoutHoneyLogsInput, LivestockUncheckedUpdateWithoutHoneyLogsInput>
  }

  export type LivestockUpdateWithoutHoneyLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    animalType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMilkAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dailyFeedKg?: NullableFloatFieldUpdateOperationsInput | number | null
    vaccineStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lastCheckupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutLivestockNestedInput
    milkLogs?: MilkLogUpdateManyWithoutLivestockNestedInput
    eggLogs?: EggLogUpdateManyWithoutLivestockNestedInput
    woolLogs?: WoolLogUpdateManyWithoutLivestockNestedInput
    weightLogs?: WeightLogUpdateManyWithoutLivestockNestedInput
    metrics?: LivestockMetricUpdateManyWithoutLivestockNestedInput
  }

  export type LivestockUncheckedUpdateWithoutHoneyLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    animalType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMilkAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dailyFeedKg?: NullableFloatFieldUpdateOperationsInput | number | null
    vaccineStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lastCheckupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    milkLogs?: MilkLogUncheckedUpdateManyWithoutLivestockNestedInput
    eggLogs?: EggLogUncheckedUpdateManyWithoutLivestockNestedInput
    woolLogs?: WoolLogUncheckedUpdateManyWithoutLivestockNestedInput
    weightLogs?: WeightLogUncheckedUpdateManyWithoutLivestockNestedInput
    metrics?: LivestockMetricUncheckedUpdateManyWithoutLivestockNestedInput
  }

  export type LivestockCreateWithoutWoolLogsInput = {
    id?: string
    animalType: string
    specificType?: string | null
    breed?: string | null
    birthDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    lastMilkAlertAt?: Date | string | null
    weightKg?: number | null
    healthStatus?: string | null
    dailyFeedKg?: number | null
    vaccineStatus?: string | null
    lastCheckupDate?: Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutLivestockInput
    milkLogs?: MilkLogCreateNestedManyWithoutLivestockInput
    eggLogs?: EggLogCreateNestedManyWithoutLivestockInput
    honeyLogs?: HoneyLogCreateNestedManyWithoutLivestockInput
    weightLogs?: WeightLogCreateNestedManyWithoutLivestockInput
    metrics?: LivestockMetricCreateNestedManyWithoutLivestockInput
  }

  export type LivestockUncheckedCreateWithoutWoolLogsInput = {
    id?: string
    userId: string
    animalType: string
    specificType?: string | null
    breed?: string | null
    birthDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    lastMilkAlertAt?: Date | string | null
    weightKg?: number | null
    healthStatus?: string | null
    dailyFeedKg?: number | null
    vaccineStatus?: string | null
    lastCheckupDate?: Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    milkLogs?: MilkLogUncheckedCreateNestedManyWithoutLivestockInput
    eggLogs?: EggLogUncheckedCreateNestedManyWithoutLivestockInput
    honeyLogs?: HoneyLogUncheckedCreateNestedManyWithoutLivestockInput
    weightLogs?: WeightLogUncheckedCreateNestedManyWithoutLivestockInput
    metrics?: LivestockMetricUncheckedCreateNestedManyWithoutLivestockInput
  }

  export type LivestockCreateOrConnectWithoutWoolLogsInput = {
    where: LivestockWhereUniqueInput
    create: XOR<LivestockCreateWithoutWoolLogsInput, LivestockUncheckedCreateWithoutWoolLogsInput>
  }

  export type LivestockUpsertWithoutWoolLogsInput = {
    update: XOR<LivestockUpdateWithoutWoolLogsInput, LivestockUncheckedUpdateWithoutWoolLogsInput>
    create: XOR<LivestockCreateWithoutWoolLogsInput, LivestockUncheckedCreateWithoutWoolLogsInput>
    where?: LivestockWhereInput
  }

  export type LivestockUpdateToOneWithWhereWithoutWoolLogsInput = {
    where?: LivestockWhereInput
    data: XOR<LivestockUpdateWithoutWoolLogsInput, LivestockUncheckedUpdateWithoutWoolLogsInput>
  }

  export type LivestockUpdateWithoutWoolLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    animalType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMilkAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dailyFeedKg?: NullableFloatFieldUpdateOperationsInput | number | null
    vaccineStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lastCheckupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutLivestockNestedInput
    milkLogs?: MilkLogUpdateManyWithoutLivestockNestedInput
    eggLogs?: EggLogUpdateManyWithoutLivestockNestedInput
    honeyLogs?: HoneyLogUpdateManyWithoutLivestockNestedInput
    weightLogs?: WeightLogUpdateManyWithoutLivestockNestedInput
    metrics?: LivestockMetricUpdateManyWithoutLivestockNestedInput
  }

  export type LivestockUncheckedUpdateWithoutWoolLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    animalType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMilkAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dailyFeedKg?: NullableFloatFieldUpdateOperationsInput | number | null
    vaccineStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lastCheckupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    milkLogs?: MilkLogUncheckedUpdateManyWithoutLivestockNestedInput
    eggLogs?: EggLogUncheckedUpdateManyWithoutLivestockNestedInput
    honeyLogs?: HoneyLogUncheckedUpdateManyWithoutLivestockNestedInput
    weightLogs?: WeightLogUncheckedUpdateManyWithoutLivestockNestedInput
    metrics?: LivestockMetricUncheckedUpdateManyWithoutLivestockNestedInput
  }

  export type LivestockCreateWithoutWeightLogsInput = {
    id?: string
    animalType: string
    specificType?: string | null
    breed?: string | null
    birthDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    lastMilkAlertAt?: Date | string | null
    weightKg?: number | null
    healthStatus?: string | null
    dailyFeedKg?: number | null
    vaccineStatus?: string | null
    lastCheckupDate?: Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutLivestockInput
    milkLogs?: MilkLogCreateNestedManyWithoutLivestockInput
    eggLogs?: EggLogCreateNestedManyWithoutLivestockInput
    honeyLogs?: HoneyLogCreateNestedManyWithoutLivestockInput
    woolLogs?: WoolLogCreateNestedManyWithoutLivestockInput
    metrics?: LivestockMetricCreateNestedManyWithoutLivestockInput
  }

  export type LivestockUncheckedCreateWithoutWeightLogsInput = {
    id?: string
    userId: string
    animalType: string
    specificType?: string | null
    breed?: string | null
    birthDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    lastMilkAlertAt?: Date | string | null
    weightKg?: number | null
    healthStatus?: string | null
    dailyFeedKg?: number | null
    vaccineStatus?: string | null
    lastCheckupDate?: Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    milkLogs?: MilkLogUncheckedCreateNestedManyWithoutLivestockInput
    eggLogs?: EggLogUncheckedCreateNestedManyWithoutLivestockInput
    honeyLogs?: HoneyLogUncheckedCreateNestedManyWithoutLivestockInput
    woolLogs?: WoolLogUncheckedCreateNestedManyWithoutLivestockInput
    metrics?: LivestockMetricUncheckedCreateNestedManyWithoutLivestockInput
  }

  export type LivestockCreateOrConnectWithoutWeightLogsInput = {
    where: LivestockWhereUniqueInput
    create: XOR<LivestockCreateWithoutWeightLogsInput, LivestockUncheckedCreateWithoutWeightLogsInput>
  }

  export type LivestockUpsertWithoutWeightLogsInput = {
    update: XOR<LivestockUpdateWithoutWeightLogsInput, LivestockUncheckedUpdateWithoutWeightLogsInput>
    create: XOR<LivestockCreateWithoutWeightLogsInput, LivestockUncheckedCreateWithoutWeightLogsInput>
    where?: LivestockWhereInput
  }

  export type LivestockUpdateToOneWithWhereWithoutWeightLogsInput = {
    where?: LivestockWhereInput
    data: XOR<LivestockUpdateWithoutWeightLogsInput, LivestockUncheckedUpdateWithoutWeightLogsInput>
  }

  export type LivestockUpdateWithoutWeightLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    animalType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMilkAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dailyFeedKg?: NullableFloatFieldUpdateOperationsInput | number | null
    vaccineStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lastCheckupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutLivestockNestedInput
    milkLogs?: MilkLogUpdateManyWithoutLivestockNestedInput
    eggLogs?: EggLogUpdateManyWithoutLivestockNestedInput
    honeyLogs?: HoneyLogUpdateManyWithoutLivestockNestedInput
    woolLogs?: WoolLogUpdateManyWithoutLivestockNestedInput
    metrics?: LivestockMetricUpdateManyWithoutLivestockNestedInput
  }

  export type LivestockUncheckedUpdateWithoutWeightLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    animalType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMilkAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dailyFeedKg?: NullableFloatFieldUpdateOperationsInput | number | null
    vaccineStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lastCheckupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    milkLogs?: MilkLogUncheckedUpdateManyWithoutLivestockNestedInput
    eggLogs?: EggLogUncheckedUpdateManyWithoutLivestockNestedInput
    honeyLogs?: HoneyLogUncheckedUpdateManyWithoutLivestockNestedInput
    woolLogs?: WoolLogUncheckedUpdateManyWithoutLivestockNestedInput
    metrics?: LivestockMetricUncheckedUpdateManyWithoutLivestockNestedInput
  }

  export type LivestockCreateWithoutMetricsInput = {
    id?: string
    animalType: string
    specificType?: string | null
    breed?: string | null
    birthDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    lastMilkAlertAt?: Date | string | null
    weightKg?: number | null
    healthStatus?: string | null
    dailyFeedKg?: number | null
    vaccineStatus?: string | null
    lastCheckupDate?: Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutLivestockInput
    milkLogs?: MilkLogCreateNestedManyWithoutLivestockInput
    eggLogs?: EggLogCreateNestedManyWithoutLivestockInput
    honeyLogs?: HoneyLogCreateNestedManyWithoutLivestockInput
    woolLogs?: WoolLogCreateNestedManyWithoutLivestockInput
    weightLogs?: WeightLogCreateNestedManyWithoutLivestockInput
  }

  export type LivestockUncheckedCreateWithoutMetricsInput = {
    id?: string
    userId: string
    animalType: string
    specificType?: string | null
    breed?: string | null
    birthDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    lastMilkAlertAt?: Date | string | null
    weightKg?: number | null
    healthStatus?: string | null
    dailyFeedKg?: number | null
    vaccineStatus?: string | null
    lastCheckupDate?: Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    milkLogs?: MilkLogUncheckedCreateNestedManyWithoutLivestockInput
    eggLogs?: EggLogUncheckedCreateNestedManyWithoutLivestockInput
    honeyLogs?: HoneyLogUncheckedCreateNestedManyWithoutLivestockInput
    woolLogs?: WoolLogUncheckedCreateNestedManyWithoutLivestockInput
    weightLogs?: WeightLogUncheckedCreateNestedManyWithoutLivestockInput
  }

  export type LivestockCreateOrConnectWithoutMetricsInput = {
    where: LivestockWhereUniqueInput
    create: XOR<LivestockCreateWithoutMetricsInput, LivestockUncheckedCreateWithoutMetricsInput>
  }

  export type LivestockUpsertWithoutMetricsInput = {
    update: XOR<LivestockUpdateWithoutMetricsInput, LivestockUncheckedUpdateWithoutMetricsInput>
    create: XOR<LivestockCreateWithoutMetricsInput, LivestockUncheckedCreateWithoutMetricsInput>
    where?: LivestockWhereInput
  }

  export type LivestockUpdateToOneWithWhereWithoutMetricsInput = {
    where?: LivestockWhereInput
    data: XOR<LivestockUpdateWithoutMetricsInput, LivestockUncheckedUpdateWithoutMetricsInput>
  }

  export type LivestockUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    animalType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMilkAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dailyFeedKg?: NullableFloatFieldUpdateOperationsInput | number | null
    vaccineStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lastCheckupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutLivestockNestedInput
    milkLogs?: MilkLogUpdateManyWithoutLivestockNestedInput
    eggLogs?: EggLogUpdateManyWithoutLivestockNestedInput
    honeyLogs?: HoneyLogUpdateManyWithoutLivestockNestedInput
    woolLogs?: WoolLogUpdateManyWithoutLivestockNestedInput
    weightLogs?: WeightLogUpdateManyWithoutLivestockNestedInput
  }

  export type LivestockUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    animalType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMilkAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dailyFeedKg?: NullableFloatFieldUpdateOperationsInput | number | null
    vaccineStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lastCheckupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    milkLogs?: MilkLogUncheckedUpdateManyWithoutLivestockNestedInput
    eggLogs?: EggLogUncheckedUpdateManyWithoutLivestockNestedInput
    honeyLogs?: HoneyLogUncheckedUpdateManyWithoutLivestockNestedInput
    woolLogs?: WoolLogUncheckedUpdateManyWithoutLivestockNestedInput
    weightLogs?: WeightLogUncheckedUpdateManyWithoutLivestockNestedInput
  }

  export type CropCreateWithoutQualityLogsInput = {
    id?: string
    cropType: string
    specificType?: string | null
    plantingDate: Date | string
    harvestDate?: Date | string | null
    notes?: string | null
    areaHectares?: number | null
    pesticide?: string | null
    createdAt?: Date | string
    nextSprayDueAt?: Date | string | null
    lastSprayAlertAt?: Date | string | null
    proteinPercent?: number | null
    moisturePercent?: number | null
    sugarPercent?: number | null
    oilPercent?: number | null
    healthStatus?: string | null
    diseaseNotes?: string | null
    qualityScore?: number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutCropsInput
    sprays?: CropSprayCreateNestedManyWithoutCropInput
    harvests?: CropHarvestCreateNestedManyWithoutCropInput
    metrics?: CropMetricCreateNestedManyWithoutCropInput
  }

  export type CropUncheckedCreateWithoutQualityLogsInput = {
    id?: string
    userId: string
    cropType: string
    specificType?: string | null
    plantingDate: Date | string
    harvestDate?: Date | string | null
    notes?: string | null
    areaHectares?: number | null
    pesticide?: string | null
    createdAt?: Date | string
    nextSprayDueAt?: Date | string | null
    lastSprayAlertAt?: Date | string | null
    proteinPercent?: number | null
    moisturePercent?: number | null
    sugarPercent?: number | null
    oilPercent?: number | null
    healthStatus?: string | null
    diseaseNotes?: string | null
    qualityScore?: number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    sprays?: CropSprayUncheckedCreateNestedManyWithoutCropInput
    harvests?: CropHarvestUncheckedCreateNestedManyWithoutCropInput
    metrics?: CropMetricUncheckedCreateNestedManyWithoutCropInput
  }

  export type CropCreateOrConnectWithoutQualityLogsInput = {
    where: CropWhereUniqueInput
    create: XOR<CropCreateWithoutQualityLogsInput, CropUncheckedCreateWithoutQualityLogsInput>
  }

  export type CropUpsertWithoutQualityLogsInput = {
    update: XOR<CropUpdateWithoutQualityLogsInput, CropUncheckedUpdateWithoutQualityLogsInput>
    create: XOR<CropCreateWithoutQualityLogsInput, CropUncheckedCreateWithoutQualityLogsInput>
    where?: CropWhereInput
  }

  export type CropUpdateToOneWithWhereWithoutQualityLogsInput = {
    where?: CropWhereInput
    data: XOR<CropUpdateWithoutQualityLogsInput, CropUncheckedUpdateWithoutQualityLogsInput>
  }

  export type CropUpdateWithoutQualityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    areaHectares?: NullableFloatFieldUpdateOperationsInput | number | null
    pesticide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextSprayDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSprayAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proteinPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    moisturePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    sugarPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    oilPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diseaseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutCropsNestedInput
    sprays?: CropSprayUpdateManyWithoutCropNestedInput
    harvests?: CropHarvestUpdateManyWithoutCropNestedInput
    metrics?: CropMetricUpdateManyWithoutCropNestedInput
  }

  export type CropUncheckedUpdateWithoutQualityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cropType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    areaHectares?: NullableFloatFieldUpdateOperationsInput | number | null
    pesticide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextSprayDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSprayAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proteinPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    moisturePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    sugarPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    oilPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diseaseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    sprays?: CropSprayUncheckedUpdateManyWithoutCropNestedInput
    harvests?: CropHarvestUncheckedUpdateManyWithoutCropNestedInput
    metrics?: CropMetricUncheckedUpdateManyWithoutCropNestedInput
  }

  export type CropCreateWithoutMetricsInput = {
    id?: string
    cropType: string
    specificType?: string | null
    plantingDate: Date | string
    harvestDate?: Date | string | null
    notes?: string | null
    areaHectares?: number | null
    pesticide?: string | null
    createdAt?: Date | string
    nextSprayDueAt?: Date | string | null
    lastSprayAlertAt?: Date | string | null
    proteinPercent?: number | null
    moisturePercent?: number | null
    sugarPercent?: number | null
    oilPercent?: number | null
    healthStatus?: string | null
    diseaseNotes?: string | null
    qualityScore?: number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutCropsInput
    sprays?: CropSprayCreateNestedManyWithoutCropInput
    harvests?: CropHarvestCreateNestedManyWithoutCropInput
    qualityLogs?: CropQualityLogCreateNestedManyWithoutCropInput
  }

  export type CropUncheckedCreateWithoutMetricsInput = {
    id?: string
    userId: string
    cropType: string
    specificType?: string | null
    plantingDate: Date | string
    harvestDate?: Date | string | null
    notes?: string | null
    areaHectares?: number | null
    pesticide?: string | null
    createdAt?: Date | string
    nextSprayDueAt?: Date | string | null
    lastSprayAlertAt?: Date | string | null
    proteinPercent?: number | null
    moisturePercent?: number | null
    sugarPercent?: number | null
    oilPercent?: number | null
    healthStatus?: string | null
    diseaseNotes?: string | null
    qualityScore?: number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    sprays?: CropSprayUncheckedCreateNestedManyWithoutCropInput
    harvests?: CropHarvestUncheckedCreateNestedManyWithoutCropInput
    qualityLogs?: CropQualityLogUncheckedCreateNestedManyWithoutCropInput
  }

  export type CropCreateOrConnectWithoutMetricsInput = {
    where: CropWhereUniqueInput
    create: XOR<CropCreateWithoutMetricsInput, CropUncheckedCreateWithoutMetricsInput>
  }

  export type CropUpsertWithoutMetricsInput = {
    update: XOR<CropUpdateWithoutMetricsInput, CropUncheckedUpdateWithoutMetricsInput>
    create: XOR<CropCreateWithoutMetricsInput, CropUncheckedCreateWithoutMetricsInput>
    where?: CropWhereInput
  }

  export type CropUpdateToOneWithWhereWithoutMetricsInput = {
    where?: CropWhereInput
    data: XOR<CropUpdateWithoutMetricsInput, CropUncheckedUpdateWithoutMetricsInput>
  }

  export type CropUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    areaHectares?: NullableFloatFieldUpdateOperationsInput | number | null
    pesticide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextSprayDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSprayAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proteinPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    moisturePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    sugarPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    oilPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diseaseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutCropsNestedInput
    sprays?: CropSprayUpdateManyWithoutCropNestedInput
    harvests?: CropHarvestUpdateManyWithoutCropNestedInput
    qualityLogs?: CropQualityLogUpdateManyWithoutCropNestedInput
  }

  export type CropUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cropType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    areaHectares?: NullableFloatFieldUpdateOperationsInput | number | null
    pesticide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextSprayDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSprayAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proteinPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    moisturePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    sugarPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    oilPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diseaseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    sprays?: CropSprayUncheckedUpdateManyWithoutCropNestedInput
    harvests?: CropHarvestUncheckedUpdateManyWithoutCropNestedInput
    qualityLogs?: CropQualityLogUncheckedUpdateManyWithoutCropNestedInput
  }

  export type UserCreateWithoutListingsInput = {
    id?: string
    email: string
    password: string
    fullName?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    crops?: CropCreateNestedManyWithoutUserInput
    livestock?: LivestockCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutListingsInput = {
    id?: string
    email: string
    password: string
    fullName?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    crops?: CropUncheckedCreateNestedManyWithoutUserInput
    livestock?: LivestockUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutListingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutListingsInput, UserUncheckedCreateWithoutListingsInput>
  }

  export type UserUpsertWithoutListingsInput = {
    update: XOR<UserUpdateWithoutListingsInput, UserUncheckedUpdateWithoutListingsInput>
    create: XOR<UserCreateWithoutListingsInput, UserUncheckedCreateWithoutListingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutListingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutListingsInput, UserUncheckedUpdateWithoutListingsInput>
  }

  export type UserUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crops?: CropUpdateManyWithoutUserNestedInput
    livestock?: LivestockUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crops?: CropUncheckedUpdateManyWithoutUserNestedInput
    livestock?: LivestockUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    fullName?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    crops?: CropCreateNestedManyWithoutUserInput
    livestock?: LivestockCreateNestedManyWithoutUserInput
    listings?: MarketListingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    fullName?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    crops?: CropUncheckedCreateNestedManyWithoutUserInput
    livestock?: LivestockUncheckedCreateNestedManyWithoutUserInput
    listings?: MarketListingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crops?: CropUpdateManyWithoutUserNestedInput
    livestock?: LivestockUpdateManyWithoutUserNestedInput
    listings?: MarketListingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crops?: CropUncheckedUpdateManyWithoutUserNestedInput
    livestock?: LivestockUncheckedUpdateManyWithoutUserNestedInput
    listings?: MarketListingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CropCreateManyUserInput = {
    id?: string
    cropType: string
    specificType?: string | null
    plantingDate: Date | string
    harvestDate?: Date | string | null
    notes?: string | null
    areaHectares?: number | null
    pesticide?: string | null
    createdAt?: Date | string
    nextSprayDueAt?: Date | string | null
    lastSprayAlertAt?: Date | string | null
    proteinPercent?: number | null
    moisturePercent?: number | null
    sugarPercent?: number | null
    oilPercent?: number | null
    healthStatus?: string | null
    diseaseNotes?: string | null
    qualityScore?: number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LivestockCreateManyUserInput = {
    id?: string
    animalType: string
    specificType?: string | null
    breed?: string | null
    birthDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    lastMilkAlertAt?: Date | string | null
    weightKg?: number | null
    healthStatus?: string | null
    dailyFeedKg?: number | null
    vaccineStatus?: string | null
    lastCheckupDate?: Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MarketListingCreateManyUserInput = {
    id?: string
    itemType: $Enums.ItemType
    itemRef: string
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    body: string
    category?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type CropUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    areaHectares?: NullableFloatFieldUpdateOperationsInput | number | null
    pesticide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextSprayDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSprayAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proteinPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    moisturePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    sugarPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    oilPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diseaseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    sprays?: CropSprayUpdateManyWithoutCropNestedInput
    harvests?: CropHarvestUpdateManyWithoutCropNestedInput
    qualityLogs?: CropQualityLogUpdateManyWithoutCropNestedInput
    metrics?: CropMetricUpdateManyWithoutCropNestedInput
  }

  export type CropUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    areaHectares?: NullableFloatFieldUpdateOperationsInput | number | null
    pesticide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextSprayDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSprayAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proteinPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    moisturePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    sugarPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    oilPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diseaseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    sprays?: CropSprayUncheckedUpdateManyWithoutCropNestedInput
    harvests?: CropHarvestUncheckedUpdateManyWithoutCropNestedInput
    qualityLogs?: CropQualityLogUncheckedUpdateManyWithoutCropNestedInput
    metrics?: CropMetricUncheckedUpdateManyWithoutCropNestedInput
  }

  export type CropUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cropType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    areaHectares?: NullableFloatFieldUpdateOperationsInput | number | null
    pesticide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextSprayDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSprayAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proteinPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    moisturePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    sugarPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    oilPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diseaseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LivestockUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    animalType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMilkAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dailyFeedKg?: NullableFloatFieldUpdateOperationsInput | number | null
    vaccineStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lastCheckupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    milkLogs?: MilkLogUpdateManyWithoutLivestockNestedInput
    eggLogs?: EggLogUpdateManyWithoutLivestockNestedInput
    honeyLogs?: HoneyLogUpdateManyWithoutLivestockNestedInput
    woolLogs?: WoolLogUpdateManyWithoutLivestockNestedInput
    weightLogs?: WeightLogUpdateManyWithoutLivestockNestedInput
    metrics?: LivestockMetricUpdateManyWithoutLivestockNestedInput
  }

  export type LivestockUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    animalType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMilkAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dailyFeedKg?: NullableFloatFieldUpdateOperationsInput | number | null
    vaccineStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lastCheckupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
    milkLogs?: MilkLogUncheckedUpdateManyWithoutLivestockNestedInput
    eggLogs?: EggLogUncheckedUpdateManyWithoutLivestockNestedInput
    honeyLogs?: HoneyLogUncheckedUpdateManyWithoutLivestockNestedInput
    woolLogs?: WoolLogUncheckedUpdateManyWithoutLivestockNestedInput
    weightLogs?: WeightLogUncheckedUpdateManyWithoutLivestockNestedInput
    metrics?: LivestockMetricUncheckedUpdateManyWithoutLivestockNestedInput
  }

  export type LivestockUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    animalType?: StringFieldUpdateOperationsInput | string
    specificType?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMilkAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    healthStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dailyFeedKg?: NullableFloatFieldUpdateOperationsInput | number | null
    vaccineStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lastCheckupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customMetrics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MarketListingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRef?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketListingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRef?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketListingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRef?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropSprayCreateManyCropInput = {
    id?: string
    sprayedAt?: Date | string
    pesticide?: string | null
    createdAt?: Date | string
  }

  export type CropHarvestCreateManyCropInput = {
    id?: string
    harvestedAt?: Date | string
    amountTon: number
    yieldTonPerHa?: number | null
    createdAt?: Date | string
  }

  export type CropQualityLogCreateManyCropInput = {
    id?: string
    measuredAt?: Date | string
    proteinPercent?: number | null
    moisturePercent?: number | null
    sugarPercent?: number | null
    oilPercent?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type CropMetricCreateManyCropInput = {
    id?: string
    key: string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CropSprayUpdateWithoutCropInput = {
    id?: StringFieldUpdateOperationsInput | string
    sprayedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pesticide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropSprayUncheckedUpdateWithoutCropInput = {
    id?: StringFieldUpdateOperationsInput | string
    sprayedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pesticide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropSprayUncheckedUpdateManyWithoutCropInput = {
    id?: StringFieldUpdateOperationsInput | string
    sprayedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pesticide?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropHarvestUpdateWithoutCropInput = {
    id?: StringFieldUpdateOperationsInput | string
    harvestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountTon?: FloatFieldUpdateOperationsInput | number
    yieldTonPerHa?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropHarvestUncheckedUpdateWithoutCropInput = {
    id?: StringFieldUpdateOperationsInput | string
    harvestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountTon?: FloatFieldUpdateOperationsInput | number
    yieldTonPerHa?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropHarvestUncheckedUpdateManyWithoutCropInput = {
    id?: StringFieldUpdateOperationsInput | string
    harvestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountTon?: FloatFieldUpdateOperationsInput | number
    yieldTonPerHa?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropQualityLogUpdateWithoutCropInput = {
    id?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proteinPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    moisturePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    sugarPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    oilPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropQualityLogUncheckedUpdateWithoutCropInput = {
    id?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proteinPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    moisturePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    sugarPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    oilPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropQualityLogUncheckedUpdateManyWithoutCropInput = {
    id?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proteinPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    moisturePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    sugarPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    oilPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropMetricUpdateWithoutCropInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropMetricUncheckedUpdateWithoutCropInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropMetricUncheckedUpdateManyWithoutCropInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilkLogCreateManyLivestockInput = {
    id?: string
    measuredAt?: Date | string
    quantityL: number
    fatPercent?: number | null
    createdAt?: Date | string
  }

  export type EggLogCreateManyLivestockInput = {
    id?: string
    measuredAt?: Date | string
    eggCount: number
    avgWeightGram?: number | null
    createdAt?: Date | string
  }

  export type HoneyLogCreateManyLivestockInput = {
    id?: string
    measuredAt?: Date | string
    amountKg: number
    qualityGrade?: string | null
    createdAt?: Date | string
  }

  export type WoolLogCreateManyLivestockInput = {
    id?: string
    shearedAt?: Date | string
    amountKg: number
    qualityGrade?: string | null
    createdAt?: Date | string
  }

  export type WeightLogCreateManyLivestockInput = {
    id?: string
    measuredAt?: Date | string
    weightKg: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type LivestockMetricCreateManyLivestockInput = {
    id?: string
    key: string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MilkLogUpdateWithoutLivestockInput = {
    id?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantityL?: FloatFieldUpdateOperationsInput | number
    fatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilkLogUncheckedUpdateWithoutLivestockInput = {
    id?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantityL?: FloatFieldUpdateOperationsInput | number
    fatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilkLogUncheckedUpdateManyWithoutLivestockInput = {
    id?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantityL?: FloatFieldUpdateOperationsInput | number
    fatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EggLogUpdateWithoutLivestockInput = {
    id?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eggCount?: IntFieldUpdateOperationsInput | number
    avgWeightGram?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EggLogUncheckedUpdateWithoutLivestockInput = {
    id?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eggCount?: IntFieldUpdateOperationsInput | number
    avgWeightGram?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EggLogUncheckedUpdateManyWithoutLivestockInput = {
    id?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eggCount?: IntFieldUpdateOperationsInput | number
    avgWeightGram?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoneyLogUpdateWithoutLivestockInput = {
    id?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountKg?: FloatFieldUpdateOperationsInput | number
    qualityGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoneyLogUncheckedUpdateWithoutLivestockInput = {
    id?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountKg?: FloatFieldUpdateOperationsInput | number
    qualityGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoneyLogUncheckedUpdateManyWithoutLivestockInput = {
    id?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountKg?: FloatFieldUpdateOperationsInput | number
    qualityGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WoolLogUpdateWithoutLivestockInput = {
    id?: StringFieldUpdateOperationsInput | string
    shearedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountKg?: FloatFieldUpdateOperationsInput | number
    qualityGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WoolLogUncheckedUpdateWithoutLivestockInput = {
    id?: StringFieldUpdateOperationsInput | string
    shearedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountKg?: FloatFieldUpdateOperationsInput | number
    qualityGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WoolLogUncheckedUpdateManyWithoutLivestockInput = {
    id?: StringFieldUpdateOperationsInput | string
    shearedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountKg?: FloatFieldUpdateOperationsInput | number
    qualityGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeightLogUpdateWithoutLivestockInput = {
    id?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weightKg?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeightLogUncheckedUpdateWithoutLivestockInput = {
    id?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weightKg?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeightLogUncheckedUpdateManyWithoutLivestockInput = {
    id?: StringFieldUpdateOperationsInput | string
    measuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weightKg?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LivestockMetricUpdateWithoutLivestockInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LivestockMetricUncheckedUpdateWithoutLivestockInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LivestockMetricUncheckedUpdateManyWithoutLivestockInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}